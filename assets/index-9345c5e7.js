(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) a(s); new MutationObserver(s => { for (const r of s) if (r.type === "childList") for (const i of r.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && a(i) }).observe(document, { childList: !0, subtree: !0 }); function t(s) { const r = {}; return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function a(s) { if (s.ep) return; s.ep = !0; const r = t(s); fetch(s.href, r) } })(); function Za(n) { return n !== null && typeof n == "object" && "constructor" in n && n.constructor === Object } function Na(n = {}, e = {}) { Object.keys(e).forEach(t => { typeof n[t] > "u" ? n[t] = e[t] : Za(e[t]) && Za(n[t]) && Object.keys(e[t]).length > 0 && Na(n[t], e[t]) }) } const as = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function ee() { const n = typeof document < "u" ? document : {}; return Na(n, as), n } const Gs = { document: as, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(n) { return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0) }, cancelAnimationFrame(n) { typeof setTimeout > "u" || clearTimeout(n) } }; function U() { const n = typeof window < "u" ? window : {}; return Na(n, Gs), n } function Us(n) { const e = n.__proto__; Object.defineProperty(n, "__proto__", { get() { return e }, set(t) { e.__proto__ = t } }) } class nt extends Array { constructor(e) { typeof e == "number" ? super(e) : (super(...e || []), Us(this)) } } function Lt(n = []) { const e = []; return n.forEach(t => { Array.isArray(t) ? e.push(...Lt(t)) : e.push(t) }), e } function ns(n, e) { return Array.prototype.filter.call(n, e) } function _s(n) { const e = []; for (let t = 0; t < n.length; t += 1)e.indexOf(n[t]) === -1 && e.push(n[t]); return e } function Ks(n) { return n.toLowerCase().replace(/-(.)/g, (e, t) => t.toUpperCase()) } function Qs(n, e) { if (typeof n != "string") return [n]; const t = [], a = e.querySelectorAll(n); for (let s = 0; s < a.length; s += 1)t.push(a[s]); return t } function oe(n, e) { const t = U(), a = ee(); let s = []; if (!e && n instanceof nt) return n; if (!n) return new nt(s); if (typeof n == "string") { const r = n.trim(); if (r.indexOf("<") >= 0 && r.indexOf(">") >= 0) { let i = "div"; r.indexOf("<li") === 0 && (i = "ul"), r.indexOf("<tr") === 0 && (i = "tbody"), (r.indexOf("<td") === 0 || r.indexOf("<th") === 0) && (i = "tr"), r.indexOf("<tbody") === 0 && (i = "table"), r.indexOf("<option") === 0 && (i = "select"); const o = a.createElement(i); o.innerHTML = r; for (let l = 0; l < o.childNodes.length; l += 1)s.push(o.childNodes[l]) } else s = Qs(n.trim(), e || a) } else if (n.nodeType || n === t || n === a) s.push(n); else if (Array.isArray(n)) { if (n instanceof nt) return n; s = n } return new nt(_s(s)) } oe.fn = nt.prototype; function Zs(...n) { const e = Lt(n.map(t => t.split(" "))); return this.forEach(t => { t.classList.add(...e) }), this } function Js(...n) { const e = Lt(n.map(t => t.split(" "))); return this.forEach(t => { t.classList.remove(...e) }), this } function er(...n) { const e = Lt(n.map(t => t.split(" "))); this.forEach(t => { e.forEach(a => { t.classList.toggle(a) }) }) } function tr(...n) { const e = Lt(n.map(t => t.split(" "))); return ns(this, t => e.filter(a => t.classList.contains(a)).length > 0).length > 0 } function ar(n, e) { if (arguments.length === 1 && typeof n == "string") return this[0] ? this[0].getAttribute(n) : void 0; for (let t = 0; t < this.length; t += 1)if (arguments.length === 2) this[t].setAttribute(n, e); else for (const a in n) this[t][a] = n[a], this[t].setAttribute(a, n[a]); return this } function nr(n) { for (let e = 0; e < this.length; e += 1)this[e].removeAttribute(n); return this } function sr(n, e) { if (arguments.length === 1 && typeof n == "string") { if (this[0]) return this[0][n] } else { for (let t = 0; t < this.length; t += 1)if (arguments.length === 2) this[t][n] = e; else for (const a in n) this[t][a] = n[a]; return this } return this } function rr(n, e) { let t; if (typeof e > "u") { if (t = this[0], !t) return; if (t.dom7ElementDataStorage && n in t.dom7ElementDataStorage) return t.dom7ElementDataStorage[n]; const a = t.getAttribute(`data-${n}`); return a || void 0 } for (let a = 0; a < this.length; a += 1)t = this[a], t.dom7ElementDataStorage || (t.dom7ElementDataStorage = {}), t.dom7ElementDataStorage[n] = e; return this } function ir(n) { for (let e = 0; e < this.length; e += 1) { const t = this[e]; t.dom7ElementDataStorage && t.dom7ElementDataStorage[n] && (t.dom7ElementDataStorage[n] = null, delete t.dom7ElementDataStorage[n]) } } function or() { const n = this[0]; if (!n) return; const e = {}; if (n.dataset) for (const t in n.dataset) e[t] = n.dataset[t]; else for (let t = 0; t < n.attributes.length; t += 1) { const a = n.attributes[t]; a.name.indexOf("data-") >= 0 && (e[Ks(a.name.split("data-")[1])] = a.value) } for (const t in e) e[t] === "false" ? e[t] = !1 : e[t] === "true" ? e[t] = !0 : parseFloat(e[t]) === e[t] * 1 && (e[t] *= 1); return e } function lr(n) { if (typeof n > "u") { const e = this[0]; if (!e) return; if (e.multiple && e.nodeName.toLowerCase() === "select") { const t = []; for (let a = 0; a < e.selectedOptions.length; a += 1)t.push(e.selectedOptions[a].value); return t } return e.value } for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (Array.isArray(n) && t.multiple && t.nodeName.toLowerCase() === "select") for (let a = 0; a < t.options.length; a += 1)t.options[a].selected = n.indexOf(t.options[a].value) >= 0; else t.value = n } return this } function cr(n) { return this.val(n) } function dr(n) { for (let e = 0; e < this.length; e += 1)this[e].style.transform = n; return this } function ur(n) { for (let e = 0; e < this.length; e += 1)this[e].style.transitionDuration = typeof n != "string" ? `${n}ms` : n; return this } function pr(...n) { let [e, t, a, s] = n; typeof n[1] == "function" && ([e, a, s] = n, t = void 0), s || (s = !1); function r(c) { const d = c.target; if (!d) return; const u = c.target.dom7EventData || []; if (u.indexOf(c) < 0 && u.unshift(c), oe(d).is(t)) a.apply(d, u); else { const p = oe(d).parents(); for (let m = 0; m < p.length; m += 1)oe(p[m]).is(t) && a.apply(p[m], u) } } function i(c) { const d = c && c.target ? c.target.dom7EventData || [] : []; d.indexOf(c) < 0 && d.unshift(c), a.apply(this, d) } const o = e.split(" "); let l; for (let c = 0; c < this.length; c += 1) { const d = this[c]; if (t) for (l = 0; l < o.length; l += 1) { const u = o[l]; d.dom7LiveListeners || (d.dom7LiveListeners = {}), d.dom7LiveListeners[u] || (d.dom7LiveListeners[u] = []), d.dom7LiveListeners[u].push({ listener: a, proxyListener: r }), d.addEventListener(u, r, s) } else for (l = 0; l < o.length; l += 1) { const u = o[l]; d.dom7Listeners || (d.dom7Listeners = {}), d.dom7Listeners[u] || (d.dom7Listeners[u] = []), d.dom7Listeners[u].push({ listener: a, proxyListener: i }), d.addEventListener(u, i, s) } } return this } function fr(...n) { let [e, t, a, s] = n; typeof n[1] == "function" && ([e, a, s] = n, t = void 0), s || (s = !1); const r = e.split(" "); for (let i = 0; i < r.length; i += 1) { const o = r[i]; for (let l = 0; l < this.length; l += 1) { const c = this[l]; let d; if (!t && c.dom7Listeners ? d = c.dom7Listeners[o] : t && c.dom7LiveListeners && (d = c.dom7LiveListeners[o]), d && d.length) for (let u = d.length - 1; u >= 0; u -= 1) { const p = d[u]; a && p.listener === a || a && p.listener && p.listener.dom7proxy && p.listener.dom7proxy === a ? (c.removeEventListener(o, p.proxyListener, s), d.splice(u, 1)) : a || (c.removeEventListener(o, p.proxyListener, s), d.splice(u, 1)) } } } return this } function hr(...n) { const e = this; let [t, a, s, r] = n; typeof n[1] == "function" && ([t, s, r] = n, a = void 0); function i(...o) { s.apply(this, o), e.off(t, a, i, r), i.dom7proxy && delete i.dom7proxy } return i.dom7proxy = s, e.on(t, a, i, r) } function mr(...n) { const e = U(), t = n[0].split(" "), a = n[1]; for (let s = 0; s < t.length; s += 1) { const r = t[s]; for (let i = 0; i < this.length; i += 1) { const o = this[i]; if (e.CustomEvent) { const l = new e.CustomEvent(r, { detail: a, bubbles: !0, cancelable: !0 }); o.dom7EventData = n.filter((c, d) => d > 0), o.dispatchEvent(l), o.dom7EventData = [], delete o.dom7EventData } } } return this } function gr(n) { const e = this; function t(a) { a.target === this && (n.call(this, a), e.off("transitionstart", t)) } return n && e.on("transitionstart", t), this } function vr(n) { const e = this; function t(a) { a.target === this && (n.call(this, a), e.off("transitionend", t)) } return n && e.on("transitionend", t), this } function br(n) { const e = this; function t(a) { a.target === this && (n.call(this, a), e.off("animationend", t)) } return n && e.on("animationend", t), this } function yr() { const n = U(); return this[0] === n ? n.innerWidth : this.length > 0 ? parseFloat(this.css("width")) : null } function Er(n) { if (this.length > 0) { if (n) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null } function wr() { const n = U(); return this[0] === n ? n.innerHeight : this.length > 0 ? parseFloat(this.css("height")) : null } function Cr(n) { if (this.length > 0) { if (n) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null } function $r() { if (this.length > 0) { const n = U(), e = ee(), t = this[0], a = t.getBoundingClientRect(), s = e.body, r = t.clientTop || s.clientTop || 0, i = t.clientLeft || s.clientLeft || 0, o = t === n ? n.scrollY : t.scrollTop, l = t === n ? n.scrollX : t.scrollLeft; return { top: a.top + o - r, left: a.left + l - i } } return null } function xr() { for (let n = 0; n < this.length; n += 1)this[n].style.display = "none"; return this } function kr() { const n = U(); for (let e = 0; e < this.length; e += 1) { const t = this[e]; t.style.display === "none" && (t.style.display = ""), n.getComputedStyle(t, null).getPropertyValue("display") === "none" && (t.style.display = "block") } return this } function Tr() { const n = U(); return this[0] ? n.getComputedStyle(this[0], null) : {} } function Sr(n, e) { const t = U(); let a; if (arguments.length === 1) if (typeof n == "string") { if (this[0]) return t.getComputedStyle(this[0], null).getPropertyValue(n) } else { for (a = 0; a < this.length; a += 1)for (const s in n) this[a].style[s] = n[s]; return this } if (arguments.length === 2 && typeof n == "string") { for (a = 0; a < this.length; a += 1)this[a].style[n] = e; return this } return this } function Mr(n) { return n ? (this.forEach((e, t) => { n.apply(e, [e, t]) }), this) : this } function Pr(n) { const e = ns(this, n); return oe(e) } function Ar(n) { if (typeof n > "u") return this[0] ? this[0].innerHTML : null; for (let e = 0; e < this.length; e += 1)this[e].innerHTML = n; return this } function Ir(n) { if (typeof n > "u") return this[0] ? this[0].textContent.trim() : null; for (let e = 0; e < this.length; e += 1)this[e].textContent = n; return this } function Or(n) { const e = U(), t = ee(), a = this[0]; let s, r; if (!a || typeof n > "u") return !1; if (typeof n == "string") { if (a.matches) return a.matches(n); if (a.webkitMatchesSelector) return a.webkitMatchesSelector(n); if (a.msMatchesSelector) return a.msMatchesSelector(n); for (s = oe(n), r = 0; r < s.length; r += 1)if (s[r] === a) return !0; return !1 } if (n === t) return a === t; if (n === e) return a === e; if (n.nodeType || n instanceof nt) { for (s = n.nodeType ? [n] : n, r = 0; r < s.length; r += 1)if (s[r] === a) return !0; return !1 } return !1 } function Br() { let n = this[0], e; if (n) { for (e = 0; (n = n.previousSibling) !== null;)n.nodeType === 1 && (e += 1); return e } } function Dr(n) { if (typeof n > "u") return this; const e = this.length; if (n > e - 1) return oe([]); if (n < 0) { const t = e + n; return t < 0 ? oe([]) : oe([this[t]]) } return oe([this[n]]) } function Lr(...n) { let e; const t = ee(); for (let a = 0; a < n.length; a += 1) { e = n[a]; for (let s = 0; s < this.length; s += 1)if (typeof e == "string") { const r = t.createElement("div"); for (r.innerHTML = e; r.firstChild;)this[s].appendChild(r.firstChild) } else if (e instanceof nt) for (let r = 0; r < e.length; r += 1)this[s].appendChild(e[r]); else this[s].appendChild(e) } return this } function Rr(n) { return oe(n).append(this), this } function Hr(n) { const e = ee(); let t, a; for (t = 0; t < this.length; t += 1)if (typeof n == "string") { const s = e.createElement("div"); for (s.innerHTML = n, a = s.childNodes.length - 1; a >= 0; a -= 1)this[t].insertBefore(s.childNodes[a], this[t].childNodes[0]) } else if (n instanceof nt) for (a = 0; a < n.length; a += 1)this[t].insertBefore(n[a], this[t].childNodes[0]); else this[t].insertBefore(n, this[t].childNodes[0]); return this } function zr(n) { return oe(n).prepend(this), this } function Fr(n) { const e = oe(n); for (let t = 0; t < this.length; t += 1)if (e.length === 1) e[0].parentNode.insertBefore(this[t], e[0]); else if (e.length > 1) for (let a = 0; a < e.length; a += 1)e[a].parentNode.insertBefore(this[t].cloneNode(!0), e[a]) } function Vr(n) { const e = oe(n); for (let t = 0; t < this.length; t += 1)if (e.length === 1) e[0].parentNode.insertBefore(this[t], e[0].nextSibling); else if (e.length > 1) for (let a = 0; a < e.length; a += 1)e[a].parentNode.insertBefore(this[t].cloneNode(!0), e[a].nextSibling) } function Nr(n) { return this.length > 0 ? n ? this[0].nextElementSibling && oe(this[0].nextElementSibling).is(n) ? oe([this[0].nextElementSibling]) : oe([]) : this[0].nextElementSibling ? oe([this[0].nextElementSibling]) : oe([]) : oe([]) } function Yr(n) { const e = []; let t = this[0]; if (!t) return oe([]); for (; t.nextElementSibling;) { const a = t.nextElementSibling; n ? oe(a).is(n) && e.push(a) : e.push(a), t = a } return oe(e) } function qr(n) { if (this.length > 0) { const e = this[0]; return n ? e.previousElementSibling && oe(e.previousElementSibling).is(n) ? oe([e.previousElementSibling]) : oe([]) : e.previousElementSibling ? oe([e.previousElementSibling]) : oe([]) } return oe([]) } function jr(n) { const e = []; let t = this[0]; if (!t) return oe([]); for (; t.previousElementSibling;) { const a = t.previousElementSibling; n ? oe(a).is(n) && e.push(a) : e.push(a), t = a } return oe(e) } function Wr(n) { return this.nextAll(n).add(this.prevAll(n)) } function Xr(n) { const e = []; for (let t = 0; t < this.length; t += 1)this[t].parentNode !== null && (n ? oe(this[t].parentNode).is(n) && e.push(this[t].parentNode) : e.push(this[t].parentNode)); return oe(e) } function Gr(n) { const e = []; for (let t = 0; t < this.length; t += 1) { let a = this[t].parentNode; for (; a;)n ? oe(a).is(n) && e.push(a) : e.push(a), a = a.parentNode } return oe(e) } function Ur(n) { let e = this; return typeof n > "u" ? oe([]) : (e.is(n) || (e = e.parents(n).eq(0)), e) } function _r(n) { const e = []; for (let t = 0; t < this.length; t += 1) { const a = this[t].querySelectorAll(n); for (let s = 0; s < a.length; s += 1)e.push(a[s]) } return oe(e) } function Kr(n) { const e = []; for (let t = 0; t < this.length; t += 1) { const a = this[t].children; for (let s = 0; s < a.length; s += 1)(!n || oe(a[s]).is(n)) && e.push(a[s]) } return oe(e) } function Qr() { for (let n = 0; n < this.length; n += 1)this[n].parentNode && this[n].parentNode.removeChild(this[n]); return this } function Zr() { return this.remove() } function Jr(...n) { const e = this; let t, a; for (t = 0; t < n.length; t += 1) { const s = oe(n[t]); for (a = 0; a < s.length; a += 1)e.push(s[a]) } return e } function ei() { for (let n = 0; n < this.length; n += 1) { const e = this[n]; if (e.nodeType === 1) { for (let t = 0; t < e.childNodes.length; t += 1)e.childNodes[t].parentNode && e.childNodes[t].parentNode.removeChild(e.childNodes[t]); e.textContent = "" } } return this } function ti(...n) { const e = U(); let [t, a, s, r, i] = n; return n.length === 4 && typeof r == "function" && (i = r, [t, a, s, i, r] = n), typeof r > "u" && (r = "swing"), this.each(function () { const l = this; let c, d, u, p, m, f, h, b, g = a > 0 || a === 0, v = t > 0 || t === 0; if (typeof r > "u" && (r = "swing"), g && (c = l.scrollTop, s || (l.scrollTop = a)), v && (d = l.scrollLeft, s || (l.scrollLeft = t)), !s) return; g && (u = l.scrollHeight - l.offsetHeight, m = Math.max(Math.min(a, u), 0)), v && (p = l.scrollWidth - l.offsetWidth, f = Math.max(Math.min(t, p), 0)); let E = null; g && m === c && (g = !1), v && f === d && (v = !1); function $(w = new Date().getTime()) { E === null && (E = w); const C = Math.max(Math.min((w - E) / s, 1), 0), k = r === "linear" ? C : .5 - Math.cos(C * Math.PI) / 2; let M; if (g && (h = c + k * (m - c)), v && (b = d + k * (f - d)), g && m > c && h >= m && (l.scrollTop = m, M = !0), g && m < c && h <= m && (l.scrollTop = m, M = !0), v && f > d && b >= f && (l.scrollLeft = f, M = !0), v && f < d && b <= f && (l.scrollLeft = f, M = !0), M) { i && i(); return } g && (l.scrollTop = h), v && (l.scrollLeft = b), e.requestAnimationFrame($) } e.requestAnimationFrame($) }) } function ai(...n) { let [e, t, a, s] = n; n.length === 3 && typeof a == "function" && ([e, t, s, a] = n); const r = this; return typeof e > "u" ? r.length > 0 ? r[0].scrollTop : null : r.scrollTo(void 0, e, t, a, s) } function ni(...n) { let [e, t, a, s] = n; n.length === 3 && typeof a == "function" && ([e, t, s, a] = n); const r = this; return typeof e > "u" ? r.length > 0 ? r[0].scrollLeft : null : r.scrollTo(e, void 0, t, a, s) } function si(n, e) { const t = U(), a = this, s = { props: Object.assign({}, n), params: Object.assign({ duration: 300, easing: "swing" }, e), elements: a, animating: !1, que: [], easingProgress(i, o) { return i === "swing" ? .5 - Math.cos(o * Math.PI) / 2 : typeof i == "function" ? i(o) : o }, stop() { s.frameId && t.cancelAnimationFrame(s.frameId), s.animating = !1, s.elements.each(i => { const o = i; delete o.dom7AnimateInstance }), s.que = [] }, done(i) { if (s.animating = !1, s.elements.each(o => { const l = o; delete l.dom7AnimateInstance }), i && i(a), s.que.length > 0) { const o = s.que.shift(); s.animate(o[0], o[1]) } }, animate(i, o) { if (s.animating) return s.que.push([i, o]), s; const l = []; s.elements.each((b, g) => { let v, E, $, w, C; b.dom7AnimateInstance || (s.elements[g].dom7AnimateInstance = s), l[g] = { container: b }, Object.keys(i).forEach(k => { v = t.getComputedStyle(b, null).getPropertyValue(k).replace(",", "."), E = parseFloat(v), $ = v.replace(E, ""), w = parseFloat(i[k]), C = i[k] + $, l[g][k] = { initialFullValue: v, initialValue: E, unit: $, finalValue: w, finalFullValue: C, currentValue: E } }) }); let c = null, d, u = 0, p = 0, m, f = !1; s.animating = !0; function h() { d = new Date().getTime(); let b, g; f || (f = !0, o.begin && o.begin(a)), c === null && (c = d), o.progress && o.progress(a, Math.max(Math.min((d - c) / o.duration, 1), 0), c + o.duration - d < 0 ? 0 : c + o.duration - d, c), l.forEach(v => { const E = v; m || E.done || Object.keys(i).forEach($ => { if (m || E.done) return; b = Math.max(Math.min((d - c) / o.duration, 1), 0), g = s.easingProgress(o.easing, b); const { initialValue: w, finalValue: C, unit: k } = E[$]; E[$].currentValue = w + g * (C - w); const M = E[$].currentValue; if ((C > w && M >= C || C < w && M <= C) && (E.container.style[$] = C + k, p += 1, p === Object.keys(i).length && (E.done = !0, u += 1), u === l.length && (m = !0)), m) { s.done(o.complete); return } E.container.style[$] = M + k }) }), !m && (s.frameId = t.requestAnimationFrame(h)) } return s.frameId = t.requestAnimationFrame(h), s } }; if (s.elements.length === 0) return a; let r; for (let i = 0; i < s.elements.length; i += 1)s.elements[i].dom7AnimateInstance ? r = s.elements[i].dom7AnimateInstance : s.elements[i].dom7AnimateInstance = s; return r || (r = s), n === "stop" ? r.stop() : r.animate(s.props, s.params), a } function ri() { const n = this; for (let e = 0; e < n.length; e += 1)n[e].dom7AnimateInstance && n[e].dom7AnimateInstance.stop() } const ii = "resize scroll".split(" "); function Ce(n) { function e(...t) { if (typeof t[0] > "u") { for (let a = 0; a < this.length; a += 1)ii.indexOf(n) < 0 && (n in this[a] ? this[a][n]() : oe(this[a]).trigger(n)); return this } return this.on(n, ...t) } return e } const oi = Ce("click"), li = Ce("blur"), ci = Ce("focus"), di = Ce("focusin"), ui = Ce("focusout"), pi = Ce("keyup"), fi = Ce("keydown"), hi = Ce("keypress"), mi = Ce("submit"), gi = Ce("change"), vi = Ce("mousedown"), bi = Ce("mousemove"), yi = Ce("mouseup"), Ei = Ce("mouseenter"), wi = Ce("mouseleave"), Ci = Ce("mouseout"), $i = Ce("mouseover"), xi = Ce("touchstart"), ki = Ce("touchend"), Ti = Ce("touchmove"), Si = Ce("resize"), Mi = Ce("scroll"), Ja = Object.freeze(Object.defineProperty({ __proto__: null, $: oe, add: Jr, addClass: Zs, animate: si, animationEnd: br, append: Lr, appendTo: Rr, attr: ar, blur: li, change: gi, children: Kr, click: oi, closest: Ur, css: Sr, data: rr, dataset: or, default: oe, detach: Zr, each: Mr, empty: ei, eq: Dr, filter: Pr, find: _r, focus: ci, focusin: di, focusout: ui, hasClass: tr, height: wr, hide: xr, html: Ar, index: Br, insertAfter: Vr, insertBefore: Fr, is: Or, keydown: fi, keypress: hi, keyup: pi, mousedown: vi, mouseenter: Ei, mouseleave: wi, mousemove: bi, mouseout: Ci, mouseover: $i, mouseup: yi, next: Nr, nextAll: Yr, off: fr, offset: $r, on: pr, once: hr, outerHeight: Cr, outerWidth: Er, parent: Xr, parents: Gr, prepend: Hr, prependTo: zr, prev: qr, prevAll: jr, prop: sr, remove: Qr, removeAttr: nr, removeClass: Js, removeData: ir, resize: Si, scroll: Mi, scrollLeft: ni, scrollTo: ti, scrollTop: ai, show: kr, siblings: Wr, stop: ri, styles: Tr, submit: mi, text: Ir, toggleClass: er, touchend: ki, touchmove: Ti, touchstart: xi, transform: dr, transition: ur, transitionEnd: vr, transitionStart: gr, trigger: mr, val: lr, value: cr, width: yr }, Symbol.toStringTag, { value: "Module" })); Object.keys(Ja).forEach(n => { n !== "$" && (oe.fn[n] = Ja[n]) }); const y = oe; function et(n) { return n < 0 ? -1 : n === 0 ? 0 : 1 } function en(n, e, t) { return (1 - t) * n + t * e } function Pi(n, e, t) { return t < n ? n : t > e ? e : t } function Ya(n) { return (n %= 360) < 0 && (n += 360), n } function Ai(n, e) { return Ya(e - n) <= 180 ? 1 : -1 } function Ii(n, e) { return 180 - Math.abs(Math.abs(n - e) - 180) } function Ma(n, e) { return [n[0] * e[0][0] + n[1] * e[0][1] + n[2] * e[0][2], n[0] * e[1][0] + n[1] * e[1][1] + n[2] * e[1][2], n[0] * e[2][0] + n[1] * e[2][1] + n[2] * e[2][2]] } const Oi = [[.41233895, .35762064, .18051042], [.2126, .7152, .0722], [.01932141, .11916382, .95034478]], Bi = [[3.2413774792388685, -1.5376652402851851, -.49885366846268053], [-.9691452513005321, 1.8758853451067872, .04156585616912061], [.05562093689691305, -.20395524564742123, 1.0571799111220335]], Di = [95.047, 100, 108.883]; function qa(n, e, t) { return (255 << 24 | (255 & n) << 16 | (255 & e) << 8 | 255 & t) >>> 0 } function tn(n) { return qa(ot(n[0]), ot(n[1]), ot(n[2])) } function ss(n) { return n >> 16 & 255 } function rs(n) { return n >> 8 & 255 } function is(n) { return 255 & n } function Li(n, e, t) { const a = Bi, s = a[0][0] * n + a[0][1] * e + a[0][2] * t, r = a[1][0] * n + a[1][1] * e + a[1][2] * t, i = a[2][0] * n + a[2][1] * e + a[2][2] * t; return qa(ot(s), ot(r), ot(i)) } function Ri(n) { return Ma([vt(ss(n)), vt(rs(n)), vt(is(n))], Oi) } function Hi(n) { const e = ot(Gt(n)); return qa(e, e, e) } function Pa(n) { return 116 * Fi(Ri(n)[1] / 100) - 16 } function Gt(n) { return 100 * Vi((n + 16) / 116) } function vt(n) { const e = n / 255; return e <= .040449936 ? e / 12.92 * 100 : 100 * Math.pow((e + .055) / 1.055, 2.4) } function ot(n) { const e = n / 100; let t = 0; return t = e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055, Pi(0, 255, Math.round(255 * t)) } function zi() { return Di } function Fi(n) { return n > 216 / 24389 ? Math.pow(n, 1 / 3) : (903.2962962962963 * n + 16) / 116 } function Vi(n) { const e = n * n * n; return e > 216 / 24389 ? e : (116 * n - 16) / 903.2962962962963 } class Ke { static make(e, t, a, s, r) { e === void 0 && (e = zi()), t === void 0 && (t = 200 / Math.PI * Gt(50) / 100), a === void 0 && (a = 50), s === void 0 && (s = 2), r === void 0 && (r = !1); const i = e, o = .401288 * i[0] + .650173 * i[1] + -.051461 * i[2], l = -.250268 * i[0] + 1.204414 * i[1] + .045854 * i[2], c = -.002079 * i[0] + .048952 * i[1] + .953127 * i[2], d = .8 + s / 10, u = d >= .9 ? en(.59, .69, 10 * (d - .9)) : en(.525, .59, 10 * (d - .8)); let p = r ? 1 : d * (1 - 1 / 3.6 * Math.exp((-t - 42) / 92)); p = p > 1 ? 1 : p < 0 ? 0 : p; const m = d, f = [p * (100 / o) + 1 - p, p * (100 / l) + 1 - p, p * (100 / c) + 1 - p], h = 1 / (5 * t + 1), b = h * h * h * h, g = 1 - b, v = b * t + .1 * g * g * Math.cbrt(5 * t), E = Gt(a) / e[1], $ = 1.48 + Math.sqrt(E), w = .725 / Math.pow(E, .2), C = w, k = [Math.pow(v * f[0] * o / 100, .42), Math.pow(v * f[1] * l / 100, .42), Math.pow(v * f[2] * c / 100, .42)], M = [400 * k[0] / (k[0] + 27.13), 400 * k[1] / (k[1] + 27.13), 400 * k[2] / (k[2] + 27.13)]; return new Ke(E, (2 * M[0] + M[1] + .05 * M[2]) * w, w, C, u, m, f, v, Math.pow(v, .25), $) } constructor(e, t, a, s, r, i, o, l, c, d) { this.n = e, this.aw = t, this.nbb = a, this.ncb = s, this.c = r, this.nc = i, this.rgbD = o, this.fl = l, this.fLRoot = c, this.z = d } } Ke.DEFAULT = Ke.make(); class Te { constructor(e, t, a, s, r, i, o, l, c) { this.hue = e, this.chroma = t, this.j = a, this.q = s, this.m = r, this.s = i, this.jstar = o, this.astar = l, this.bstar = c } distance(e) { const t = this.jstar - e.jstar, a = this.astar - e.astar, s = this.bstar - e.bstar, r = Math.sqrt(t * t + a * a + s * s); return 1.41 * Math.pow(r, .63) } static fromInt(e) { return Te.fromIntInViewingConditions(e, Ke.DEFAULT) } static fromIntInViewingConditions(e, t) { const a = (65280 & e) >> 8, s = 255 & e, r = vt((16711680 & e) >> 16), i = vt(a), o = vt(s), l = .41233895 * r + .35762064 * i + .18051042 * o, c = .2126 * r + .7152 * i + .0722 * o, d = .01932141 * r + .11916382 * i + .95034478 * o, u = .401288 * l + .650173 * c - .051461 * d, p = -.250268 * l + 1.204414 * c + .045854 * d, m = -.002079 * l + .048952 * c + .953127 * d, f = t.rgbD[0] * u, h = t.rgbD[1] * p, b = t.rgbD[2] * m, g = Math.pow(t.fl * Math.abs(f) / 100, .42), v = Math.pow(t.fl * Math.abs(h) / 100, .42), E = Math.pow(t.fl * Math.abs(b) / 100, .42), $ = 400 * et(f) * g / (g + 27.13), w = 400 * et(h) * v / (v + 27.13), C = 400 * et(b) * E / (E + 27.13), k = (11 * $ + -12 * w + C) / 11, M = ($ + w - 2 * C) / 9, A = (20 * $ + 20 * w + 21 * C) / 20, O = (40 * $ + 20 * w + C) / 20, S = 180 * Math.atan2(M, k) / Math.PI, P = S < 0 ? S + 360 : S >= 360 ? S - 360 : S, T = P * Math.PI / 180, I = O * t.nbb, H = 100 * Math.pow(I / t.aw, t.c * t.z), D = 4 / t.c * Math.sqrt(H / 100) * (t.aw + 4) * t.fLRoot, z = P < 20.14 ? P + 360 : P, B = 5e4 / 13 * (.25 * (Math.cos(z * Math.PI / 180 + 2) + 3.8)) * t.nc * t.ncb * Math.sqrt(k * k + M * M) / (A + .305), L = Math.pow(B, .9) * Math.pow(1.64 - Math.pow(.29, t.n), .73), N = L * Math.sqrt(H / 100), F = N * t.fLRoot, V = 50 * Math.sqrt(L * t.c / (t.aw + 4)), _ = (1 + 100 * .007) * H / (1 + .007 * H), J = 1 / .0228 * Math.log(1 + .0228 * F), Q = J * Math.cos(T), j = J * Math.sin(T); return new Te(P, N, H, D, F, V, _, Q, j) } static fromJch(e, t, a) { return Te.fromJchInViewingConditions(e, t, a, Ke.DEFAULT) } static fromJchInViewingConditions(e, t, a, s) { const r = 4 / s.c * Math.sqrt(e / 100) * (s.aw + 4) * s.fLRoot, i = t * s.fLRoot, o = t / Math.sqrt(e / 100), l = 50 * Math.sqrt(o * s.c / (s.aw + 4)), c = a * Math.PI / 180, d = (1 + 100 * .007) * e / (1 + .007 * e), u = 1 / .0228 * Math.log(1 + .0228 * i), p = u * Math.cos(c), m = u * Math.sin(c); return new Te(a, t, e, r, i, l, d, p, m) } static fromUcs(e, t, a) { return Te.fromUcsInViewingConditions(e, t, a, Ke.DEFAULT) } static fromUcsInViewingConditions(e, t, a, s) { const r = t, i = a, o = Math.sqrt(r * r + i * i), l = (Math.exp(.0228 * o) - 1) / .0228 / s.fLRoot; let c = Math.atan2(i, r) * (180 / Math.PI); c < 0 && (c += 360); const d = e / (1 - .007 * (e - 100)); return Te.fromJchInViewingConditions(d, l, c, s) } toInt() { return this.viewed(Ke.DEFAULT) } viewed(e) { const t = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), a = Math.pow(t / Math.pow(1.64 - Math.pow(.29, e.n), .73), 1 / .9), s = this.hue * Math.PI / 180, r = .25 * (Math.cos(s + 2) + 3.8), i = e.aw * Math.pow(this.j / 100, 1 / e.c / e.z), o = r * (5e4 / 13) * e.nc * e.ncb, l = i / e.nbb, c = Math.sin(s), d = Math.cos(s), u = 23 * (l + .305) * a / (23 * o + 11 * a * d + 108 * a * c), p = u * d, m = u * c, f = (460 * l + 451 * p + 288 * m) / 1403, h = (460 * l - 891 * p - 261 * m) / 1403, b = (460 * l - 220 * p - 6300 * m) / 1403, g = Math.max(0, 27.13 * Math.abs(f) / (400 - Math.abs(f))), v = et(f) * (100 / e.fl) * Math.pow(g, 1 / .42), E = Math.max(0, 27.13 * Math.abs(h) / (400 - Math.abs(h))), $ = et(h) * (100 / e.fl) * Math.pow(E, 1 / .42), w = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), C = et(b) * (100 / e.fl) * Math.pow(w, 1 / .42), k = v / e.rgbD[0], M = $ / e.rgbD[1], A = C / e.rgbD[2]; return Li(1.86206786 * k - 1.01125463 * M + .14918677 * A, .38752654 * k + .62144744 * M - .00897398 * A, -.0158415 * k - .03412294 * M + 1.04996444 * A) } } class re { static sanitizeRadians(e) { return (e + 8 * Math.PI) % (2 * Math.PI) } static trueDelinearized(e) { const t = e / 100; let a = 0; return a = t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, 255 * a } static chromaticAdaptation(e) { const t = Math.pow(Math.abs(e), .42); return 400 * et(e) * t / (t + 27.13) } static hueOf(e) { const t = Ma(e, re.SCALED_DISCOUNT_FROM_LINRGB), a = re.chromaticAdaptation(t[0]), s = re.chromaticAdaptation(t[1]), r = re.chromaticAdaptation(t[2]), i = (11 * a + -12 * s + r) / 11, o = (a + s - 2 * r) / 9; return Math.atan2(o, i) } static areInCyclicOrder(e, t, a) { return re.sanitizeRadians(t - e) < re.sanitizeRadians(a - e) } static intercept(e, t, a) { return (t - e) / (a - e) } static lerpPoint(e, t, a) { return [e[0] + (a[0] - e[0]) * t, e[1] + (a[1] - e[1]) * t, e[2] + (a[2] - e[2]) * t] } static setCoordinate(e, t, a, s) { const r = re.intercept(e[s], t, a[s]); return re.lerpPoint(e, r, a) } static isBounded(e) { return 0 <= e && e <= 100 } static nthVertex(e, t) { const a = re.Y_FROM_LINRGB[0], s = re.Y_FROM_LINRGB[1], r = re.Y_FROM_LINRGB[2], i = t % 4 <= 1 ? 0 : 100, o = t % 2 == 0 ? 0 : 100; if (t < 4) { const l = i, c = o, d = (e - l * s - c * r) / a; return re.isBounded(d) ? [d, l, c] : [-1, -1, -1] } if (t < 8) { const l = i, c = o, d = (e - c * a - l * r) / s; return re.isBounded(d) ? [c, d, l] : [-1, -1, -1] } { const l = i, c = o, d = (e - l * a - c * s) / r; return re.isBounded(d) ? [l, c, d] : [-1, -1, -1] } } static bisectToSegment(e, t) { let a = [-1, -1, -1], s = a, r = 0, i = 0, o = !1, l = !0; for (let c = 0; c < 12; c++) { const d = re.nthVertex(e, c); if (d[0] < 0) continue; const u = re.hueOf(d); o ? (l || re.areInCyclicOrder(r, u, i)) && (l = !1, re.areInCyclicOrder(r, t, u) ? (s = d, i = u) : (a = d, r = u)) : (a = d, s = d, r = u, i = u, o = !0) } return [a, s] } static midpoint(e, t) { return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2, (e[2] + t[2]) / 2] } static criticalPlaneBelow(e) { return Math.floor(e - .5) } static criticalPlaneAbove(e) { return Math.ceil(e - .5) } static bisectToLimit(e, t) { const a = re.bisectToSegment(e, t); let s = a[0], r = re.hueOf(s), i = a[1]; for (let o = 0; o < 3; o++)if (s[o] !== i[o]) { let l = -1, c = 255; s[o] < i[o] ? (l = re.criticalPlaneBelow(re.trueDelinearized(s[o])), c = re.criticalPlaneAbove(re.trueDelinearized(i[o]))) : (l = re.criticalPlaneAbove(re.trueDelinearized(s[o])), c = re.criticalPlaneBelow(re.trueDelinearized(i[o]))); for (let d = 0; d < 8 && !(Math.abs(c - l) <= 1); d++) { const u = Math.floor((l + c) / 2), p = re.CRITICAL_PLANES[u], m = re.setCoordinate(s, p, i, o), f = re.hueOf(m); re.areInCyclicOrder(r, t, f) ? (i = m, c = u) : (s = m, r = f, l = u) } } return re.midpoint(s, i) } static inverseChromaticAdaptation(e) { const t = Math.abs(e), a = Math.max(0, 27.13 * t / (400 - t)); return et(e) * Math.pow(a, 1 / .42) } static findResultByJ(e, t, a) { let s = 11 * Math.sqrt(a); const r = Ke.DEFAULT, i = 1 / Math.pow(1.64 - Math.pow(.29, r.n), .73), o = .25 * (Math.cos(e + 2) + 3.8) * (5e4 / 13) * r.nc * r.ncb, l = Math.sin(e), c = Math.cos(e); for (let d = 0; d < 5; d++) { const u = s / 100, p = t === 0 || s === 0 ? 0 : t / Math.sqrt(u), m = Math.pow(p * i, 1 / .9), f = r.aw * Math.pow(u, 1 / r.c / r.z) / r.nbb, h = 23 * (f + .305) * m / (23 * o + 11 * m * c + 108 * m * l), b = h * c, g = h * l, v = (460 * f + 451 * b + 288 * g) / 1403, E = (460 * f - 891 * b - 261 * g) / 1403, $ = (460 * f - 220 * b - 6300 * g) / 1403, w = Ma([re.inverseChromaticAdaptation(v), re.inverseChromaticAdaptation(E), re.inverseChromaticAdaptation($)], re.LINRGB_FROM_SCALED_DISCOUNT); if (w[0] < 0 || w[1] < 0 || w[2] < 0) return 0; const C = re.Y_FROM_LINRGB[0], k = re.Y_FROM_LINRGB[1], M = re.Y_FROM_LINRGB[2], A = C * w[0] + k * w[1] + M * w[2]; if (A <= 0) return 0; if (d === 4 || Math.abs(A - a) < .002) return w[0] > 100.01 || w[1] > 100.01 || w[2] > 100.01 ? 0 : tn(w); s -= (A - a) * s / (2 * A) } return 0 } static solveToInt(e, t, a) { if (t < 1e-4 || a < 1e-4 || a > 99.9999) return Hi(a); const s = (e = Ya(e)) / 180 * Math.PI, r = Gt(a), i = re.findResultByJ(s, t, r); return i !== 0 ? i : tn(re.bisectToLimit(r, s)) } static solveToCam(e, t, a) { return Te.fromInt(re.solveToInt(e, t, a)) } } re.SCALED_DISCOUNT_FROM_LINRGB = [[.001200833568784504, .002389694492170889, .0002795742885861124], [.0005891086651375999, .0029785502573438758, .0003270666104008398], [.00010146692491640572, .0005364214359186694, .0032979401770712076]], re.LINRGB_FROM_SCALED_DISCOUNT = [[1373.2198709594231, -1100.4251190754821, -7.278681089101213], [-271.815969077903, 559.6580465940733, -32.46047482791194], [1.9622899599665666, -57.173814538844006, 308.7233197812385]], re.Y_FROM_LINRGB = [.2126, .7152, .0722], re.CRITICAL_PLANES = [.015176349177441876, .045529047532325624, .07588174588720938, .10623444424209313, .13658714259697685, .16693984095186062, .19729253930674434, .2276452376616281, .2579979360165119, .28835063437139563, .3188300904430532, .350925934958123, .3848314933096426, .42057480301049466, .458183274052838, .4976837250274023, .5391024159806381, .5824650784040898, .6277969426914107, .6751227633498623, .7244668422128921, .775853049866786, .829304845476233, .8848452951698498, .942497089126609, 1.0022825574869039, 1.0642236851973577, 1.1283421258858297, 1.1946592148522128, 1.2631959812511864, 1.3339731595349034, 1.407011200216447, 1.4823302800086415, 1.5599503113873272, 1.6398909516233677, 1.7221716113234105, 1.8068114625156377, 1.8938294463134073, 1.9832442801866852, 2.075074464868551, 2.1693382909216234, 2.2660538449872063, 2.36523901573795, 2.4669114995532007, 2.5710888059345764, 2.6777882626779785, 2.7870270208169257, 2.898822059350997, 3.0131901897720907, 3.1301480604002863, 3.2497121605402226, 3.3718988244681087, 3.4967242352587946, 3.624204428461639, 3.754355295633311, 3.887192587735158, 4.022731918402185, 4.160988767090289, 4.301978482107941, 4.445716283538092, 4.592217266055746, 4.741496401646282, 4.893568542229298, 5.048448422192488, 5.20615066083972, 5.3666897647573375, 5.5300801301023865, 5.696336044816294, 5.865471690767354, 6.037501145825082, 6.212438385869475, 6.390297286737924, 6.571091626112461, 6.7548350853498045, 6.941541251256611, 7.131223617812143, 7.323895587840543, 7.5195704746346665, 7.7182615035334345, 7.919981813454504, 8.124744458384042, 8.332562408825165, 8.543448553206703, 8.757415699253682, 8.974476575321063, 9.194643831691977, 9.417930041841839, 9.644347703669503, 9.873909240696694, 10.106627003236781, 10.342513269534024, 10.58158024687427, 10.8238400726681, 11.069304815507364, 11.317986476196008, 11.569896988756009, 11.825048221409341, 12.083451977536606, 12.345119996613247, 12.610063955123938, 12.878295467455942, 13.149826086772048, 13.42466730586372, 13.702830557985108, 13.984327217668513, 14.269168601521828, 14.55736596900856, 14.848930523210871, 15.143873411576273, 15.44220572664832, 15.743938506781891, 16.04908273684337, 16.35764934889634, 16.66964922287304, 16.985093187232053, 17.30399201960269, 17.62635644741625, 17.95219714852476, 18.281524751807332, 18.614349837764564, 18.95068293910138, 19.290534541298456, 19.633915083172692, 19.98083495742689, 20.331304511189067, 20.685334046541502, 21.042933821039977, 21.404114048223256, 21.76888489811322, 22.137256497705877, 22.50923893145328, 22.884842241736916, 23.264076429332462, 23.6469514538663, 24.033477234264016, 24.42366364919083, 24.817520537484558, 25.21505769858089, 25.61628489293138, 26.021211842414342, 26.429848230738664, 26.842203703840827, 27.258287870275353, 27.678110301598522, 28.10168053274597, 28.529008062403893, 28.96010235337422, 29.39497283293396, 29.83362889318845, 30.276079891419332, 30.722335150426627, 31.172403958865512, 31.62629557157785, 32.08401920991837, 32.54558406207592, 33.010999283389665, 33.4802739966603, 33.953417292456834, 34.430438229418264, 34.911345834551085, 35.39614910352207, 35.88485700094671, 36.37747846067349, 36.87402238606382, 37.37449765026789, 37.87891309649659, 38.38727753828926, 38.89959975977785, 39.41588851594697, 39.93615253289054, 40.460400508064545, 40.98864111053629, 41.520882981230194, 42.05713473317016, 42.597404951718396, 43.141702194811224, 43.6900349931913, 44.24241185063697, 44.798841244188324, 45.35933162437017, 45.92389141541209, 46.49252901546552, 47.065252796817916, 47.64207110610409, 48.22299226451468, 48.808024568002054, 49.3971762874833, 49.9904556690408, 50.587870934119984, 51.189430279724725, 51.79514187861014, 52.40501387947288, 53.0190544071392, 53.637271562750364, 54.259673423945976, 54.88626804504493, 55.517063457223934, 56.15206766869424, 56.79128866487574, 57.43473440856916, 58.08241284012621, 58.734331877617365, 59.39049941699807, 60.05092333227251, 60.715611475655585, 61.38457167773311, 62.057811747619894, 62.7353394731159, 63.417162620860914, 64.10328893648692, 64.79372614476921, 65.48848194977529, 66.18756403501224, 66.89098006357258, 67.59873767827808, 68.31084450182222, 69.02730813691093, 69.74813616640164, 70.47333615344107, 71.20291564160104, 71.93688215501312, 72.67524319850172, 73.41800625771542, 74.16517879925733, 74.9167682708136, 75.67278210128072, 76.43322770089146, 77.1981124613393, 77.96744375590167, 78.74122893956174, 79.51947534912904, 80.30219030335869, 81.08938110306934, 81.88105503125999, 82.67721935322541, 83.4778813166706, 84.28304815182372, 85.09272707154808, 85.90692527145302, 86.72564993000343, 87.54890820862819, 88.3767072518277, 89.2090541872801, 90.04595612594655, 90.88742016217518, 91.73345337380438, 92.58406282226491, 93.43925555268066, 94.29903859396902, 95.16341895893969, 96.03240364439274, 96.9059996312159, 97.78421388448044, 98.6670533535366, 99.55452497210776]; class Ve { static from(e, t, a) { return new Ve(re.solveToInt(e, t, a)) } static fromInt(e) { return new Ve(e) } toInt() { return this.argb } get hue() { return this.internalHue } set hue(e) { this.setInternalState(re.solveToInt(e, this.internalChroma, this.internalTone)) } get chroma() { return this.internalChroma } set chroma(e) { this.setInternalState(re.solveToInt(this.internalHue, e, this.internalTone)) } get tone() { return this.internalTone } set tone(e) { this.setInternalState(re.solveToInt(this.internalHue, this.internalChroma, e)) } constructor(e) { this.argb = e; const t = Te.fromInt(e); this.internalHue = t.hue, this.internalChroma = t.chroma, this.internalTone = Pa(e), this.argb = e } setInternalState(e) { const t = Te.fromInt(e); this.internalHue = t.hue, this.internalChroma = t.chroma, this.internalTone = Pa(e), this.argb = e } } class ja { static harmonize(e, t) { const a = Ve.fromInt(e), s = Ve.fromInt(t), r = Ii(a.hue, s.hue), i = Math.min(.5 * r, 15), o = Ya(a.hue + i * Ai(a.hue, s.hue)); return Ve.from(o, a.chroma, a.tone).toInt() } static hctHue(e, t, a) { const s = ja.cam16Ucs(e, t, a), r = Te.fromInt(s), i = Te.fromInt(e); return Ve.from(r.hue, i.chroma, Pa(e)).toInt() } static cam16Ucs(e, t, a) { const s = Te.fromInt(e), r = Te.fromInt(t), i = s.jstar, o = s.astar, l = s.bstar, c = i + (r.jstar - i) * a, d = o + (r.astar - o) * a, u = l + (r.bstar - l) * a; return Te.fromUcs(c, d, u).toInt() } } class Me { static fromInt(e) { const t = Ve.fromInt(e); return Me.fromHueAndChroma(t.hue, t.chroma) } static fromHueAndChroma(e, t) { return new Me(e, t) } constructor(e, t) { this.hue = e, this.chroma = t, this.cache = new Map } tone(e) { let t = this.cache.get(e); return t === void 0 && (t = Ve.from(this.hue, this.chroma, e).toInt(), this.cache.set(e, t)), t } } class xe { static of(e) { return new xe(e, !1) } static contentOf(e) { return new xe(e, !0) } static fromColors(e) { return xe.createPaletteFromColors(!1, e) } static contentFromColors(e) { return xe.createPaletteFromColors(!0, e) } static createPaletteFromColors(e, t) { const a = new xe(t.primary, e); if (t.secondary) { const s = new xe(t.secondary, e); a.a2 = s.a1 } if (t.tertiary) { const s = new xe(t.tertiary, e); a.a3 = s.a1 } if (t.error) { const s = new xe(t.error, e); a.error = s.a1 } if (t.neutral) { const s = new xe(t.neutral, e); a.n1 = s.n1 } if (t.neutralVariant) { const s = new xe(t.neutralVariant, e); a.n2 = s.n2 } return a } constructor(e, t) { const a = Ve.fromInt(e), s = a.hue, r = a.chroma; t ? (this.a1 = Me.fromHueAndChroma(s, r), this.a2 = Me.fromHueAndChroma(s, r / 3), this.a3 = Me.fromHueAndChroma(s + 60, r / 2), this.n1 = Me.fromHueAndChroma(s, Math.min(r / 12, 4)), this.n2 = Me.fromHueAndChroma(s, Math.min(r / 6, 8))) : (this.a1 = Me.fromHueAndChroma(s, Math.max(48, r)), this.a2 = Me.fromHueAndChroma(s, 16), this.a3 = Me.fromHueAndChroma(s + 60, 24), this.n1 = Me.fromHueAndChroma(s, 4), this.n2 = Me.fromHueAndChroma(s, 8)), this.error = Me.fromHueAndChroma(25, 84) } } class Ue { get primary() { return this.props.primary } get onPrimary() { return this.props.onPrimary } get primaryContainer() { return this.props.primaryContainer } get onPrimaryContainer() { return this.props.onPrimaryContainer } get secondary() { return this.props.secondary } get onSecondary() { return this.props.onSecondary } get secondaryContainer() { return this.props.secondaryContainer } get onSecondaryContainer() { return this.props.onSecondaryContainer } get tertiary() { return this.props.tertiary } get onTertiary() { return this.props.onTertiary } get tertiaryContainer() { return this.props.tertiaryContainer } get onTertiaryContainer() { return this.props.onTertiaryContainer } get error() { return this.props.error } get onError() { return this.props.onError } get errorContainer() { return this.props.errorContainer } get onErrorContainer() { return this.props.onErrorContainer } get background() { return this.props.background } get onBackground() { return this.props.onBackground } get surface() { return this.props.surface } get onSurface() { return this.props.onSurface } get surfaceVariant() { return this.props.surfaceVariant } get onSurfaceVariant() { return this.props.onSurfaceVariant } get outline() { return this.props.outline } get outlineVariant() { return this.props.outlineVariant } get shadow() { return this.props.shadow } get scrim() { return this.props.scrim } get inverseSurface() { return this.props.inverseSurface } get inverseOnSurface() { return this.props.inverseOnSurface } get inversePrimary() { return this.props.inversePrimary } static light(e) { return Ue.lightFromCorePalette(xe.of(e)) } static dark(e) { return Ue.darkFromCorePalette(xe.of(e)) } static lightContent(e) { return Ue.lightFromCorePalette(xe.contentOf(e)) } static darkContent(e) { return Ue.darkFromCorePalette(xe.contentOf(e)) } static lightFromCorePalette(e) { return new Ue({ primary: e.a1.tone(40), onPrimary: e.a1.tone(100), primaryContainer: e.a1.tone(90), onPrimaryContainer: e.a1.tone(10), secondary: e.a2.tone(40), onSecondary: e.a2.tone(100), secondaryContainer: e.a2.tone(90), onSecondaryContainer: e.a2.tone(10), tertiary: e.a3.tone(40), onTertiary: e.a3.tone(100), tertiaryContainer: e.a3.tone(90), onTertiaryContainer: e.a3.tone(10), error: e.error.tone(40), onError: e.error.tone(100), errorContainer: e.error.tone(90), onErrorContainer: e.error.tone(10), background: e.n1.tone(99), onBackground: e.n1.tone(10), surface: e.n1.tone(99), onSurface: e.n1.tone(10), surfaceVariant: e.n2.tone(90), onSurfaceVariant: e.n2.tone(30), outline: e.n2.tone(50), outlineVariant: e.n2.tone(80), shadow: e.n1.tone(0), scrim: e.n1.tone(0), inverseSurface: e.n1.tone(20), inverseOnSurface: e.n1.tone(95), inversePrimary: e.a1.tone(80) }) } static darkFromCorePalette(e) { return new Ue({ primary: e.a1.tone(80), onPrimary: e.a1.tone(20), primaryContainer: e.a1.tone(30), onPrimaryContainer: e.a1.tone(90), secondary: e.a2.tone(80), onSecondary: e.a2.tone(20), secondaryContainer: e.a2.tone(30), onSecondaryContainer: e.a2.tone(90), tertiary: e.a3.tone(80), onTertiary: e.a3.tone(20), tertiaryContainer: e.a3.tone(30), onTertiaryContainer: e.a3.tone(90), error: e.error.tone(80), onError: e.error.tone(20), errorContainer: e.error.tone(30), onErrorContainer: e.error.tone(80), background: e.n1.tone(10), onBackground: e.n1.tone(90), surface: e.n1.tone(10), onSurface: e.n1.tone(90), surfaceVariant: e.n2.tone(30), onSurfaceVariant: e.n2.tone(80), outline: e.n2.tone(60), outlineVariant: e.n2.tone(30), shadow: e.n1.tone(0), scrim: e.n1.tone(0), inverseSurface: e.n1.tone(90), inverseOnSurface: e.n1.tone(20), inversePrimary: e.a1.tone(40) }) } constructor(e) { this.props = e } toJSON() { return { ...this.props } } } function ht(n) { const e = ss(n), t = rs(n), a = is(n), s = [e.toString(16), t.toString(16), a.toString(16)]; for (const [r, i] of s.entries()) i.length === 1 && (s[r] = "0" + i); return "#" + s.join("") } function la(n) { const e = (n = n.replace("#", "")).length === 3, t = n.length === 6, a = n.length === 8; if (!e && !t && !a) throw new Error("unexpected hex " + n); let s = 0, r = 0, i = 0; return e ? (s = je(n.slice(0, 1).repeat(2)), r = je(n.slice(1, 2).repeat(2)), i = je(n.slice(2, 3).repeat(2))) : t ? (s = je(n.slice(0, 2)), r = je(n.slice(2, 4)), i = je(n.slice(4, 6))) : a && (s = je(n.slice(2, 4)), r = je(n.slice(4, 6)), i = je(n.slice(6, 8))), (255 << 24 | (255 & s) << 16 | (255 & r) << 8 | 255 & i) >>> 0 } function je(n) { return parseInt(n, 16) } function Ni(n, e) { e === void 0 && (e = []); const t = xe.of(n); return { source: n, schemes: { light: Ue.light(n), dark: Ue.dark(n) }, palettes: { primary: t.a1, secondary: t.a2, tertiary: t.a3, neutral: t.n1, neutralVariant: t.n2, error: t.error }, customColors: e.map(a => Yi(n, a)) } } function Yi(n, e) { let t = e.value; const a = t, s = n; e.blend && (t = ja.harmonize(a, s)); const r = xe.of(t).a1; return { color: e, value: t, light: { color: r.tone(40), onColor: r.tone(100), colorContainer: r.tone(90), onColorContainer: r.tone(10) }, dark: { color: r.tone(80), onColor: r.tone(20), colorContainer: r.tone(30), onColorContainer: r.tone(90) } } } function an(n) { const e = Math.round, t = n.length, a = {}; return n.slice(0, 3).toLowerCase() === "rgb" ? (n = n.replace(" ", "").split(","), a[0] = parseInt(n[0].slice(n[3].toLowerCase() === "a" ? 5 : 4), 10), a[1] = parseInt(n[1], 10), a[2] = parseInt(n[2], 10), a[3] = n[3] ? parseFloat(n[3]) : -1) : (t < 6 ? n = parseInt(String(n[1]) + n[1] + n[2] + n[2] + n[3] + n[3] + (t > 4 ? String(n[4]) + n[4] : ""), 16) : n = parseInt(n.slice(1), 16), a[0] = n >> 16 & 255, a[1] = n >> 8 & 255, a[2] = n & 255, a[3] = t === 9 || t === 5 ? e((n >> 24 & 255) / 255 * 1e4) / 1e4 : -1), a } function nn(n, e, t) { t === void 0 && (t = .5); const a = Math.round; n = n.trim(), e = e.trim(), t = t < 0 ? t * -1 : t; const r = an(n), i = an(e); return e[0] === "r" ? "rgb" + (e[3] === "a" ? "a(" : "(") + a((i[0] - r[0]) * t + r[0]) + "," + a((i[1] - r[1]) * t + r[1]) + "," + a((i[2] - r[2]) * t + r[2]) + (r[3] < 0 && i[3] < 0 ? "" : "," + (r[3] > -1 && i[3] > -1 ? a(((i[3] - r[3]) * t + r[3]) * 1e4) / 1e4 : i[3] < 0 ? r[3] : i[3])) + ")" : "#" + (4294967296 + (r[3] > -1 && i[3] > -1 ? a(((i[3] - r[3]) * t + r[3]) * 255) : i[3] > -1 ? a(i[3] * 255) : r[3] > -1 ? a(r[3] * 255) : 255) * 16777216 + a((i[0] - r[0]) * t + r[0]) * 65536 + a((i[1] - r[1]) * t + r[1]) * 256 + a((i[2] - r[2]) * t + r[2])).toString(16).slice(r[3] > -1 || i[3] > -1 ? 1 : 3) } const qi = function (n) { n === void 0 && (n = ""); const e = Ni(la(`#${n.replace("#", "")}`));[.05, .08, .11, .12, .14].forEach((i, o) => { e.schemes.light.props[`surface${o + 1}`] = la(nn(ht(e.schemes.light.props.surface), ht(e.schemes.light.props.primary), i)), e.schemes.dark.props[`surface${o + 1}`] = la(nn(ht(e.schemes.dark.props.surface), ht(e.schemes.dark.props.primary), i)) }); const t = i => i.split("").map(o => o.toUpperCase() === o && o !== "-" && o !== "7" ? `-${o.toLowerCase()}` : o).join(""), a = i => ["tertiary", "shadow", "scrim", "error", "background"].filter(l => i.toLowerCase().includes(l)).length > 0, s = {}, r = {}; return Object.keys(e.schemes.light.props).forEach(i => { a(i) || (s[t(`--f7-md-${i}`)] = ht(e.schemes.light.props[i])) }), Object.keys(e.schemes.dark.props).forEach(i => { a(i) || (r[t(`--f7-md-${i}`)] = ht(e.schemes.dark.props[i])) }), { light: s, dark: r } }; let sn = 0; function ji() { return sn += 1, sn } function wt(n, e) { n === void 0 && (n = "xxxxxxxxxx"), e === void 0 && (e = "0123456789abcdef"); const t = e.length; return n.replace(/x/g, () => e[Math.floor(Math.random() * t)]) } const lt = `
  <span class="preloader-inner">
    <svg viewBox="0 0 36 36">
      <circle cx="18" cy="18" r="16"></circle>
    </svg>
  </span>
`.trim(), ct = `
  <span class="preloader-inner">
    ${[0, 1, 2, 3, 4, 5, 6, 7].map(() => '<span class="preloader-inner-line"></span>').join("")}
  </span>
`.trim(); function Ne(n) { let e; return n.split("").map((t, a) => t.match(/[A-Z]/) && a !== 0 && !e ? (e = !0, `:${t.toLowerCase()}`) : t.toLowerCase()).join("") } function ve(n) { const e = n; Object.keys(e).forEach(t => { try { e[t] = null } catch { } try { delete e[t] } catch { } }) } function Aa(n) { return U().requestAnimationFrame(n) } function Wi(n) { return U().cancelAnimationFrame(n) } function $e(n, e) { return e === void 0 && (e = 0), setTimeout(n, e) } function Ae(n) { return Aa(() => { Aa(n) }) } function Ie() { return Date.now() } function Bt(n) { const e = U(), t = {}; let a = n || e.location.href, s, r, i, o; if (typeof a == "string" && a.length) for (a = a.indexOf("?") > -1 ? a.replace(/\S*\?/, "") : "", r = a.split("&").filter(l => l !== ""), o = r.length, s = 0; s < o; s += 1)i = r[s].replace(/#\S+/g, "").split("="), t[decodeURIComponent(i[0])] = typeof i[1] > "u" ? void 0 : decodeURIComponent(i.slice(1).join("=")) || ""; return t } function Ut(n, e) { e === void 0 && (e = "x"); const t = U(); let a, s, r; const i = t.getComputedStyle(n, null); return t.WebKitCSSMatrix ? (s = i.transform || i.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(o => o.replace(",", ".")).join(", ")), r = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (r = i.MozTransform || i.OTransform || i.MsTransform || i.msTransform || i.transform || i.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = r.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? s = r.m41 : a.length === 16 ? s = parseFloat(a[12]) : s = parseFloat(a[4])), e === "y" && (t.WebKitCSSMatrix ? s = r.m42 : a.length === 16 ? s = parseFloat(a[13]) : s = parseFloat(a[5])), s || 0 } function dt(n, e) { if (e === void 0 && (e = []), typeof n == "string") return n; const t = [], a = "&"; let s; function r(o) { if (e.length > 0) { let l = ""; for (let c = 0; c < e.length; c += 1)c === 0 ? l += e[c] : l += `[${encodeURIComponent(e[c])}]`; return `${l}[${encodeURIComponent(o)}]` } return encodeURIComponent(o) } function i(o) { return encodeURIComponent(o) } return Object.keys(n).forEach(o => { let l; if (Array.isArray(n[o])) { l = []; for (let c = 0; c < n[o].length; c += 1)!Array.isArray(n[o][c]) && typeof n[o][c] == "object" ? (s = e.slice(), s.push(o), s.push(String(c)), l.push(dt(n[o][c], s))) : l.push(`${r(o)}[]=${i(n[o][c])}`); l.length > 0 && t.push(l.join(a)) } else n[o] === null || n[o] === "" ? t.push(`${r(o)}=`) : typeof n[o] == "object" ? (s = e.slice(), s.push(o), l = dt(n[o], s), l !== "" && t.push(l)) : typeof n[o] < "u" && n[o] !== "" ? t.push(`${r(o)}=${i(n[o])}`) : n[o] === "" && t.push(r(o)) }), t.join(a) } function it(n) { return typeof n == "object" && n !== null && n.constructor && n.constructor === Object } function _t() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; const a = e[0]; e.splice(0, 1); const s = e; for (let r = 0; r < s.length; r += 1) { const i = e[r]; if (i != null) { const o = Object.keys(Object(i)); for (let l = 0, c = o.length; l < c; l += 1) { const d = o[l], u = Object.getOwnPropertyDescriptor(i, d); u !== void 0 && u.enumerable && (a[d] = i[d]) } } } return a } function R() { let n = !0, e, t; for (var a = arguments.length, s = new Array(a), r = 0; r < a; r++)s[r] = arguments[r]; typeof s[0] == "boolean" ? (n = s[0], e = s[1], s.splice(0, 2), t = s) : (e = s[0], s.splice(0, 1), t = s); for (let i = 0; i < t.length; i += 1) { const o = s[i]; if (o != null) { const l = Object.keys(Object(o)); for (let c = 0, d = l.length; c < d; c += 1) { const u = l[c], p = Object.getOwnPropertyDescriptor(o, u); p !== void 0 && p.enumerable && (n ? it(e[u]) && it(o[u]) ? R(e[u], o[u]) : !it(e[u]) && it(o[u]) ? (e[u] = {}, R(e[u], o[u])) : e[u] = o[u] : e[u] = o[u]) } } } return e } function Ge(n) { const e = n.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (a, s, r, i) => s + s + r + r + i + i), t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e); return t ? t.slice(1).map(a => parseInt(a, 16)) : null } function _e(n, e, t) { return `#${[n, e, t].map(s => { const r = s.toString(16); return r.length === 1 ? `0${r}` : r }).join("")}` } function Kt(n, e, t) { n /= 255, e /= 255, t /= 255; const a = Math.max(n, e, t), s = Math.min(n, e, t), r = a - s; let i; r === 0 ? i = 0 : a === n ? i = (e - t) / r % 6 : a === e ? i = (t - n) / r + 2 : a === t && (i = (n - e) / r + 4); const o = (s + a) / 2, l = r === 0 ? 0 : r / (1 - Math.abs(2 * o - 1)); return i < 0 && (i = 360 / 60 + i), [i * 60, l, o] } function bt(n, e, t) { const a = (1 - Math.abs(2 * t - 1)) * e, s = n / 60, r = a * (1 - Math.abs(s % 2 - 1)); let i; Number.isNaN(n) || typeof n > "u" ? i = [0, 0, 0] : s <= 1 ? i = [a, r, 0] : s <= 2 ? i = [r, a, 0] : s <= 3 ? i = [0, a, r] : s <= 4 ? i = [0, r, a] : s <= 5 ? i = [r, 0, a] : s <= 6 && (i = [a, 0, r]); const o = t - a / 2; return i.map(l => Math.max(0, Math.min(255, Math.round(255 * (l + o))))) } function Qe(n, e, t) { const a = { h: n, s: 0, l: 0 }, s = { h: n, s: e, b: t }; return a.l = (2 - s.s) * s.b / 2, a.s = a.l && a.l < 1 ? s.s * s.b / (a.l < .5 ? a.l * 2 : 2 - a.l * 2) : a.s, [a.h, a.s, a.l] } function Mt(n, e, t) { const a = { h: n, s: 0, b: 0 }, s = { h: n, s: e, l: t }, r = s.s * (s.l < .5 ? s.l : 1 - s.l); return a.b = s.l + r, a.s = s.l > 0 ? 2 * r / a.b : a.s, [a.h, a.s, a.b] } const ca = n => { const e = Kt(...n), t = [e[0], e[1], Math.max(0, e[2] - .08)], a = [e[0], e[1], Math.max(0, e[2] + .08)], s = _e(...bt(...t)), r = _e(...bt(...a)); return { shade: s, tint: r } }; function Ia() { let n, e; for (var t = arguments.length, a = new Array(t), s = 0; s < t; s++)a[s] = arguments[s]; if (a.length === 1 ? (n = a[0], e = Ge(n)) : a.length === 3 && (e = a, n = _e(...e)), !e) return {}; const { light: r, dark: i } = qi(n), o = ca(e), l = ca(Ge(r["--f7-md-primary"])), c = ca(Ge(i["--f7-md-primary"])); return Object.keys(r).forEach(d => { d.includes("surface-") && (r[`${d}-rgb`] = Ge(r[d])) }), Object.keys(i).forEach(d => { d.includes("surface-") && (i[`${d}-rgb`] = Ge(i[d])) }), { ios: { "--f7-theme-color": "var(--f7-ios-primary)", "--f7-theme-color-rgb": "var(--f7-ios-primary-rgb)", "--f7-theme-color-shade": "var(--f7-ios-primary-shade)", "--f7-theme-color-tint": "var(--f7-ios-primary-tint)" }, md: { "--f7-theme-color": "var(--f7-md-primary)", "--f7-theme-color-rgb": "var(--f7-md-primary-rgb)", "--f7-theme-color-shade": "var(--f7-md-primary-shade)", "--f7-theme-color-tint": "var(--f7-md-primary-tint)" }, light: { "--f7-ios-primary": n, "--f7-ios-primary-shade": o.shade, "--f7-ios-primary-tint": o.tint, "--f7-ios-primary-rgb": e.join(", "), "--f7-md-primary-shade": l.shade, "--f7-md-primary-tint": l.tint, "--f7-md-primary-rgb": Ge(r["--f7-md-primary"]).join(", "), ...r }, dark: { "--f7-md-primary-shade": c.shade, "--f7-md-primary-tint": c.tint, "--f7-md-primary-rgb": Ge(i["--f7-md-primary"]).join(", "), ...i } } } function Se(n, e) { Object.keys(e).forEach(t => { it(e[t]) && Object.keys(e[t]).forEach(a => { typeof e[t][a] == "function" && (e[t][a] = e[t][a].bind(n)) }), n[t] = e[t] }) } function na() { const n = []; for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; return t.forEach(s => { Array.isArray(s) ? n.push(...na(...s)) : n.push(s) }), n } function Xi(n) {
  n === void 0 && (n = {}); const e = i => { let o = ""; return Object.keys(i).forEach(l => { o += `${l}:${i[l]};` }), o }, t = Ia(n.primary), a = [":root{", e(t.light), "--swiper-theme-color:var(--f7-theme-color);", ...Object.keys(n).map(i => `--f7-color-${i}: ${n[i]};`), "}", ".dark{", e(t.dark), "}", ".ios, .ios .dark{", e(t.ios), "}", ".md, .md .dark{", e(t.md), "}"].join(""), s = {}; Object.keys(n).forEach(i => { const o = n[i]; s[i] = Ia(o) }); let r = ""; return Object.keys(n).forEach(i => {
    const { light: o, dark: l, ios: c, md: d } = s[i], u = `
    --f7-ios-primary: #ffffff;
    --f7-ios-primary-shade: #ebebeb;
    --f7-ios-primary-tint: #ffffff;
    --f7-ios-primary-rgb: 255, 255, 255;
    --f7-md-primary-shade: #eee;
    --f7-md-primary-tint: #fff;
    --f7-md-primary-rgb: 255, 255, 255;
    --f7-md-primary: #fff;
    --f7-md-on-primary: #000;
    --f7-md-primary-container: #fff;
    --f7-md-on-primary-container: #000;
    --f7-md-secondary: #fff;
    --f7-md-on-secondary: #000;
    --f7-md-secondary-container: #555;
    --f7-md-on-secondary-container: #fff;
    --f7-md-surface: #fff;
    --f7-md-on-surface: #000;
    --f7-md-surface-variant: #333;
    --f7-md-on-surface-variant: #fff;
    --f7-md-outline: #fff;
    --f7-md-outline-variant: #fff;
    --f7-md-inverse-surface: #000;
    --f7-md-inverse-on-surface: #fff;
    --f7-md-inverse-primary: #000;
    --f7-md-surface-1: #f8f8f8;
    --f7-md-surface-2: #f1f1f1;
    --f7-md-surface-3: #e7e7e7;
    --f7-md-surface-4: #e1e1e1;
    --f7-md-surface-5: #d7d7d7;
    --f7-md-surface-variant-rgb: 51, 51, 51;
    --f7-md-on-surface-variant-rgb: 255, 255, 255;
    --f7-md-surface-1-rgb: 248, 248, 248;
    --f7-md-surface-2-rgb: 241, 241, 241;
    --f7-md-surface-3-rgb: 231, 231, 231;
    --f7-md-surface-4-rgb: 225, 225, 225;
    --f7-md-surface-5-rgb: 215, 215, 215;
    `, p = `
    --f7-ios-primary: #000;
    --f7-ios-primary-shade: #000;
    --f7-ios-primary-tint: #232323;
    --f7-ios-primary-rgb: 0, 0, 0;
    --f7-md-primary-shade: #000;
    --f7-md-primary-tint: #232323;
    --f7-md-primary-rgb: 0, 0, 0;
    --f7-md-primary: #000;
    --f7-md-on-primary: #fff;
    --f7-md-primary-container: #000;
    --f7-md-on-primary-container: #fff;
    --f7-md-secondary: #000;
    --f7-md-on-secondary: #fff;
    --f7-md-secondary-container: #aaa;
    --f7-md-on-secondary-container: #000;
    --f7-md-surface: #000;
    --f7-md-on-surface: #fff;
    --f7-md-surface-variant: #ccc;
    --f7-md-on-surface-variant: #000;
    --f7-md-outline: #000;
    --f7-md-outline-variant: #000;
    --f7-md-inverse-surface: #fff;
    --f7-md-inverse-on-surface: #000;
    --f7-md-inverse-primary: #fff;
    --f7-md-surface-1: #070707;
    --f7-md-surface-2: #161616;
    --f7-md-surface-3: #232323;
    --f7-md-surface-4: #303030;
    --f7-md-surface-5: #373737;
    --f7-md-surface-variant-rgb: 204, 204, 204;
    --f7-md-on-surface-variant-rgb: 0, 0, 0;
    --f7-md-surface-1-rgb: 7, 7, 7;
    --f7-md-surface-2-rgb: 22, 22, 22;
    --f7-md-surface-3-rgb: 35, 35, 35;
    --f7-md-surface-4-rgb: 48, 48, 48;
    --f7-md-surface-5-rgb: 55, 55, 55;
    `, m = i === "white" ? u : i === "black" ? p : e(o), f = i === "white" ? u : i === "black" ? p : e(l); r += [`.color-${i} {`, m, "--swiper-theme-color: var(--f7-theme-color);", "}", `.color-${i}.dark, .color-${i} .dark, .dark .color-${i} {`, f, "--swiper-theme-color: var(--f7-theme-color);", "}", `.ios .color-${i}, .ios.color-${i}, .ios .dark .color-${i}, .ios .dark.color-${i} {`, e(c), "}", `.md .color-${i}, .md.color-${i}, .md .dark .color-${i}, .md .dark.color-${i} {`, e(d), "}", `.text-color-${i} {`, `--f7-theme-color-text-color: ${n[i]};`, "}", `.bg-color-${i} {`, `--f7-theme-color-bg-color: ${n[i]};`, "}", `.border-color-${i} {`, `--f7-theme-color-border-color: ${n[i]};`, "}", `.ripple-color-${i} {`, `--f7-theme-color-ripple-color: rgba(${o["--f7-ios-primary-rgb"]}, 0.3);`, "}"].join("")
  }), `${a}${r}`
} const rn = Object.freeze(Object.defineProperty({ __proto__: null, bindMethods: Se, cancelAnimationFrame: Wi, colorHexToRgb: Ge, colorHsbToHsl: Qe, colorHslToHsb: Mt, colorHslToRgb: bt, colorRgbToHex: _e, colorRgbToHsl: Kt, colorThemeCSSProperties: Ia, colorThemeCSSStyles: Xi, deleteProps: ve, eventNameToColonCase: Ne, extend: R, flattenArray: na, getTranslate: Ut, id: wt, iosPreloaderContent: ct, isObject: it, mdPreloaderContent: lt, merge: _t, nextFrame: Ae, nextTick: $e, now: Ie, parseUrlQuery: Bt, requestAnimationFrame: Aa, serializeObject: dt, uniqueNumber: ji }, Symbol.toStringTag, { value: "Module" })); let da; function Gi() { const n = U(), e = ee(); return { touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch), pointerEvents: !!n.PointerEvent && "maxTouchPoints" in n.navigator && n.navigator.maxTouchPoints >= 0, passiveListener: function () { let a = !1; try { const s = Object.defineProperty({}, "passive", { get() { a = !0 } }); n.addEventListener("testPassiveListener", null, s) } catch { } return a }(), intersectionObserver: function () { return "IntersectionObserver" in n }() } } function Ee() { return da || (da = Gi()), da } let ua; function Ui(n) { let { userAgent: e } = n === void 0 ? {} : n; const t = Ee(), a = U(), s = a.navigator.platform, r = e || a.navigator.userAgent, i = { ios: !1, android: !1, androidChrome: !1, desktop: !1, iphone: !1, ipod: !1, ipad: !1, edge: !1, ie: !1, firefox: !1, macos: !1, windows: !1, cordova: !!a.cordova, electron: !1, capacitor: !!a.Capacitor, nwjs: !1 }, o = a.screen.width, l = a.screen.height, c = r.match(/(Android);?[\s\/]+([\d.]+)?/); let d = r.match(/(iPad).*OS\s([\d_]+)/); const u = r.match(/(iPod)(.*OS\s([\d_]+))?/), p = !d && r.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/), m = r.indexOf("MSIE ") >= 0 || r.indexOf("Trident/") >= 0, f = r.indexOf("Edge/") >= 0, h = r.indexOf("Gecko/") >= 0 && r.indexOf("Firefox/") >= 0, b = s === "Win32", g = r.toLowerCase().indexOf("electron") >= 0, v = typeof nw < "u" && typeof process < "u" && typeof process.versions < "u" && typeof process.versions.nw < "u"; let E = s === "MacIntel"; const $ = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; !d && E && t.touch && $.indexOf(`${o}x${l}`) >= 0 && (d = r.match(/(Version)\/([\d.]+)/), d || (d = [0, 1, "13_0_0"]), E = !1), i.ie = m, i.edge = f, i.firefox = h, c && (i.os = "android", i.osVersion = c[2], i.android = !0, i.androidChrome = r.toLowerCase().indexOf("chrome") >= 0), (d || p || u) && (i.os = "ios", i.ios = !0), p && !u && (i.osVersion = p[2].replace(/_/g, "."), i.iphone = !0), d && (i.osVersion = d[2].replace(/_/g, "."), i.ipad = !0), u && (i.osVersion = u[3] ? u[3].replace(/_/g, ".") : null, i.ipod = !0), i.ios && i.osVersion && r.indexOf("Version/") >= 0 && i.osVersion.split(".")[0] === "10" && (i.osVersion = r.toLowerCase().split("version/")[1].split(" ")[0]), i.webView = !!((p || d || u) && (r.match(/.*AppleWebKit(?!.*Safari)/i) || a.navigator.standalone)) || a.matchMedia && a.matchMedia("(display-mode: standalone)").matches, i.webview = i.webView, i.standalone = i.webView, i.desktop = !(i.ios || i.android) || g || v, i.desktop && (i.electron = g, i.nwjs = v, i.macos = E, i.windows = b, i.macos && (i.os = "macos"), i.windows && (i.os = "windows")), i.pixelRatio = a.devicePixelRatio || 1; const w = "(prefers-color-scheme: dark)", C = "(prefers-color-scheme: light)"; return i.prefersColorScheme = function () { let M; return a.matchMedia && a.matchMedia(C).matches && (M = "light"), a.matchMedia && a.matchMedia(w).matches && (M = "dark"), M }, i } function ue(n, e) { return n === void 0 && (n = {}), (!ua || e) && (ua = Ui(n)), ua } class os { constructor(e) { e === void 0 && (e = []); const t = this; t.eventsParents = e, t.eventsListeners = {} } on(e, t, a) { const s = this; if (typeof t != "function") return s; const r = a ? "unshift" : "push"; return e.split(" ").forEach(i => { s.eventsListeners[i] || (s.eventsListeners[i] = []), s.eventsListeners[i][r](t) }), s } once(e, t, a) { const s = this; if (typeof t != "function") return s; function r() { s.off(e, r), r.f7proxy && delete r.f7proxy; for (var i = arguments.length, o = new Array(i), l = 0; l < i; l++)o[l] = arguments[l]; t.apply(s, o) } return r.f7proxy = t, s.on(e, r, a) } off(e, t) { const a = this; return a.eventsListeners && e.split(" ").forEach(s => { typeof t > "u" ? a.eventsListeners[s] = [] : a.eventsListeners[s] && a.eventsListeners[s].forEach((r, i) => { (r === t || r.f7proxy && r.f7proxy === t) && a.eventsListeners[s].splice(i, 1) }) }), a } emit() { const e = this; if (!e.eventsListeners) return e; let t, a, s, r; for (var i = arguments.length, o = new Array(i), l = 0; l < i; l++)o[l] = arguments[l]; typeof o[0] == "string" || Array.isArray(o[0]) ? (t = o[0], a = o.slice(1, o.length), s = e, r = e.eventsParents) : (t = o[0].events, a = o[0].data, s = o[0].context || e, r = o[0].local ? [] : o[0].parents || e.eventsParents); const c = Array.isArray(t) ? t : t.split(" "), d = c.map(p => p.replace("local::", "")), u = c.filter(p => p.indexOf("local::") < 0); return d.forEach(p => { if (e.eventsListeners && e.eventsListeners[p]) { const m = []; e.eventsListeners[p].forEach(f => { m.push(f) }), m.forEach(f => { f.apply(s, a) }) } }), r && r.length > 0 && r.forEach(p => { p.emit(u, ...a) }), e } } class me extends os { constructor(e, t) { e === void 0 && (e = {}), t === void 0 && (t = []), super(t); const a = this; a.params = e, a.params && a.params.on && Object.keys(a.params.on).forEach(s => { a.on(s, a.params.on[s]) }) } useModuleParams(e, t) { if (e.params) { const a = {}; Object.keys(e.params).forEach(s => { typeof t[s] > "u" || (a[s] = R({}, t[s])) }), R(t, e.params), Object.keys(a).forEach(s => { R(t[s], a[s]) }) } } useModulesParams(e) { const t = this; t.modules && Object.keys(t.modules).forEach(a => { const s = t.modules[a]; s.params && R(e, s.params) }) } useModule(e, t) { e === void 0 && (e = ""), t === void 0 && (t = {}); const a = this; if (!a.modules) return; const s = typeof e == "string" ? a.modules[e] : e; s && (s.instance && Object.keys(s.instance).forEach(r => { const i = s.instance[r]; typeof i == "function" ? a[r] = i.bind(a) : a[r] = i }), s.on && a.on && Object.keys(s.on).forEach(r => { a.on(r, s.on[r]) }), s.vnode && (a.vnodeHooks || (a.vnodeHooks = {}), Object.keys(s.vnode).forEach(r => { Object.keys(s.vnode[r]).forEach(i => { const o = s.vnode[r][i]; a.vnodeHooks[i] || (a.vnodeHooks[i] = {}), a.vnodeHooks[i][r] || (a.vnodeHooks[i][r] = []), a.vnodeHooks[i][r].push(o.bind(a)) }) })), s.create && s.create.bind(a)(t)) } useModules(e) { e === void 0 && (e = {}); const t = this; t.modules && Object.keys(t.modules).forEach(a => { const s = e[a] || {}; t.useModule(a, s) }) } static set components(e) { const t = this; t.use && t.use(e) } static installModule(e) { const t = this; t.prototype.modules || (t.prototype.modules = {}); const a = e.name || `${Object.keys(t.prototype.modules).length}_${Ie()}`; if (t.prototype.modules[a] = e, e.proto && Object.keys(e.proto).forEach(o => { t.prototype[o] = e.proto[o] }), e.static && Object.keys(e.static).forEach(o => { t[o] = e.static[o] }), e.install) { for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)r[i - 1] = arguments[i]; e.install.apply(t, r) } return t } static use(e) { const t = this; if (Array.isArray(e)) return e.forEach(i => t.installModule(i)), t; for (var a = arguments.length, s = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++)s[r - 1] = arguments[r]; return t.installModule(e, ...s) } } function we(n) { n === void 0 && (n = {}); const { defaultSelector: e, constructor: t, domProp: a, app: s, addMethods: r } = n, i = { create() { for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; return s ? new t(s, ...l) : new t(...l) }, get(o) { if (o === void 0 && (o = e), o instanceof t) return o; const l = y(o); if (l.length !== 0) return l[0][a] }, destroy(o) { const l = i.get(o); if (l && l.destroy) return l.destroy() } }; return r && Array.isArray(r) && r.forEach(o => { i[o] = function (l) { l === void 0 && (l = e); const c = i.get(l); for (var d = arguments.length, u = new Array(d > 1 ? d - 1 : 0), p = 1; p < d; p++)u[p - 1] = arguments[p]; if (c && c[o]) return c[o](...u) } }), i } function Ze(n) { n === void 0 && (n = {}); const { defaultSelector: e, constructor: t, app: a } = n; return R(we({ defaultSelector: e, constructor: t, app: a, domProp: "f7Modal" }), { open(r, i, o) { let l = y(r); if (l.length > 1 && o) { const d = y(o).parents(".page"); d.length && l.each(u => { const p = y(u); p.parents(d)[0] === d[0] && (l = p) }) } if (l.length > 1 && (l = l.eq(l.length - 1)), !l.length) return; let c = l[0].f7Modal; if (!c) { const d = l.dataset(); c = new t(a, { el: l, ...d }) } return c.open(i) }, close(r, i, o) { r === void 0 && (r = e); let l = y(r); if (!l.length) return; if (l.length > 1) { let d; if (o) { const u = y(o); u.length && (d = u.parents(l)) } d && d.length > 0 ? l = d : l = l.eq(l.length - 1) } let c = l[0].f7Modal; if (!c) { const d = l.dataset(); c = new t(a, { el: l, ...d }) } return c.close(i) } }) } const on = []; function _i(n) { const e = this, t = U(), a = ee(); return new Promise((s, r) => { const i = e.instance; let o, l, c; if (!n) { r(new Error("Framework7: Lazy module must be specified")); return } function d(u) { e.use(u), i && (i.useModuleParams(u, i.params), i.useModule(u)) } if (typeof n == "string") { const u = n.match(/([a-z0-9-]*)/i); if (n.indexOf(".") < 0 && u && u[0].length === n.length) { if (!i || i && !i.params.lazyModulesPath) { r(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name')); return } o = `${i.params.lazyModulesPath}/${n}/${n}.lazy.js` } else o = n } else typeof n == "function" ? c = n : l = n; if (c) { const u = c(e, !1); if (!u) { r(new Error("Framework7: Can't find Framework7 component in specified component function")); return } if (e.prototype.modules && e.prototype.modules[u.name]) { s(); return } d(u), s() } if (l) { const u = l; if (!u) { r(new Error("Framework7: Can't find Framework7 component in specified component")); return } if (e.prototype.modules && e.prototype.modules[u.name]) { s(); return } d(u), s() } if (o) { if (on.indexOf(o) >= 0) { s(); return } on.push(o); const u = new Promise((m, f) => { fetch(o).then(h => h.text()).then(h => { const g = `f7_component_loader_callback_${wt()}`, v = a.createElement("script"); v.innerHTML = `window.${g} = function (Framework7, Framework7AutoInstallComponent) {return ${h.trim()}}`, y("head").append(v); const E = t[g]; delete t[g], y(v).remove(); const $ = E(e, !1); if (!$) { f(new Error(`Framework7: Can't find Framework7 component in ${o} file`)); return } if (e.prototype.modules && e.prototype.modules[$.name]) { m(); return } d($), m() }).catch(h => { f(h) }) }), p = new Promise(m => { fetch(o.replace(".lazy.js", i.rtl ? ".rtl.css" : ".css").replace(".js", i.rtl ? ".rtl.css" : ".css")).then(f => f.text()).then(f => { const h = a.createElement("style"); h.innerHTML = f, y("head").append(h), m() }).catch(() => { m() }) }); Promise.all([u, p]).then(() => { s() }).catch(m => { r(m) }) } }) } const x = function (n, e) { const t = e || {}; for (var a = arguments.length, s = new Array(a > 2 ? a - 2 : 0), r = 2; r < a; r++)s[r - 2] = arguments[r]; const i = s || [], o = Object.keys(t).map(c => c[0] === "_" ? t[c] ? c.replace("_", "") : "" : `${c}="${t[c]}"`).filter(c => !!c).join(" "); if (["path", "img", "circle", "polygon", "line", "input"].indexOf(n) >= 0) return `<${n} ${o} />`.trim(); const l = i.filter(c => !!c).map(c => Array.isArray(c) ? c.join("") : c).join(""); return `<${n} ${o}>${l}</${n}>`.trim() }; class Pe extends me { constructor(e) { if (e === void 0 && (e = {}), super(e), Pe.instance && typeof window < "u") throw new Error("Framework7 is already initialized and can't be initialized more than once"); const t = ue({ userAgent: e.userAgent || void 0 }), a = Ee(), s = R({}, e), r = this; r.device = t, r.support = a; const i = U(), o = ee(); Pe.instance = r; const l = { el: "body", theme: "auto", routes: [], name: "Framework7", lazyModulesPath: null, initOnDeviceReady: !0, init: !0, darkMode: void 0, iosTranslucentBars: !0, iosTranslucentModals: !0, component: void 0, componentUrl: void 0, userAgent: null, url: null, colors: { primary: "#007aff", red: "#ff3b30", green: "#4cd964", blue: "#2196f3", pink: "#ff2d55", yellow: "#ffcc00", orange: "#ff9500", purple: "#9c27b0", deeppurple: "#673ab7", lightblue: "#5ac8fa", teal: "#009688", lime: "#cddc39", deeporange: "#ff6b22", white: "#ffffff", black: "#000000" } }; return r.useModulesParams(l), r.params = R(l, e), R(r, { name: r.params.name, routes: r.params.routes, theme: function () { return r.params.theme === "auto" ? t.ios ? "ios" : "md" : r.params.theme }(), passedParams: s, online: i.navigator.onLine, colors: r.params.colors, darkMode: r.params.darkMode }), e.store && (r.params.store = e.store), r.$el && r.$el[0] && (r.$el[0].f7 = r), r.useModules(), r.initStore(), r.params.init && (t.cordova && r.params.initOnDeviceReady ? y(o).on("deviceready", () => { r.init() }) : r.init()), r } setColorTheme(e) { if (!e) return; const t = this; t.colors.primary = e, t.setColors() } setColors() { const e = this, t = ee(); e.colorsStyleEl || (e.colorsStyleEl = t.createElement("style"), t.head.appendChild(e.colorsStyleEl)), e.colorsStyleEl.textContent = e.utils.colorThemeCSSStyles(e.colors) } mount(e) { const t = this, a = U(), s = ee(), r = y(e || t.params.el).eq(0); t.$el = r, t.$el && t.$el[0] && (t.el = t.$el[0], t.el.f7 = t, t.rtl = r.css("direction") === "rtl"); const i = "(prefers-color-scheme: dark)", o = "(prefers-color-scheme: light)"; t.mq = {}, a.matchMedia && (t.mq.dark = a.matchMedia(i), t.mq.light = a.matchMedia(o)), t.colorSchemeListener = function (c) { let { matches: d, media: u } = c; if (!d) return; const p = s.querySelector("html"); u === i ? (p.classList.add("dark"), t.darkMode = !0, t.emit("darkModeChange", !0)) : u === o && (p.classList.remove("dark"), t.darkMode = !1, t.emit("darkModeChange", !1)) }, t.emit("mount") } initStore() { const e = this; typeof e.params.store < "u" && e.params.store.__store ? e.store = e.params.store : e.store = e.createStore(e.params.store) } enableAutoDarkMode() { const e = U(), t = ee(); if (!e.matchMedia) return; const a = this, s = t.querySelector("html"); a.mq.dark && a.mq.light && (a.mq.dark.addListener(a.colorSchemeListener), a.mq.light.addListener(a.colorSchemeListener)), a.mq.dark && a.mq.dark.matches ? (s.classList.add("dark"), a.darkMode = !0, a.emit("darkModeChange", !0)) : a.mq.light && a.mq.light.matches && (s.classList.remove("dark"), a.darkMode = !1, a.emit("darkModeChange", !1)) } disableAutoDarkMode() { if (!U().matchMedia) return; const t = this; t.mq.dark && t.mq.dark.removeListener(t.colorSchemeListener), t.mq.light && t.mq.light.removeListener(t.colorSchemeListener) } setDarkMode(e) { const t = this; e === "auto" ? t.enableAutoDarkMode() : (t.disableAutoDarkMode(), y("html")[e ? "addClass" : "removeClass"]("dark"), t.darkMode = e) } initAppComponent(e) { const t = this; t.router.componentLoader(t.params.component, t.params.componentUrl, { componentOptions: { el: t.$el[0] } }, a => { t.$el = y(a), t.$el[0].f7 = t, t.$elComponent = a.f7Component, t.el = t.$el[0], e && e() }, () => { }) } init(e) { const t = this; t.setColors(), t.mount(e); const a = () => { if (t.initialized) return; t.$el.addClass("framework7-initializing"), t.rtl && y("html").attr("dir", "rtl"), typeof t.params.darkMode > "u" ? t.darkMode = y("html").hasClass("dark") : t.setDarkMode(t.params.darkMode); const s = U(); s.addEventListener("offline", () => { t.online = !1, t.emit("offline"), t.emit("connection", !1) }), s.addEventListener("online", () => { t.online = !0, t.emit("online"), t.emit("connection", !0) }), t.$el.addClass("framework7-root"), y("html").removeClass("ios md").addClass(t.theme); const r = t.device; t.params.iosTranslucentBars && t.theme === "ios" && r.ios && y("html").addClass("ios-translucent-bars"), t.params.iosTranslucentModals && t.theme === "ios" && r.ios && y("html").addClass("ios-translucent-modals"), Ae(() => { t.$el.removeClass("framework7-initializing") }), t.initialized = !0, t.emit("init") }; return t.params.component || t.params.componentUrl ? t.initAppComponent(() => { a() }) : a(), t } loadModule() { return Pe.loadModule(...arguments) } loadModules() { return Pe.loadModules(...arguments) } getVnodeHooks(e, t) { const a = this; return !a.vnodeHooks || !a.vnodeHooks[e] ? [] : a.vnodeHooks[e][t] || [] } get $() { return y } static get Dom7() { return y } static get $() { return y } static get device() { return ue() } static get support() { return Ee() } static get Class() { return me } static get Events() { return os } } Pe.$jsx = x; Pe.ModalMethods = Ze; Pe.ConstructorMethods = we; Pe.loadModule = _i; Pe.loadModules = function (e) { return Promise.all(e.map(t => Pe.loadModule(t))) }; const ls = { name: "device", static: { getDevice: ue }, on: { init() { const n = ee(), e = ue(), t = [], a = n.querySelector("html"), s = n.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]'); a && (e.standalone && e.ios && s && s.content === "black-translucent" && t.push("device-full-viewport"), t.push(`device-pixel-ratio-${Math.floor(e.pixelRatio)}`), e.os && !e.desktop ? t.push(`device-${e.os}`) : e.desktop && (t.push("device-desktop"), e.os && t.push(`device-${e.os}`)), e.cordova && t.push("device-cordova"), e.capacitor && t.push("device-capacitor"), t.forEach(r => { a.classList.add(r) })) } } }, cs = { name: "support", static: { getSupport: Ee } }, ds = { name: "utils", proto: { utils: rn }, static: { utils: rn } }, us = { name: "resize", create() { const n = this; n.getSize = () => { if (!n.el) return { width: 0, height: 0, left: 0, top: 0 }; const e = n.$el.offset(), [t, a, s, r] = [n.el.offsetWidth, n.el.offsetHeight, e.left, e.top]; return n.width = t, n.height = a, n.left = s, n.top = r, { width: t, height: a, left: s, top: r } } }, on: { init() { const n = this, e = U(); n.getSize(), e.addEventListener("resize", () => { n.emit("resize") }, !1), e.addEventListener("orientationchange", () => { n.emit("orientationchange") }) }, orientationchange() { const n = ee(); ue().ipad && (n.body.scrollLeft = 0, setTimeout(() => { n.body.scrollLeft = 0 }, 0)) }, resize() { this.getSize() } } }; function Ki() { const n = this, e = ue(), t = Ee(), a = U(), s = ee(), r = n.params.touch, i = r[`${n.theme}TouchRipple`]; e.ios && e.webView && a.addEventListener("touchstart", () => { }); let o, l, c, d, u, p, m, f, h, b, g, v; function E(q) { const pe = y(q), be = pe.parents(r.activeStateElements); if (pe.closest(".no-active-state").length) return null; let he; if (pe.is(r.activeStateElements) && (he = pe), be.length > 0 && (he = he ? he.add(be) : be), he && he.length > 1) { const se = []; let Fe; for (let ne = 0; ne < he.length; ne += 1)Fe || (se.push(he[ne]), (he.eq(ne).hasClass("prevent-active-state-propagation") || he.eq(ne).hasClass("no-active-state-propagation")) && (Fe = !0)); he = y(se) } return he || pe } function $(q) { return q.parents(".page-content").length > 0 } function w() { f && f.addClass("active-state") } function C() { f && (f.removeClass("active-state"), f = null) } function k(q) { const pe = r.touchRippleElements, be = y(q); if (be.is(pe)) return be.hasClass("no-ripple") ? !1 : be; if (be.parents(pe).length > 0) { const he = be.parents(pe).eq(0); return he.hasClass("no-ripple") ? !1 : he } return !1 } function M(q, pe, be) { q && (b = n.touchRipple.create(n, q, pe, be)) } function A() { b && (b.remove(), b = void 0, g = void 0) } function O(q) { if (g = k(q), !g || g.length === 0) { g = void 0; return } $(g) ? (clearTimeout(v), v = setTimeout(() => { A(), M(g, o, l) }, 80)) : (A(), M(g, o, l)) } function S() { clearTimeout(v), A() } function P() { !b && g && !d ? (clearTimeout(v), M(g, o, l), setTimeout(A, 0)) : A() } function T(q) { const pe = E(q.target); pe && (pe.addClass("active-state"), "which" in q && q.which === 3 && setTimeout(() => { y(".active-state").removeClass("active-state") }, 0)), i && (o = q.pageX, l = q.pageY, O(q.target, q.pageX, q.pageY)) } function I() { r.activeStateOnMouseMove || y(".active-state").removeClass("active-state"), i && S() } function H() { y(".active-state").removeClass("active-state"), i && P() } function D() { c = null, clearTimeout(h), clearTimeout(p), r.activeState && C(), i && P() } let z, B = !1, L = null; const N = ".dialog-button, .actions-button"; let F = !1, V = null; function _(q) { return q.isTrusted ? (d = !1, u = !1, m = !1, z = void 0, q.targetTouches.length > 1 ? (f && C(), !0) : (q.touches.length > 1 && f && C(), r.tapHold && (p && clearTimeout(p), p = setTimeout(() => { q && q.touches && q.touches.length > 1 || (u = !0, q.preventDefault(), m = !0, y(q.target).trigger("taphold", q), n.emit("taphold", q)) }, r.tapHoldDelay)), c = q.target, o = q.targetTouches[0].pageX, l = q.targetTouches[0].pageY, B = q.target.closest(".segmented-strong .button-active, .segmented-strong .tab-link-active"), F = n.theme === "ios" && q.target.closest(N), B && (L = B.closest(".segmented-strong")), r.activeState && (f = E(c), f && !$(f) ? w() : f && (h = setTimeout(w, 80))), i && O(c, o, l), !0)) : !0 } function J(q) { if (!q.isTrusted) return; let pe, be, he = !0; q.type === "touchmove" && (pe = q.targetTouches[0], be = r.touchClicksDistanceThreshold); const se = q.targetTouches[0].pageX, Fe = q.targetTouches[0].pageY; if (typeof z > "u" && (z = !!(z || Math.abs(Fe - l) > Math.abs(se - o))), (F || !z && B && L) && q.cancelable && q.preventDefault(), !z && B && L) { const fe = s.elementFromPoint(q.targetTouches[0].clientX, q.targetTouches[0].clientY).closest(".segmented-strong .button:not(.button-active):not(.tab-link-active)"); fe && L.contains(fe) && (y(fe).trigger("click", "f7Segmented"), c = fe) } if (be && pe) { const ne = pe.pageX, fe = pe.pageY; (Math.abs(ne - o) > be || Math.abs(fe - l) > be) && (d = !0) } else d = !0; d && (m = !0, F && (V = s.elementFromPoint(q.targetTouches[0].clientX, q.targetTouches[0].clientY).closest(N), V && f && f[0] === V ? he = !1 : V && setTimeout(() => { f = E(V), w() })), r.tapHold && clearTimeout(p), r.activeState && he && (clearTimeout(h), C()), i && S()) } function Q(q) { return q.isTrusted ? (z = void 0, B = !1, L = null, F = !1, clearTimeout(h), clearTimeout(p), V && (y(V).trigger("click", "f7TouchMoveActivable"), V = null), s.activeElement === q.target ? (r.activeState && C(), i && P(), !0) : (r.activeState && (w(), setTimeout(C, 0)), i && P(), r.tapHoldPreventClicks && u || m ? (q.cancelable && q.preventDefault(), m = !0, !1) : !0)) : !0 } function j(q) { const pe = q && q.detail && q.detail === "f7Overswipe", be = q && q.detail && q.detail === "f7Segmented", he = q && q.detail && q.detail === "f7TouchMoveActivable"; let se = m; return c && q.target !== c ? pe || be || he ? se = !1 : se = !0 : he && (se = !1), r.tapHold && r.tapHoldPreventClicks && u && (se = !0), se && (q.stopImmediatePropagation(), q.stopPropagation(), q.preventDefault()), r.tapHold && (p = setTimeout(() => { u = !1 }, e.ios || e.androidChrome ? 100 : 400)), m = !1, c = null, !se } function Y(q, pe) { n.emit({ events: q, data: [pe] }) } function X(q) { Y("click", q) } function K(q) { Y("touchstart touchstart:active", q) } function W(q) { Y("touchmove touchmove:active", q) } function G(q) { Y("touchend touchend:active", q) } function Z(q) { Y("touchstart:passive", q) } function ie(q) { Y("touchmove:passive", q) } function ge(q) { Y("touchend:passive", q) } const te = t.passiveListener ? { passive: !0 } : !1, le = t.passiveListener ? { passive: !0, capture: !0 } : !0, ce = t.passiveListener ? { passive: !1 } : !1, de = t.passiveListener ? { passive: !1, capture: !0 } : !0; s.addEventListener("click", X, !0), t.passiveListener ? (s.addEventListener(n.touchEvents.start, K, de), s.addEventListener(n.touchEvents.move, W, ce), s.addEventListener(n.touchEvents.end, G, ce), s.addEventListener(n.touchEvents.start, Z, le), s.addEventListener(n.touchEvents.move, ie, te), s.addEventListener(n.touchEvents.end, ge, te)) : (s.addEventListener(n.touchEvents.start, q => { K(q), Z(q) }, !0), s.addEventListener(n.touchEvents.move, q => { W(q), ie(q) }, !1), s.addEventListener(n.touchEvents.end, q => { G(q), ge(q) }, !1)), t.touch ? (n.on("click", j), n.on("touchstart", _), n.on("touchmove", J), n.on("touchend", Q), s.addEventListener("touchcancel", D, { passive: !0 })) : r.activeState && (n.on("touchstart", T), n.on("touchmove", I), n.on("touchend", H), s.addEventListener("pointercancel", H, { passive: !0 })), s.addEventListener("contextmenu", q => { r.disableContextMenu && (e.ios || e.android || e.cordova || a.Capacitor && a.Capacitor.isNative) && q.preventDefault(), i && (f && C(), P()) }) } const ps = { name: "touch", params: { touch: { touchClicksDistanceThreshold: 5, disableContextMenu: !1, tapHold: !1, tapHoldDelay: 750, tapHoldPreventClicks: !0, activeState: !0, activeStateElements: "a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .link, .item-link, .accordion-item-toggle", activeStateOnMouseMove: !1, mdTouchRipple: !0, iosTouchRipple: !1, touchRippleElements: ".ripple, .link, .item-link, .list label.item-content, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .list.accordion-list .accordion-item-toggle", touchRippleInsetElements: ".ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back" } }, create() { const n = this, e = Ee(); R(n, { touchEvents: { start: e.touch ? "touchstart" : e.pointerEvents ? "pointerdown" : "mousedown", move: e.touch ? "touchmove" : e.pointerEvents ? "pointermove" : "mousemove", end: e.touch ? "touchend" : e.pointerEvents ? "pointerup" : "mouseup" } }) }, on: { init: Ki } }; function Qi(n) { for (var e = [], t = 0; t < n.length;) { var a = n[t]; if (a === "*" || a === "+" || a === "?") { e.push({ type: "MODIFIER", index: t, value: n[t++] }); continue } if (a === "\\") { e.push({ type: "ESCAPED_CHAR", index: t++, value: n[t++] }); continue } if (a === "{") { e.push({ type: "OPEN", index: t, value: n[t++] }); continue } if (a === "}") { e.push({ type: "CLOSE", index: t, value: n[t++] }); continue } if (a === ":") { for (var s = "", r = t + 1; r < n.length;) { var i = n.charCodeAt(r); if (i >= 48 && i <= 57 || i >= 65 && i <= 90 || i >= 97 && i <= 122 || i === 95) { s += n[r++]; continue } break } if (!s) throw new TypeError("Missing parameter name at ".concat(t)); e.push({ type: "NAME", index: t, value: s }), t = r; continue } if (a === "(") { var o = 1, l = "", r = t + 1; if (n[r] === "?") throw new TypeError('Pattern cannot start with "?" at '.concat(r)); for (; r < n.length;) { if (n[r] === "\\") { l += n[r++] + n[r++]; continue } if (n[r] === ")") { if (o--, o === 0) { r++; break } } else if (n[r] === "(" && (o++, n[r + 1] !== "?")) throw new TypeError("Capturing groups are not allowed at ".concat(r)); l += n[r++] } if (o) throw new TypeError("Unbalanced pattern at ".concat(t)); if (!l) throw new TypeError("Missing pattern at ".concat(t)); e.push({ type: "PATTERN", index: t, value: l }), t = r; continue } e.push({ type: "CHAR", index: t, value: n[t++] }) } return e.push({ type: "END", index: t, value: "" }), e } function fs(n, e) { e === void 0 && (e = {}); for (var t = Qi(n), a = e.prefixes, s = a === void 0 ? "./" : a, r = "[^".concat(mt(e.delimiter || "/#?"), "]+?"), i = [], o = 0, l = 0, c = "", d = function (C) { if (l < t.length && t[l].type === C) return t[l++].value }, u = function (C) { var k = d(C); if (k !== void 0) return k; var M = t[l], A = M.type, O = M.index; throw new TypeError("Unexpected ".concat(A, " at ").concat(O, ", expected ").concat(C)) }, p = function () { for (var C = "", k; k = d("CHAR") || d("ESCAPED_CHAR");)C += k; return C }; l < t.length;) { var m = d("CHAR"), f = d("NAME"), h = d("PATTERN"); if (f || h) { var b = m || ""; s.indexOf(b) === -1 && (c += b, b = ""), c && (i.push(c), c = ""), i.push({ name: f || o++, prefix: b, suffix: "", pattern: h || r, modifier: d("MODIFIER") || "" }); continue } var g = m || d("ESCAPED_CHAR"); if (g) { c += g; continue } c && (i.push(c), c = ""); var v = d("OPEN"); if (v) { var b = p(), E = d("NAME") || "", $ = d("PATTERN") || "", w = p(); u("CLOSE"), i.push({ name: E || ($ ? o++ : ""), pattern: E && !$ ? r : $, prefix: b, suffix: w, modifier: d("MODIFIER") || "" }); continue } u("END") } return i } function Zi(n, e) { return Ji(fs(n, e), e) } function Ji(n, e) { e === void 0 && (e = {}); var t = Wa(e), a = e.encode, s = a === void 0 ? function (l) { return l } : a, r = e.validate, i = r === void 0 ? !0 : r, o = n.map(function (l) { if (typeof l == "object") return new RegExp("^(?:".concat(l.pattern, ")$"), t) }); return function (l) { for (var c = "", d = 0; d < n.length; d++) { var u = n[d]; if (typeof u == "string") { c += u; continue } var p = l ? l[u.name] : void 0, m = u.modifier === "?" || u.modifier === "*", f = u.modifier === "*" || u.modifier === "+"; if (Array.isArray(p)) { if (!f) throw new TypeError('Expected "'.concat(u.name, '" to not repeat, but got an array')); if (p.length === 0) { if (m) continue; throw new TypeError('Expected "'.concat(u.name, '" to not be empty')) } for (var h = 0; h < p.length; h++) { var b = s(p[h], u); if (i && !o[d].test(b)) throw new TypeError('Expected all "'.concat(u.name, '" to match "').concat(u.pattern, '", but got "').concat(b, '"')); c += u.prefix + b + u.suffix } continue } if (typeof p == "string" || typeof p == "number") { var b = s(String(p), u); if (i && !o[d].test(b)) throw new TypeError('Expected "'.concat(u.name, '" to match "').concat(u.pattern, '", but got "').concat(b, '"')); c += u.prefix + b + u.suffix; continue } if (!m) { var g = f ? "an array" : "a string"; throw new TypeError('Expected "'.concat(u.name, '" to be ').concat(g)) } } return c } } function mt(n) { return n.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function Wa(n) { return n && n.sensitive ? "" : "i" } function eo(n, e) { if (!e) return n; for (var t = /\((?:\?<(.*?)>)?(?!\?)/g, a = 0, s = t.exec(n.source); s;)e.push({ name: s[1] || a++, prefix: "", suffix: "", modifier: "", pattern: "" }), s = t.exec(n.source); return n } function to(n, e, t) { var a = n.map(function (s) { return hs(s, e, t).source }); return new RegExp("(?:".concat(a.join("|"), ")"), Wa(t)) } function ao(n, e, t) { return no(fs(n, t), e, t) } function no(n, e, t) { t === void 0 && (t = {}); for (var a = t.strict, s = a === void 0 ? !1 : a, r = t.start, i = r === void 0 ? !0 : r, o = t.end, l = o === void 0 ? !0 : o, c = t.encode, d = c === void 0 ? function (O) { return O } : c, u = t.delimiter, p = u === void 0 ? "/#?" : u, m = t.endsWith, f = m === void 0 ? "" : m, h = "[".concat(mt(f), "]|$"), b = "[".concat(mt(p), "]"), g = i ? "^" : "", v = 0, E = n; v < E.length; v++) { var $ = E[v]; if (typeof $ == "string") g += mt(d($)); else { var w = mt(d($.prefix)), C = mt(d($.suffix)); if ($.pattern) if (e && e.push($), w || C) if ($.modifier === "+" || $.modifier === "*") { var k = $.modifier === "*" ? "?" : ""; g += "(?:".concat(w, "((?:").concat($.pattern, ")(?:").concat(C).concat(w, "(?:").concat($.pattern, "))*)").concat(C, ")").concat(k) } else g += "(?:".concat(w, "(").concat($.pattern, ")").concat(C, ")").concat($.modifier); else $.modifier === "+" || $.modifier === "*" ? g += "((?:".concat($.pattern, ")").concat($.modifier, ")") : g += "(".concat($.pattern, ")").concat($.modifier); else g += "(?:".concat(w).concat(C, ")").concat($.modifier) } } if (l) s || (g += "".concat(b, "?")), g += t.endsWith ? "(?=".concat(h, ")") : "$"; else { var M = n[n.length - 1], A = typeof M == "string" ? b.indexOf(M[M.length - 1]) > -1 : M === void 0; s || (g += "(?:".concat(b, "(?=").concat(h, "))?")), A || (g += "(?=".concat(b, "|").concat(h, ")")) } return new RegExp(g, Wa(t)) } function hs(n, e, t) { return n instanceof RegExp ? eo(n, e) : Array.isArray(n) ? to(n, e, t) : ao(n, e, t) } const ae = { queue: [], clearQueue() { if (ae.queue.length === 0) return; ae.queue.shift()() }, routerQueue: [], clearRouterQueue() { if (ae.routerQueue.length === 0) return; const n = ae.routerQueue.pop(), { router: e, stateUrl: t, action: a } = n; let s = e.params.animate; e.params.browserHistoryAnimate === !1 && (s = !1), a === "back" && e.back({ animate: s, browserHistory: !1 }), a === "load" && e.navigate(t, { animate: s, browserHistory: !1 }) }, handle(n) { if (ae.blockPopstate) return; const e = this; let t = n.state; ae.previousState = ae.state, ae.state = t, ae.allowChange = !0, ae.clearQueue(), t = ae.state, t || (t = {}), e.views.forEach(a => { const s = a.router; let r = t[a.id]; if (!r && a.params.browserHistory && (r = { url: a.router.history[0] }), !r) return; const i = r.url || void 0; let o = s.params.animate; s.params.browserHistoryAnimate === !1 && (o = !1), i !== s.url && (s.history.indexOf(i) >= 0 ? s.allowPageChange ? s.back({ animate: o, browserHistory: !1 }) : ae.routerQueue.push({ action: "back", router: s }) : s.allowPageChange ? s.navigate(i, { animate: o, browserHistory: !1 }) : ae.routerQueue.unshift({ action: "load", stateUrl: i, router: s })) }) }, initViewState(n, e) { const t = U(), a = R({}, ae.state || {}, { [n]: e }); ae.state = a, t.history.replaceState(a, "") }, push(n, e, t) { const a = U(), s = ee(); if (t.substr(-3) === "#!/" && (t = t.replace("#!/", ""), t === "" && (t = s.location.href, t.includes("#!/") && (t = s.location.href.split("#!/")[0]))), !ae.allowChange) { ae.queue.push(() => { ae.push(n, e, t) }); return } ae.previousState = ae.state; const r = R({}, ae.previousState || {}, { [n]: e }); ae.state = r, a.history.pushState(r, "", t) }, replace(n, e, t) { const a = U(); if (t.substr(-3) === "#!/" && (t = t.replace("#!/", "")), !ae.allowChange) { ae.queue.push(() => { ae.replace(n, e, t) }); return } ae.previousState = ae.state; const s = R({}, ae.previousState || {}, { [n]: e }); ae.state = s, a.history.replaceState(s, "", t) }, go(n) { const e = U(); ae.allowChange = !1, e.history.go(n) }, back() { const n = U(); ae.allowChange = !1, n.history.back() }, allowChange: !0, previousState: {}, state: {}, blockPopstate: !0, init(n) { const e = U(), t = ee(); ae.state = e.history.state, y(e).on("load", () => { setTimeout(() => { ae.blockPopstate = !1 }, 0) }), t.readyState && t.readyState === "complete" && (ae.blockPopstate = !1), y(e).on("popstate", ae.handle.bind(n)) } }; function so(n) { const e = n, { $el: t, $navbarsEl: a, app: s, params: r } = e, i = Ee(), o = ue(); let l = !1, c = !1; const d = {}; let u, p = [], m = [], f, h, b = !0, g, v = [], E = [], $, w, C, k; const M = r[`${s.theme}SwipeBackAnimateShadow`], A = r[`${s.theme}SwipeBackAnimateOpacity`], O = r[`${s.theme}SwipeBackActiveArea`], S = r[`${s.theme}SwipeBackThreshold`], P = s.rtl ? "right center" : "left center", T = s.rtl ? "calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center" : "calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center"; function I() { const F = [], V = s.rtl ? -1 : 1, _ = v.hasClass("navbar-transparent") && !v.hasClass("navbar-large") && !v.hasClass("navbar-transparent-visible"), J = v.hasClass("navbar-large"), Q = v.hasClass("navbar-large-collapsed"), j = v.hasClass("navbar-large-transparent") || v.hasClass("navbar-large") && v.hasClass("navbar-transparent"), Y = E.hasClass("navbar-transparent") && !E.hasClass("navbar-large") && !E.hasClass("navbar-transparent-visible"), X = E.hasClass("navbar-large"), K = E.hasClass("navbar-large-collapsed"), W = E.hasClass("navbar-large-transparent") || E.hasClass("navbar-large") && E.hasClass("navbar-transparent"), G = J && !Q, Z = X && !K, ie = v.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg"), ge = E.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg"); let te, le; return r.iosAnimateNavbarBackIcon && (v.hasClass("sliding") || v.find(".navbar-inner.sliding").length ? te = v.find(".left").find(".back .icon + span").eq(0) : te = v.find(".left.sliding").find(".back .icon + span").eq(0), E.hasClass("sliding") || E.find(".navbar-inner.sliding").length ? le = E.find(".left").find(".back .icon + span").eq(0) : le = E.find(".left.sliding").find(".back .icon + span").eq(0), te.length && ge.each(ce => { y(ce).hasClass("title") && (ce.f7NavbarLeftOffset += te.prev(".icon")[0].offsetWidth) })), ie.each(ce => { const de = y(ce), q = de.hasClass("subnavbar"), pe = de.hasClass("left"), be = de.hasClass("title"), he = de.hasClass("navbar-bg"); if ((be || he) && _ || !G && de.hasClass(".title-large")) return; const se = { el: ce }; if (G) { if (be) return; if (de.hasClass("title-large")) { F.indexOf(se) < 0 && F.push(se), se.overflow = "visible", de.find(".title-large-text").each(ne => { F.push({ el: ne, transform: fe => `translateX(${fe * 100 * V}%)` }) }); return } } if (Z && (G || de.hasClass("title-large") && (F.indexOf(se) < 0 && F.push(se), se.opacity = 0), pe)) { F.indexOf(se) < 0 && F.push(se), se.opacity = ne => 1 - ne ** .33, de.find(".back span").each(ne => { F.push({ el: ne, "transform-origin": P, transform: fe => `translateX(calc(${fe} * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(${fe} * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(${1 + 1 * fe})` }) }); return } if (he) { F.indexOf(se) < 0 && F.push(se), !G && !Z && (Q ? (j && (se.className = "ios-swipeback-navbar-bg-large"), se.transform = ne => `translateX(${100 * ne * V}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`) : se.transform = ne => `translateX(${100 * ne * V}%)`), !G && Z && (se.className = "ios-swipeback-navbar-bg-large", se.transform = ne => `translateX(${100 * ne * V}%) translateY(calc(-1 * ${1 - ne} * var(--f7-navbar-large-title-height)))`), G && Z && (se.transform = ne => `translateX(${100 * ne * V}%)`), G && !Z && (se.transform = ne => `translateX(${100 * ne * V}%) translateY(calc(-${ne} * var(--f7-navbar-large-title-height)))`); return } if (de.hasClass("title-large")) return; const Fe = de.hasClass("sliding") || de.parents(".navbar-inner.sliding").length; if (F.indexOf(se) < 0 && F.push(se), (!q || q && !Fe) && (se.opacity = ne => 1 - ne ** .33), Fe) { let ne = se; if (pe && te.length && r.iosAnimateNavbarBackIcon) { const fe = { el: te[0] }; ne = fe, F.push(fe) } ne.transform = fe => { let qe = fe * ne.el.f7NavbarRightOffset; return o.pixelRatio === 1 && (qe = Math.round(qe)), q && J ? `translate3d(${qe}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)` : `translate3d(${qe}px,0,0)` } } }), ge.each(ce => { const de = y(ce), q = de.hasClass("subnavbar"), pe = de.hasClass("left"), be = de.hasClass("title"), he = de.hasClass("navbar-bg"); if ((be || he) && Y) return; const se = { el: ce }; if (Z) { if (be) return; if (F.indexOf(se) < 0 && F.push(se), de.hasClass("title-large")) { se.opacity = 1, se.overflow = "visible", de.find(".title-large-text").each(ne => { F.push({ el: ne, "transform-origin": T, opacity: fe => fe ** 3, transform: fe => `translateX(calc(${1 - fe} * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(${fe - 1} * var(--f7-navbar-large-title-height) + ${1 - fe} * var(--f7-navbar-large-title-padding-vertical))) scale(${.5 + fe * .5})` }) }); return } } if (he) { F.indexOf(se) < 0 && F.push(se), !G && !Z && (K ? (W && (se.className = "ios-swipeback-navbar-bg-large"), se.transform = ne => `translateX(${(-100 + 100 * ne) * V}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`) : se.transform = ne => `translateX(${(-100 + 100 * ne) * V}%)`), !G && Z && (se.transform = ne => `translateX(${(-100 + 100 * ne) * V}%) translateY(calc(-1 * ${1 - ne} * var(--f7-navbar-large-title-height)))`), G && !Z && (se.className = "ios-swipeback-navbar-bg-large", se.transform = ne => `translateX(${(-100 + 100 * ne) * V}%) translateY(calc(-${ne} * var(--f7-navbar-large-title-height)))`), G && Z && (se.transform = ne => `translateX(${(-100 + 100 * ne) * V}%)`); return } if (de.hasClass("title-large")) return; const Fe = de.hasClass("sliding") || E.children(".navbar-inner.sliding").length; if (F.indexOf(se) < 0 && F.push(se), (!q || q && !Fe) && (se.opacity = ne => ne ** 3), Fe) { let ne = se; if (pe && le.length && r.iosAnimateNavbarBackIcon) { const fe = { el: le[0] }; ne = fe, F.push(fe) } ne.transform = fe => { let qe = ne.el.f7NavbarLeftOffset * (1 - fe); return o.pixelRatio === 1 && (qe = Math.round(qe)), q && X ? `translate3d(${qe}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)` : `translate3d(${qe}px,0,0)` } } }), F } function H(F) { let { progress: V, reset: _, transition: J, reflow: Q } = F === void 0 ? {} : F; const j = ["overflow", "transform", "transform-origin", "opacity"]; if (J === !0 || J === !1) for (let Y = 0; Y < k.length; Y += 1) { const X = k[Y]; X && X.el && (J === !0 && X.el.classList.add("navbar-page-transitioning"), J === !1 && X.el.classList.remove("navbar-page-transitioning")) } Q && k.length && k[0] && k[0].el && (k[0].el._clientLeft = k[0].el.clientLeft); for (let Y = 0; Y < k.length; Y += 1) { const X = k[Y]; if (X && X.el) { X.className && !X.classNameSet && !_ && (X.el.classList.add(X.className), X.classNameSet = !0), X.className && _ && X.el.classList.remove(X.className); for (let K = 0; K < j.length; K += 1) { const W = j[K]; X[W] && (_ ? X.el.style[W] = "" : typeof X[W] == "function" ? X.el.style[W] = X[W](V) : X.el.style[W] = X[W]) } } } } function D(F) { if (!F.isTrusted) return; const V = r[`${s.theme}SwipeBack`]; !b || !V || l || s.swipeout && s.swipeout.el || !e.allowPageChange || y(F.target).closest(".range-slider, .calendar-months").length > 0 || y(F.target).closest(".page-master, .page-master-detail").length > 0 && r.masterDetailBreakpoint > 0 && s.width >= r.masterDetailBreakpoint || (c = !1, l = !0, u = void 0, d.x = F.type === "touchstart" ? F.targetTouches[0].pageX : F.pageX, d.y = F.type === "touchstart" ? F.targetTouches[0].pageY : F.pageY, g = Ie(), $ = e.dynamicNavbar) } function z(F) { if (!F.isTrusted || !l) return; const V = F.type === "touchmove" ? F.targetTouches[0].pageX : F.pageX, _ = F.type === "touchmove" ? F.targetTouches[0].pageY : F.pageY; if (typeof u > "u" && (u = !!(u || Math.abs(_ - d.y) > Math.abs(V - d.x)) || V < d.x && !s.rtl || V > d.x && s.rtl), u || F.f7PreventSwipeBack || s.preventSwipeBack) { l = !1; return } if (!c) { let K = !1; const W = y(F.target), G = W.closest(".swipeout"); G.length > 0 && (!s.rtl && G.find(".swipeout-actions-left").length > 0 && (K = !0), s.rtl && G.find(".swipeout-actions-right").length > 0 && (K = !0)), p = W.closest(".page"), (p.hasClass("no-swipeback") || W.closest(".no-swipeback, .card-opened").length > 0) && (K = !0), m = t.find(".page-previous"), m.length > 1 && (m = m.eq(m.length - 1)); let Z = d.x - t.offset().left > O; if (f = t.width(), s.rtl ? Z = d.x < t.offset().left - t[0].scrollLeft + (f - O) : Z = d.x - t.offset().left > O, Z && (K = !0), (m.length === 0 || p.length === 0) && (K = !0), K) { l = !1; return } M && (w = p.find(".page-shadow-effect"), w.length === 0 && (w = y('<div class="page-shadow-effect"></div>'), p.append(w))), A && (C = m.find(".page-opacity-effect"), C.length === 0 && (C = y('<div class="page-opacity-effect"></div>'), m.append(C))), $ && (v = a.find(".navbar-current"), E = a.find(".navbar-previous"), E.length > 1 && (E = E.eq(E.length - 1)), k = I(E, v)), y(".sheet.modal-in").length > 0 && s.sheet && s.sheet.close(y(".sheet.modal-in")) } F.f7PreventSwipePanel = !0, c = !0, s.preventSwipePanelBySwipeBack = !0, F.preventDefault(); const J = s.rtl ? -1 : 1; h = (V - d.x - S) * J, h < 0 && (h = 0); const Q = Math.min(Math.max(h / f, 0), 1), j = { percentage: Q, progress: Q, currentPageEl: p[0], previousPageEl: m[0], currentNavbarEl: v[0], previousNavbarEl: E[0] }; t.trigger("swipeback:move", j), e.emit("swipebackMove", j); let Y = h * J, X = (h / 5 - f / 5) * J; s.rtl ? (Y = Math.max(Y, -f), X = Math.max(X, 0)) : (Y = Math.min(Y, f), X = Math.min(X, 0)), o.pixelRatio === 1 && (Y = Math.round(Y), X = Math.round(X)), e.swipeBackActive = !0, y([p[0], m[0]]).addClass("page-swipeback-active"), p.transform(`translate3d(${Y}px,0,0)`), M && (w[0].style.opacity = 1 - 1 * Q), s.theme === "ios" && m.transform(`translate3d(${X}px,0,0)`), A && (C[0].style.opacity = 1 - 1 * Q), $ && H({ progress: Q }) } function B(F) { if (!F.isTrusted) return; if (s.preventSwipePanelBySwipeBack = !1, !l || !c) { l = !1, c = !1; return } l = !1, c = !1, e.swipeBackActive = !1; const V = y([p[0], m[0]]); if (V.removeClass("page-swipeback-active"), h === 0) { V.transform(""), w && w.length > 0 && w.remove(), C && C.length > 0 && C.remove(), $ && H({ reset: !0 }); return } const _ = Ie() - g; let J = !1; (_ < 300 && h > 10 || _ >= 300 && h > f / 2) && (p.removeClass("page-current").addClass(`page-next${s.theme !== "ios" ? " page-next-on-right" : ""}`), m.removeClass("page-previous").addClass("page-current").removeAttr("aria-hidden"), w && (w[0].style.opacity = ""), C && (C[0].style.opacity = ""), $ && (e.setNavbarPosition(v, "next"), e.setNavbarPosition(E, "current", !1)), J = !0), V.addClass("page-transitioning page-transitioning-swipeback"), o.ios && (p[0]._clientLeft = p[0].clientLeft), V.transform(""), $ && H({ progress: J ? 1 : 0, transition: !0, reflow: !!o.ios }), b = !1, e.allowPageChange = !1; const Q = { currentPageEl: p[0], previousPageEl: m[0], currentNavbarEl: v[0], previousNavbarEl: E[0] }; J ? (e.currentRoute = m[0].f7Page.route, e.currentPage = m[0], e.pageCallback("beforeOut", p, v, "current", "next", { route: p[0].f7Page.route, swipeBack: !0 }), e.pageCallback("beforeIn", m, E, "previous", "current", { route: m[0].f7Page.route, swipeBack: !0 }, p[0]), t.trigger("swipeback:beforechange", Q), e.emit("swipebackBeforeChange", Q)) : (t.trigger("swipeback:beforereset", Q), e.emit("swipebackBeforeReset", Q)), p.transitionEnd(() => { V.removeClass("page-transitioning page-transitioning-swipeback"), $ && H({ reset: !0, transition: !1 }), b = !0, e.allowPageChange = !0, J ? (e.history.length === 1 && e.history.unshift(e.url), e.history.pop(), e.saveHistory(), r.browserHistory && ae.back(), e.pageCallback("afterOut", p, v, "current", "next", { route: p[0].f7Page.route, swipeBack: !0 }), e.pageCallback("afterIn", m, E, "previous", "current", { route: m[0].f7Page.route, swipeBack: !0 }), e.pageCallback("beforeRemove", p, v, "next", { swipeBack: !0 }), e.removePage(p), $ && e.removeNavbar(v), t.trigger("swipeback:afterchange", Q), e.emit("swipebackAfterChange", Q), e.emit("routeChanged", e.currentRoute, e.previousRoute, e), r.preloadPreviousPage && e.back(e.history[e.history.length - 2], { preload: !0 })) : (t.trigger("swipeback:afterreset", Q), e.emit("swipebackAfterReset", Q)), w && w.length > 0 && w.remove(), C && C.length > 0 && C.remove() }) } function L() { const F = s.touchEvents.start === "touchstart" && i.passiveListener ? { passive: !0, capture: !1 } : !1; t.on(s.touchEvents.start, D, F), s.on("touchmove:active", z), s.on("touchend:passive", B) } function N() { const F = s.touchEvents.start === "touchstart" && i.passiveListener ? { passive: !0, capture: !1 } : !1; t.off(s.touchEvents.start, D, F), s.off("touchmove:active", z), s.off("touchend:passive", B) } L(), e.on("routerDestroy", N) } function ms(n, e, t) { const a = this, s = e.route.redirect, r = n === "forward" ? "navigate" : "back"; t.initial && a.params.browserHistory && (t.replaceState = !0, t.history = !0); function i(l, c) { c === void 0 && (c = {}), a.allowPageChange = !0, a[r](l, R({}, t, c)) } function o() { a.allowPageChange = !0 } if (typeof s == "function") { a.allowPageChange = !1; const l = s.call(a, { router: a, to: e, resolve: i, reject: o, direction: n, app: a.app }); return l && typeof l == "string" ? (a.allowPageChange = !0, a[r](l, t)) : a } return a[r](s, t) } function ln(n, e, t, a, s, r, i, o) { const l = []; Array.isArray(t) ? l.push(...t) : t && typeof t == "function" && l.push(t), e && (Array.isArray(e) ? l.push(...e) : l.push(e)); function c() { if (l.length === 0) { r(); return } l.shift().call(n, { router: n, to: a, from: s, resolve() { c() }, reject() { i() }, direction: o, app: n.app }) } c() } function Oa(n, e, t, a, s) { const r = this; function i() { n && n.route && (r.params.routesBeforeEnter || n.route.beforeEnter) ? (r.allowPageChange = !1, ln(r, r.params.routesBeforeEnter, n.route.beforeEnter, n, e, () => { r.allowPageChange = !0, t() }, () => { a() }, s)) : t() } function o() { e && e.route && (r.params.routesBeforeLeave || e.route.beforeLeave) ? (r.allowPageChange = !1, ln(r, r.params.routesBeforeLeave, e.route.beforeLeave, n, e, () => { r.allowPageChange = !0, i() }, () => { a() }, s)) : i() } o() } function Ct(n, e) { if (!n.view) throw new Error(`Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router.${e}(...)`) } function sa(n, e, t, a) { function s(i) { i.then(o => { t({ component: o.default || o._default || o }) }).catch(o => { throw a(), new Error(o) }) } if (e instanceof Promise) { s(e); return } const r = e.call(n); r instanceof Promise ? s(r) : t({ component: r }) } function ro(n) { n === void 0 && (n = {}); const e = this; return Ct(e, "refreshPage"), e.navigate(e.currentRoute.url, { ignoreCache: !0, reloadCurrent: !0, props: n }) } function xt(n, e, t) { t === void 0 && (t = {}); const a = ee(), s = y(e), r = n.app, i = n.view, o = R(!1, { animate: n.params.animate, browserHistory: !0, replaceState: !1, history: !0, reloadCurrent: n.params.reloadPages, reloadPrevious: !1, reloadAll: !1, clearPreviousHistory: !1, reloadDetail: n.params.reloadDetail, on: {} }, t), l = n.params.masterDetailBreakpoint > 0, c = l && o.route && o.route.route && (o.route.route.master === !0 || typeof o.route.route.master == "function" && o.route.route.master(r, n)); let d, u, p = 0, m = n.currentRoute.modal, f; if (m || "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(B => { n.currentRoute && n.currentRoute.route && n.currentRoute.route[B] && (m = !0, f = B) }), m) { const B = n.currentRoute.modal || n.currentRoute.route.modalInstance || r[f].get(), L = n.history[n.history.length - 2]; let N = n.findMatchingRoute(L); !N && L && (N = { url: L, path: L.split("?")[0], query: Bt(L), route: { path: L.split("?")[0], url: L } }), n.modalRemove(B) } const h = n.dynamicNavbar, b = n.$el, g = s, v = o.reloadPrevious || o.reloadCurrent || o.reloadAll; let E, $, w, C; if (n.allowPageChange = !1, g.length === 0) return n.allowPageChange = !0, n; g.length && n.removeThemeElements(g), h && (w = g.children(".navbar"), $ = n.$navbarsEl, w.length === 0 && g[0] && g[0].f7Page && (w = g[0].f7Page.$navbarEl)), o.route && o.route.route && o.route.route.keepAlive && !o.route.route.keepAliveData && (o.route.route.keepAliveData = { pageEl: s[0] }); const k = b.children(".page").filter(B => B !== g[0]); let M; if (h && (M = $.children(".navbar").filter(B => B !== w[0])), o.reloadPrevious && k.length < 2) return n.allowPageChange = !0, n; let A, O, S; if (l && !o.reloadAll) { for (let B = 0; B < k.length; B += 1)if (!d && k[B].classList.contains("page-master")) { d = k[B]; continue } if (A = !c && d, A && d) { for (let B = 0; B < k.length; B += 1)if (k[B].classList.contains("page-master-detail")) { u = k[B]; continue } } O = A && o.reloadDetail && r.width >= n.params.masterDetailBreakpoint && d } A && (S = !u || O || o.reloadAll || o.reloadCurrent); let P = "next"; if (o.reloadCurrent || o.reloadAll || O ? P = "current" : o.reloadPrevious && (P = "previous"), g.removeClass("page-previous page-current page-next").addClass(`page-${P}${c ? " page-master" : ""}${A ? " page-master-detail" : ""}${S ? " page-master-detail-root" : ""}`).trigger("page:unstack").trigger("page:position", { position: P }), n.emit("pageUnstack", g[0]), n.emit("pagePosition", g[0], P), (c || A) && (g.trigger("page:role", { role: c ? "master" : "detail", root: !!S }), n.emit("pageRole", g[0], { role: c ? "master" : "detail", detailRoot: !!S })), h && w.length && (w.removeClass("navbar-previous navbar-current navbar-next").addClass(`navbar-${P}${c ? " navbar-master" : ""}${A ? " navbar-master-detail" : ""}${S ? " navbar-master-detail-root" : ""}`), w.trigger("navbar:position", { position: P }), n.emit("navbarPosition", w[0], P), (c || A) && n.emit("navbarRole", w[0], { role: c ? "master" : "detail", detailRoot: !!S })), o.reloadCurrent || O) O ? (E = k.filter(B => !B.classList.contains("page-master")), h && (C = y(E.map(B => r.navbar.getElByPage(B)))), E.length > 1 && d && (p = E.length - 1, y(d).removeClass("page-master-stacked").trigger("page:masterunstack"), n.emit("pageMasterUnstack", d), h && (y(r.navbar.getElByPage(d)).removeClass("navbar-master-stacked"), n.emit("navbarMasterUnstack", r.navbar.getElByPage(d))))) : (E = k.eq(k.length - 1), h && (C = y(r.navbar.getElByPage(E)))); else if (o.reloadPrevious) E = k.eq(k.length - 2), h && (C = y(r.navbar.getElByPage(E))); else if (o.reloadAll) E = k.filter(B => B !== g[0]), h && (C = M.filter(B => B !== w[0])); else { let B = [], L = []; if (k.length > 1) { let N = 0; for (N = 0; N < k.length - 1; N += 1) { if (d && k[N] === d) { k.eq(N).addClass("page-master-stacked"), k.eq(N).trigger("page:masterstack"), n.emit("pageMasterStack", k[N]), h && (y(r.navbar.getElByPage(d)).addClass("navbar-master-stacked"), n.emit("navbarMasterStack", r.navbar.getElByPage(d))); continue } const F = r.navbar.getElByPage(k.eq(N)); B.push(k[N]), n.pageCallback("beforeRemove", k[N], M && M[N], "previous", void 0, o), n.removePage(k[N]), h && F && (L.push(F), n.removeNavbar(F)) } } E = b.children(".page").filter(N => N !== g[0] && B.indexOf(N) < 0), h && (C = $.children(".navbar").filter(N => N !== w[0] && L.indexOf(L) < 0)), B = [], L = [] } if (A && !o.reloadAll && ((E.length > 1 || O) && (E = E.filter(B => !B.classList.contains("page-master"))), C && (C.length > 1 || O) && (C = C.filter(B => !B.classList.contains("navbar-master")))), n.params.browserHistory && (o.browserHistory || o.replaceState) && !o.reloadPrevious) { const B = n.params.browserHistoryRoot || ""; ae[o.reloadCurrent || O && u || o.reloadAll || o.replaceState ? "replace" : "push"](i.id, { url: o.route.url }, B + n.params.browserHistorySeparator + o.route.url) } o.reloadPrevious || (n.currentPageEl = g[0], h && w.length ? n.currentNavbarEl = w[0] : delete n.currentNavbarEl, n.currentRoute = o.route); const T = o.route.url; o.history && (((o.reloadCurrent || O && u) && n.history.length) > 0 || o.replaceState ? (O && p > 0 && (n.history = n.history.slice(0, n.history.length - p), n.propsHistory = n.propsHistory.slice(0, n.propsHistory.length - p)), n.history[n.history.length - (o.reloadPrevious ? 2 : 1)] = T, n.propsHistory[n.propsHistory.length - (o.reloadPrevious ? 2 : 1)] = o.props || {}) : o.reloadPrevious ? (n.history[n.history.length - 2] = T, n.propsHistory[n.propsHistory.length - 2] = o.props || {}) : o.reloadAll ? (n.history = [T], n.propsHistory = [o.props || {}]) : (n.history.push(T), n.propsHistory.push(o.props || {}))), n.saveHistory(); const I = g.parents(a).length > 0, H = g[0].f7Component; if (o.reloadPrevious ? (H && !I ? H.mount(B => { y(B).insertBefore(E) }) : g.insertBefore(E), h && w.length && (w.find(".title-large").length && w.addClass("navbar-large"), C.length ? w.insertBefore(C) : (n.$navbarsEl.parents(a).length || n.$el.prepend(n.$navbarsEl), $.append(w)))) : (E.next(".page")[0] !== g[0] && (H && !I ? H.mount(B => { b.append(B) }) : b.append(g[0])), h && w.length && (w.find(".title-large").length && w.addClass("navbar-large"), n.$navbarsEl.parents(a).length || n.$el.prepend(n.$navbarsEl), $.append(w[0]))), I ? o.route && o.route.route && o.route.route.keepAlive && !g[0].f7PageMounted && (g[0].f7PageMounted = !0, n.pageCallback("mounted", g, w, P, v ? P : "current", o, E)) : n.pageCallback("mounted", g, w, P, v ? P : "current", o, E), (o.reloadCurrent || O) && E.length > 0 ? (n.pageCallback("beforeOut", E, C, "current", void 0, o), n.pageCallback("afterOut", E, C, "current", void 0, o), n.pageCallback("beforeRemove", E, C, "current", void 0, o), n.removePage(E), h && C && C.length && n.removeNavbar(C)) : o.reloadAll ? E.each((B, L) => { const N = y(B), F = y(r.navbar.getElByPage(N)); N.hasClass("page-current") && (n.pageCallback("beforeOut", E, C, "current", void 0, o), n.pageCallback("afterOut", E, C, "current", void 0, o)), n.pageCallback("beforeRemove", N, C && C.eq(L), "previous", void 0, o), n.removePage(N), h && F.length && n.removeNavbar(F) }) : o.reloadPrevious && (n.pageCallback("beforeRemove", E, C, "previous", void 0, o), n.removePage(E), h && C && C.length && n.removeNavbar(C)), o.route.route.tab && n.tabLoad(o.route.route.tab, R({}, o, { history: !1, browserHistory: !1 })), l && i.checkMasterDetailBreakpoint(), n.pageCallback("init", g, w, P, v ? P : "current", o, E), o.reloadCurrent || o.reloadAll || O) return n.allowPageChange = !0, n.pageCallback("beforeIn", g, w, P, "current", o), g.removeAttr("aria-hidden"), h && w && w.removeAttr("aria-hidden"), n.pageCallback("afterIn", g, w, P, "current", o), o.reloadCurrent && o.clearPreviousHistory && n.clearPreviousHistory(), O && (n.setPagePosition(y(d), "previous"), d.f7Page && d.f7Page.navbarEl && n.setNavbarPosition(y(d.f7Page.navbarEl), "previous")), n; if (o.reloadPrevious) return n.allowPageChange = !0, n; n.pageCallback("beforeOut", E, C, "current", "previous", o), n.pageCallback("beforeIn", g, w, "next", "current", o); function D() { n.setPagePosition(g, "current", !1), n.setPagePosition(E, "previous", !E.hasClass("page-master")), h && (n.setNavbarPosition(w, "current", !1), n.setNavbarPosition(C, "previous", !C.hasClass("navbar-master"))), n.allowPageChange = !0, n.pageCallback("afterOut", E, C, "current", "previous", o), n.pageCallback("afterIn", g, w, "next", "current", o); let B = (n.params.preloadPreviousPage || n.params[`${r.theme}SwipeBack`]) && !c; B || (g.hasClass("smart-select-page") || g.hasClass("photo-browser-page") || g.hasClass("autocomplete-page") || g.hasClass("color-picker-page")) && (B = !0), B || g.attr("data-name") && g.attr("data-name") === "smart-select-page" || (n.pageCallback("beforeRemove", E, C, "previous", void 0, o), n.removePage(E), h && C.length && n.removeNavbar(C)), o.clearPreviousHistory && n.clearPreviousHistory(), n.emit("routeChanged", n.currentRoute, n.previousRoute, n), n.params.browserHistory && ae.clearRouterQueue() } function z() { n.setPagePosition(E, "current", !1), n.setPagePosition(g, "next", !1), h && (n.setNavbarPosition(C, "current", !1), n.setNavbarPosition(w, "next", !1)) } if (o.animate && !(c && r.width >= n.params.masterDetailBreakpoint)) { const B = n.params[`${n.app.theme}PageLoadDelay`]; let L = n.params.transition; o.transition && (L = o.transition), !L && n.currentRoute && n.currentRoute.route && (L = n.currentRoute.route.transition), !L && n.currentRoute && n.currentRoute.route.options && (L = n.currentRoute.route.options.transition), L && (g[0].f7PageTransition = L), B ? setTimeout(() => { z(), n.animate(E, g, C, w, "forward", L, () => { D() }) }, B) : (z(), n.animate(E, g, C, w, "forward", L, () => { D() })) } else D(); return n } function pa(n, e, t, a) { if (e === void 0 && (e = {}), t === void 0 && (t = {}), !n.allowPageChange && !a) return n; const s = e, r = t, { url: i, content: o, el: l, pageName: c, component: d, componentUrl: u } = s; if (!r.reloadCurrent && r.route && r.route.route && r.route.route.parentPath && n.currentRoute.route && n.currentRoute.route.parentPath === r.route.route.parentPath) { if (r.route.url === n.url) return n.allowPageChange = !0, !1; let f = Object.keys(r.route.params).length === Object.keys(n.currentRoute.params).length; if (f && Object.keys(r.route.params).forEach(h => { (!(h in n.currentRoute.params) || n.currentRoute.params[h] !== r.route.params[h]) && (f = !1) }), f) return r.route.route.tab ? n.tabLoad(r.route.route.tab, r) : !1; if (!f && r.route.route.tab && n.currentRoute.route.tab && n.currentRoute.parentPath === r.route.parentPath) return n.tabLoad(r.route.route.tab, r) } if (r.route && r.route.url && n.url === r.route.url && !(r.reloadCurrent || r.reloadPrevious) && !n.params.allowDuplicateUrls) return n.allowPageChange = !0, !1; !r.route && i && (r.route = n.parseRouteUrl(i), R(r.route, { route: { url: i, path: i } })); function p(f, h) { return xt(n, f, R(r, h)) } function m() { return n.allowPageChange = !0, n } if ((i || u || d) && (n.allowPageChange = !1), o) xt(n, n.getPageEl(o), r); else if (l) xt(n, n.getPageEl(l), r); else if (c) xt(n, n.$el.children(`.page[data-name="${c}"]`).eq(0), r); else if (d || u) try { n.pageComponentLoader({ routerEl: n.el, component: d, componentUrl: u, options: r, resolve: p, reject: m }) } catch (f) { throw n.allowPageChange = !0, f } else i && (n.xhrAbortController && (n.xhrAbortController.abort(), n.xhrAbortController = !1), n.xhrRequest(i, r).then(f => { xt(n, n.getPageEl(f), r) }).catch(() => { n.allowPageChange = !0 })); return n } function io(n, e) { e === void 0 && (e = {}); const t = this; if (t.swipeBackActive) return t; let a, s, r, i, o, l, c; if (typeof n == "string" ? a = n : (a = n.url, s = n.route, r = n.name, i = n.path, o = n.query, l = n.params), r || i) return a = t.generateUrl({ path: i, name: r, params: l, query: o }), a ? t.navigate(a, e) : t; const d = t.app; if (Ct(t, "navigate"), a === "#" || a === "") return t; let u = a.replace("./", ""); if (u[0] !== "/" && u.indexOf("#") !== 0) { const h = t.currentRoute.parentPath || t.currentRoute.path; u = ((h ? `${h}/` : "/") + u).replace("///", "/").replace("//", "/") } if (s ? c = R(t.parseRouteUrl(u), { route: R({}, s) }) : c = t.findMatchingRoute(u), !c) return t; if (c.route && c.route.viewName) { const h = c.route.viewName, b = d.views[h]; if (!b) throw new Error(`Framework7: There is no View with "${h}" name that was specified in this route`); if (b !== t.view) return b.router.navigate(n, e) } if (c.route.redirect) return ms.call(t, "forward", c, e); const p = {}; if (c.route.options ? R(p, c.route.options, e) : R(p, e), p.openIn && (!t.params.ignoreOpenIn || t.params.ignoreOpenIn && t.history.length > 0)) return t.openIn(t, u, p); p.route = c; function m() { let h = !1; if ("popup popover sheet loginScreen actions customModal panel".split(" ").forEach(v => { c.route[v] && !h && (h = !0, t.modalLoad(v, c, p, "forward")) }), c.route.keepAlive && c.route.keepAliveData && (pa(t, { el: c.route.keepAliveData.pageEl }, p, !1), h = !0), "url content component pageName el componentUrl".split(" ").forEach(v => { c.route[v] && !h && (h = !0, pa(t, { [v]: c.route[v] }, p, !1)) }), h) return; function b(v, E) { t.allowPageChange = !1; let $ = !1; "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(w => { if (v[w]) { $ = !0; const C = R({}, c, { route: v }); t.allowPageChange = !0, t.modalLoad(w, C, R(p, E), "forward") } }), !$ && pa(t, v, R(p, E), !0) } function g() { t.allowPageChange = !0 } c.route.async && (t.allowPageChange = !1, c.route.async.call(t, { router: t, to: p.route, from: t.currentRoute, resolve: b, reject: g, direction: "forward", app: d })), c.route.asyncComponent && sa(t, c.route.asyncComponent, b, g) } function f() { t.allowPageChange = !0 } if (t.params.masterDetailBreakpoint > 0 && c.route.masterRoute) { let h = !0, b = !1; if (t.currentRoute && t.currentRoute.route && ((t.currentRoute.route.master === !0 || typeof t.currentRoute.route.master == "function" && t.currentRoute.route.master(d, t)) && (t.currentRoute.route === c.route.masterRoute || t.currentRoute.route.path === c.route.masterRoute.path) && (h = !1), t.currentRoute.route.masterRoute && (t.currentRoute.route.masterRoute === c.route.masterRoute || t.currentRoute.route.masterRoute.path === c.route.masterRoute.path) && (h = !1, b = !0)), h || b && e.reloadAll) return t.navigate({ path: c.route.masterRoute.path, params: c.params || {} }, { animate: !1, reloadAll: e.reloadAll, reloadCurrent: e.reloadCurrent, reloadPrevious: e.reloadPrevious, browserHistory: !e.initial, history: !e.initial, once: { pageAfterIn() { t.navigate(n, R({}, e, { animate: !1, reloadAll: !1, reloadCurrent: !1, reloadPrevious: !1, history: !e.initial, browserHistory: !e.initial })) } } }), t } return Oa.call(t, c, t.currentRoute, () => { c.route.modules ? d.loadModules(Array.isArray(c.route.modules) ? c.route.modules : [c.route.modules]).then(() => { m() }).catch(() => { f() }) : m() }, () => { f() }, "forward"), t } function oo(n, e) { e === void 0 && (e = {}); const t = this, a = R({ animate: t.params.animate, browserHistory: !0, history: !0, parentPageEl: null, preload: !1, on: {} }, e); let s, r; a.route && (!a.preload && a.route !== t.currentRoute && (r = t.previousRoute, t.currentRoute = a.route), a.preload ? (s = a.route, r = t.currentRoute) : (s = t.currentRoute, r || (r = t.previousRoute)), t.params.browserHistory && a.browserHistory && !a.reloadPrevious && ae[t.params.browserHistoryTabs](t.view.id, { url: a.route.url }, (t.params.browserHistoryRoot || "") + t.params.browserHistorySeparator + a.route.url), a.history && (t.history[Math.max(t.history.length - 1, 0)] = a.route.url, t.saveHistory())); const i = y(a.parentPageEl || t.currentPageEl); let o; i.length && i.find(`#${n.id}`).length ? o = i.find(`#${n.id}`).eq(0) : t.view.selector ? o = `${t.view.selector} #${n.id}` : o = `#${n.id}`; const l = t.app.tab.show({ tabEl: o, animate: a.animate, tabRoute: a.route }), { $newTabEl: c, $oldTabEl: d, animated: u, onTabsChanged: p } = l; if (c && c.parents(".page").length > 0 && a.route) { const v = c.parents(".page")[0].f7Page; v && a.route && (v.route = a.route) } function m(v) { t.removeThemeElements(c); let E = c; typeof v != "string" && (E = y(v)), E.trigger("tab:init tab:mounted", n), t.emit("tabInit tabMounted", c[0], n), d && d.length && (u ? p(() => { t.emit("routeChanged", t.currentRoute, t.previousRoute, t), t.params.unloadTabContent && t.tabRemove(d, c, n) }) : (t.emit("routeChanged", t.currentRoute, t.previousRoute, t), t.params.unloadTabContent && t.tabRemove(d, c, n))) } if (c[0].f7RouterTabLoaded) return !d || !d.length || (u ? p(() => { t.emit("routeChanged", t.currentRoute, t.previousRoute, t) }) : t.emit("routeChanged", t.currentRoute, t.previousRoute, t)), t; function f(v, E) { const { url: $, content: w, el: C, component: k, componentUrl: M } = v; function A(S) { t.allowPageChange = !0, S && (typeof S == "string" ? c.html(S) : (c.html(""), S.f7Component ? S.f7Component.mount(P => { c.append(P) }) : c.append(S)), c[0].f7RouterTabLoaded = !0, m(S)) } function O() { return t.allowPageChange = !0, t } if (w) A(w); else if (C) A(C); else if (k || M) try { t.tabComponentLoader({ tabEl: c[0], component: k, componentUrl: M, options: E, resolve: A, reject: O }) } catch (S) { throw t.allowPageChange = !0, S } else $ && (t.xhrAbortController && (t.xhrAbortController.abort(), t.xhrAbortController = !1), t.xhrRequest($, E).then(S => { A(S) }).catch(() => { t.allowPageChange = !0 })) } let h; "url content component el componentUrl".split(" ").forEach(v => { n[v] && (h = !0, f({ [v]: n[v] }, a)) }); function b(v, E) { f(v, R(a, E)) } function g() { t.allowPageChange = !0 } return n.async ? n.async.call(t, { router: t, to: s, from: r, resolve: b, reject: g, app: t.app }) : n.asyncComponent ? sa(t, n.asyncComponent, b, g) : h || (t.allowPageChange = !0), t } function lo(n, e, t) { const a = this; let s; n[0] && (n[0].f7RouterTabLoaded = !1, delete n[0].f7RouterTabLoaded), n.children().each(r => { r.f7Component && (s = !0, y(r).trigger("tab:beforeremove", t), r.f7Component.destroy()) }), s || n.trigger("tab:beforeremove", t), a.emit("tabBeforeRemove", n[0], e[0], t), a.removeTabContent(n[0], t) } function co(n, e, t, a) { t === void 0 && (t = {}); const s = this, r = s.app, i = n === "panel", o = i ? "panel" : "modal", l = R({ animate: s.params.animate, browserHistory: !0, history: !0, on: {}, once: {} }, t), c = R({}, e.route[n]), d = e.route, u = (g, v) => { const { on: E, once: $ } = l; let w; v === "open" && (w = E.modalOpen || $.modalOpen || E.panelOpen || $.panelOpen), v === "close" && (w = E.modalClose || $.modalClose || E.panelClose || $.panelClose), v === "closed" && (w = E.modalClosed || $.modalClosed || E.panelClosed || $.panelClosed), w && w(g) }; function p() { const g = r[n].create(c); d.modalInstance = g; const v = g.el; function E() { g.close() } g.on(`${o}Open`, () => { v || (s.removeThemeElements(g.el), g.$el.trigger(`${n.toLowerCase()}:init ${n.toLowerCase()}:mounted`, e, g), s.emit(`${i ? "" : "modalInit"} ${n}Init ${n}Mounted`, g.el, e, g)), s.once("swipeBackMove", E), u(g, "open") }), g.on(`${o}Close`, () => { s.off("swipeBackMove", E), g.closeByRouter || s.back(), u(g, "close") }), g.on(`${o}Closed`, () => { g.$el.trigger(`${n.toLowerCase()}:beforeremove`, e, g), g.emit(`${i ? "" : "modalBeforeRemove "}${n}BeforeRemove`, g.el, e, g); const $ = g.el.f7Component; u(g, "closed"), $ && $.destroy(), $e(() => { ($ || c.component || c.asyncComponent) && s.removeModal(g.el), g.destroy(), delete g.route, delete d.modalInstance }) }), l.route && (s.params.browserHistory && l.browserHistory && ae.push(s.view.id, { url: l.route.url, modal: n }, (s.params.browserHistoryRoot || "") + s.params.browserHistorySeparator + l.route.url), l.route !== s.currentRoute && (g.route = R(l.route, { modal: g }), s.currentRoute = g.route), l.history && !l.reloadCurrent && (s.history.push(l.route.url), s.saveHistory())), v && (s.removeThemeElements(g.el), g.$el.trigger(`${n.toLowerCase()}:init ${n.toLowerCase()}:mounted`, e, g), s.emit(`${o}Init ${n}Init ${n}Mounted`, g.el, e, g)), g.open(l.animate === !1 || l.animate === !0 ? l.animate : void 0) } function m(g, v) { const { url: E, content: $, component: w, componentUrl: C } = g; function k(A) { A && (typeof A == "string" ? c.content = A : A.f7Component ? A.f7Component.mount(O => { c.el = O, r.$el.append(O) }) : c.el = A, p()) } function M() { return s.allowPageChange = !0, s } if ($) k($); else if (w || C) try { s.modalComponentLoader({ rootEl: r.el, component: w, componentUrl: C, options: v, resolve: k, reject: M }) } catch (A) { throw s.allowPageChange = !0, A } else E ? (s.xhrAbortController && (s.xhrAbortController.abort(), s.xhrAbortController = !1), s.xhrRequest(E, v).then(A => { c.content = A, p() }).catch(() => { s.allowPageChange = !0 })) : p() } let f; "url content component el componentUrl template".split(" ").forEach(g => { c[g] && !f && (f = !0, m({ [g]: c[g] }, l)) }), !f && n === "actions" && p(); function h(g, v) { m(g, R(l, v)) } function b() { s.allowPageChange = !0 } return c.async && c.async.call(s, { router: s, to: l.route, from: s.currentRoute, resolve: h, reject: b, direction: a, app: r }), c.asyncComponent && sa(s, c.asyncComponent, h, b), s } function uo(n) { R(n, { closeByRouter: !0 }), n.close() } function kt(n, e, t) { const a = ue(), s = ee(), r = y(e), i = n.app, o = n.view, l = R(!1, { animate: n.params.animate, browserHistory: !0, replaceState: !1 }, t), c = n.params.masterDetailBreakpoint > 0, d = c && l.route && l.route.route && (l.route.route.master === !0 || typeof l.route.route.master == "function" && l.route.route.master(i, n)); let u, p; const m = n.dynamicNavbar, f = r, h = n.$el.children(".page-current"), b = h.length === 0 && l.preload, g = c && h.hasClass("page-master"); f.length && n.removeThemeElements(f); let v, E, $; if (m && (E = f.children(".navbar"), v = n.$navbarsEl, E.length === 0 && f[0] && f[0].f7Page && (E = f[0].f7Page.$navbarEl), $ = v.find(".navbar-current")), n.allowPageChange = !1, f.length === 0 || h.length === 0 && !l.preload) return n.allowPageChange = !0, n; n.removeThemeElements(f), l.route && l.route.route && l.route.route.keepAlive && !l.route.route.keepAliveData && (l.route.route.keepAliveData = { pageEl: r[0] }); let w, C; if (c) { const T = n.$el.children(".page").filter(I => I !== f[0]); for (let I = 0; I < T.length; I += 1)if (!u && T[I].classList.contains("page-master")) { u = T[I]; continue } w = !d && u && n.history.indexOf(l.route.url) > n.history.indexOf(u.f7Page.route.url), !w && !d && u && u.f7Page && l.route.route.masterRoute && (w = l.route.route.masterRoute.path === u.f7Page.route.route.path) } w && u && u.f7Page && (C = n.history.indexOf(l.route.url) - n.history.indexOf(u.f7Page.route.url) === 1), f.addClass(`page-${b ? "current" : "previous"}${d ? " page-master" : ""}${w ? " page-master-detail" : ""}${C ? " page-master-detail-root" : ""}`).removeAttr("aria-hidden").trigger("page:unstack").trigger("page:position", { position: b ? "current" : "previous" }), n.emit("pageUnstack", f[0]), n.emit("pagePosition", f[0], b ? "current" : "previous"), (d || w) && (f.trigger("page:role", { role: d ? "master" : "detail", root: !!C }), n.emit("pageRole", f[0], { role: d ? "master" : "detail", detailRoot: !!C })), m && E.length > 0 && (E.addClass(`navbar-${b ? "current" : "previous"}${d ? " navbar-master" : ""}${w ? " navbar-master-detail" : ""}${C ? " navbar-master-detail-root" : ""}`).removeAttr("aria-hidden"), E.trigger("navbar:position", { position: b ? "current" : "previous" }), n.emit("navbarPosition", E[0], b ? "current" : "previous"), (d || C) && n.emit("navbarRole", E[0], { role: d ? "master" : "detail", detailRoot: !!C })); let k; if (l.force && h.prev(".page-previous").length >= 0) { n.history.indexOf(l.route.url) >= 0 ? (k = n.history.length - n.history.indexOf(l.route.url) - 1, n.history = n.history.slice(0, n.history.indexOf(l.route.url) + 2), n.propsHistory = n.propsHistory.slice(0, n.history.indexOf(l.route.url) + 2), o.history = n.history) : n.history[[n.history.length - 2]] ? n.propsHistory[n.propsHistory.length - 2] = l.props || {} : (n.history.unshift(n.url), n.propsHistory.unshift(l.props || {})); const T = h.prev(".page-previous"); let I; m && (I = y(i.navbar.getElByPage(T))), T.length > 0 && (n.pageCallback("beforeRemove", T, I, "previous", void 0, l), T[0] === u && (p = !0), n.removePage(T), m && I.length && n.removeNavbar(I)) } const M = f.parents(s).length > 0, A = f[0].f7Component; function O() { b && (!M && A ? A.mount(T => { n.$el.append(T) }) : n.$el.append(f)), f.next(h).length === 0 && (!M && A ? A.mount(T => { y(T).insertBefore(h) }) : f.insertBefore(h)), m && E.length && (E.find(".title-large").length && E.addClass("navbar-large"), E.insertBefore($), $.length > 0 ? E.insertBefore($) : (n.$navbarsEl.parents(s).length || n.$el.prepend(n.$navbarsEl), v.append(E))), M ? l.route && l.route.route && l.route.route.keepAlive && !f[0].f7PageMounted && (f[0].f7PageMounted = !0, n.pageCallback("mounted", f, E, "previous", "current", l, h)) : n.pageCallback("mounted", f, E, "previous", "current", l, h) } if (l.preload) { O(), l.route.route.tab && n.tabLoad(l.route.route.tab, R({}, l, { history: !1, browserHistory: !1, preload: !0 })), d && (f.removeClass("page-master-stacked").trigger("page:masterunstack"), n.emit("pageMasterUnstack", f[0]), m && (y(i.navbar.getElByPage(f)).removeClass("navbar-master-stacked"), n.emit("navbarMasterUnstack", i.navbar.getElByPage(f)))), n.pageCallback("init", f, E, "previous", "current", l, h), b && (n.pageCallback("beforeIn", f, E, "current", void 0, l), n.pageCallback("afterIn", f, E, "current", void 0, l)); const T = f.prevAll(".page-previous:not(.page-master)"); return T.length > 0 && T.each(I => { const H = y(I); let D; m && (D = y(i.navbar.getElByPage(H))), n.pageCallback("beforeRemove", H, D, "previous", void 0), n.removePage(H), m && D.length && n.removeNavbar(D) }), n.allowPageChange = !0, n } if (!(a.ie || a.edge || a.firefox && !a.ios) && n.params.browserHistory && l.browserHistory) if (l.replaceState) { const T = n.params.browserHistoryRoot || ""; ae.replace(o.id, { url: l.route.url }, T + n.params.browserHistorySeparator + l.route.url) } else k ? ae.go(-k) : ae.back(); if (l.replaceState ? (n.history[n.history.length - 1] = l.route.url, n.propsHistory[n.propsHistory.length - 1] = l.props || {}) : (n.history.length === 1 && (n.history.unshift(n.url), n.propsHistory.unshift(l.props || {})), n.history.pop(), n.propsHistory.pop()), n.saveHistory(), n.currentPageEl = f[0], m && E.length ? n.currentNavbarEl = E[0] : delete n.currentNavbarEl, n.currentRoute = l.route, (a.ie || a.edge || a.firefox && !a.ios) && n.params.browserHistory && l.browserHistory) if (l.replaceState) { const T = n.params.browserHistoryRoot || ""; ae.replace(o.id, { url: l.route.url }, T + n.params.browserHistorySeparator + l.route.url) } else k ? ae.go(-k) : ae.back(); O(), l.route.route.tab && n.tabLoad(l.route.route.tab, R({}, l, { history: !1, browserHistory: !1 })), c && (g || p) && o.checkMasterDetailBreakpoint(!1), n.pageCallback("init", f, E, "previous", "current", l, h), n.pageCallback("beforeOut", h, $, "current", "next", l), n.pageCallback("beforeIn", f, E, "previous", "current", l); function S() { n.setPagePosition(f, "current", !1), n.setPagePosition(h, "next", !0), m && (n.setNavbarPosition(E, "current", !1), n.setNavbarPosition($, "next", !0)), n.pageCallback("afterOut", h, $, "current", "next", l), n.pageCallback("afterIn", f, E, "previous", "current", l), n.pageCallback("beforeRemove", h, $, "next", void 0, l), n.removePage(h), m && $.length && n.removeNavbar($), n.allowPageChange = !0, n.emit("routeChanged", n.currentRoute, n.previousRoute, n), (n.params.preloadPreviousPage || n.params[`${i.theme}SwipeBack`]) && n.history[n.history.length - 2] && !d && n.back(n.history[n.history.length - 2], { preload: !0, props: n.propsHistory[n.propsHistory.length - 2] || {} }), n.params.browserHistory && ae.clearRouterQueue() } function P() { n.setPagePosition(h, "current"), n.setPagePosition(f, "previous", !1), m && (n.setNavbarPosition($, "current"), n.setNavbarPosition(E, "previous", !1)) } if (l.animate && !(g && i.width >= n.params.masterDetailBreakpoint)) { let T = n.params.transition; h[0] && h[0].f7PageTransition && (T = h[0].f7PageTransition, delete h[0].f7PageTransition), l.transition && (T = l.transition), !T && n.previousRoute && n.previousRoute.route && (T = n.previousRoute.route.transition), !T && n.previousRoute && n.previousRoute.route && n.previousRoute.route.options && (T = n.previousRoute.route.options.transition), P(), n.animate(h, f, $, E, "backward", T, () => { S() }) } else S(); return n } function Ht(n, e, t, a) { if (!n.allowPageChange && !a) return n; const s = e, r = t, { url: i, content: o, el: l, pageName: c, component: d, componentUrl: u } = s; if (r.route.url && n.url === r.route.url && !(r.reloadCurrent || r.reloadPrevious) && !n.params.allowDuplicateUrls) return n.allowPageChange = !0, !1; !r.route && i && (r.route = n.parseRouteUrl(i)); function p(f, h) { return kt(n, f, R(r, h)) } function m() { return n.allowPageChange = !0, n } if ((i || u || d) && (n.allowPageChange = !1), o) kt(n, n.getPageEl(o), r); else if (l) kt(n, n.getPageEl(l), r); else if (c) kt(n, n.$el.children(`.page[data-name="${c}"]`).eq(0), r); else if (d || u) try { n.pageComponentLoader({ routerEl: n.el, component: d, componentUrl: u, options: r, resolve: p, reject: m }) } catch (f) { throw n.allowPageChange = !0, f } else i && (n.xhrAbortController && (n.xhrAbortController.abort(), n.xhrAbortController = !1), n.xhrRequest(i, r).then(f => { kt(n, n.getPageEl(f), r) }).catch(() => { n.allowPageChange = !0 })); return n } function po() { const n = this, e = ue(); if (n.swipeBackActive) return n; let t, a, s, r; typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "object" ? a = (arguments.length <= 0 ? void 0 : arguments[0]) || {} : (t = arguments.length <= 0 ? void 0 : arguments[0], a = (arguments.length <= 1 ? void 0 : arguments[1]) || {}); const { name: i, params: o, query: l } = a; if (i) return t = n.generateUrl({ name: i, params: o, query: l }), t ? n.back(t, R({}, a, { name: null, params: null, query: null })) : n; const c = n.app; Ct(n, "back"); let d = n.currentRoute.modal, u; if (d || "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(g => { n.currentRoute.route[g] && (d = !0, u = g) }), d && !a.preload) { const g = n.currentRoute.modal || n.currentRoute.route.modalInstance || c[u].get(), v = n.history[n.history.length - 2]; let E; if (g && g.$el) { const w = g.$el.prevAll(".modal-in"); if (w.length && w[0].f7Modal) { const C = w[0]; n.$el.parents(C).length || (E = C.f7Modal.route) } } if (E || (E = n.findMatchingRoute(v)), !E && v && (E = { url: v, path: v.split("?")[0], query: Bt(v), route: { path: v.split("?")[0], url: v } }), (!t || t.replace(/[# ]/g, "").trim().length === 0) && (!E || !g)) return n; const $ = a.force && E && t; if (E && g) { const w = e.ie || e.edge || e.firefox && !e.ios, C = n.params.browserHistory && a.browserHistory !== !1, k = n.currentRoute && n.currentRoute.route && n.currentRoute.route.options && n.currentRoute.route.options.browserHistory === !1; C && !w && !k && ae.back(), n.currentRoute = E, n.history.pop(), n.propsHistory.pop(), n.saveHistory(), C && w && !k && ae.back(), n.modalRemove(g), $ && n.navigate(t, { reloadCurrent: !0 }) } else g && (n.modalRemove(g), t && n.navigate(t, { reloadCurrent: !0 })); return n } let p = n.$el.children(".page-current").prevAll(".page-previous:not(.page-master)").eq(0), m; if (n.params.masterDetailBreakpoint > 0) { const g = []; n.$el.children(".page").each(E => { g.push(E.className) }); const v = n.$el.children(".page-current").prevAll(".page-master").eq(0); if (v.length) { const E = n.history[n.history.length - 2], $ = n.findMatchingRoute(E); $ && v[0].f7Page && $.route === v[0].f7Page.route.route && (p = v, a.preload || (m = c.width >= n.params.masterDetailBreakpoint)) } } if (!a.force && p.length && !m) { if (n.params.browserHistory && p[0].f7Page && n.history[n.history.length - 2] !== p[0].f7Page.route.url) return n.back(n.history[n.history.length - 2], R(a, { force: !0, props: n.propsHistory[n.propsHistory.length - 2] || {} })), n; const g = p[0].f7Page.route; return Oa.call(n, g, n.currentRoute, () => { Ht(n, { el: p }, R(a, { route: g })) }, () => { }, "backward"), n } if (t === "#" && (t = void 0), t && t[0] !== "/" && t.indexOf("#") !== 0 && (t = ((n.path || "/") + t).replace("//", "/")), !t && n.history.length > 1 && (t = n.history[n.history.length - 2], s = n.propsHistory[n.propsHistory.length - 2] || {}), m && !a.force && n.history[n.history.length - 3]) return n.back(n.history[n.history.length - 3], R({}, a || {}, { force: !0, animate: !1, props: n.propsHistory[n.propsHistory.length - 3] || {} })); if (m && !a.force || (r = n.findMatchingRoute(t), r || t && (r = { url: t, path: t.split("?")[0], query: Bt(t), route: { path: t.split("?")[0], url: t } }), !r)) return n; if (r.route.redirect) return ms.call(n, "backward", r, a); const f = {}; r.route.options ? R(f, r.route.options, a, { props: s || {} }) : R(f, a, { props: s || {} }), f.route = r; function h() { let g = !1; if (r.route.keepAlive && r.route.keepAliveData && (Ht(n, { el: r.route.keepAliveData.pageEl }, f), g = !0), "url content component pageName el componentUrl".split(" ").forEach($ => { r.route[$] && !g && (g = !0, Ht(n, { [$]: r.route[$] }, f)) }), g) return; function v($, w) { n.allowPageChange = !1, Ht(n, $, R(f, w), !0) } function E() { n.allowPageChange = !0 } r.route.async && (n.allowPageChange = !1, r.route.async.call(n, { router: n, to: r, from: n.currentRoute, resolve: v, reject: E, direction: "backward", app: c })), r.route.asyncComponent && sa(n, r.route.asyncComponent, v, E) } function b() { n.allowPageChange = !0 } return f.preload ? h() : Oa.call(n, r, n.currentRoute, () => { r.route.modules ? c.loadModules(Array.isArray(r.route.modules) ? r.route.modules : [r.route.modules]).then(() => { h() }).catch(() => { b() }) : h() }, () => { b() }, "backward"), n } function fo(n) { Ct(n, "clearPreviousPages"); const e = n.app, t = n.dynamicNavbar; n.$el.children(".page").filter(s => n.currentRoute && (n.currentRoute.modal || n.currentRoute.panel) ? !0 : s !== n.currentPageEl).each(s => { const r = y(s), i = y(e.navbar.getElByPage(r)); n.pageCallback("beforeRemove", r, i, "previous", void 0, {}), n.removePage(r), t && i.length && n.removeNavbar(i) }) } function ho() { const n = this; Ct(n, "clearPreviousHistory"); const e = n.history[n.history.length - 1]; fo(n), n.history = [e], n.view.history = [e], n.saveHistory() } class Le extends me {
  constructor(e, t) { super({}, [typeof t > "u" ? e : t]); const a = this; a.isAppRouter = typeof t > "u", a.isAppRouter ? R(!1, a, { app: e, params: e.params.view, routes: e.routes || [], cache: e.cache }) : R(!1, a, { app: e, view: t, viewId: t.id, id: t.params.routerId, params: t.params, routes: t.routes, history: t.history, propsHistory: [], scrollHistory: t.scrollHistory, cache: e.cache, dynamicNavbar: e.theme === "ios" && t.params.iosDynamicNavbar, initialPages: [], initialNavbars: [] }), a.useModules(), a.allowPageChange = !0; let s = {}, r = {}; return Object.defineProperty(a, "currentRoute", { enumerable: !0, configurable: !0, set(i) { i === void 0 && (i = {}), r = R({}, s), s = i, s && (a.url = s.url, a.emit("routeChange", i, r, a)) }, get() { return s } }), Object.defineProperty(a, "previousRoute", { enumerable: !0, configurable: !0, get() { return r }, set(i) { r = i } }), a } mount() { const e = this, t = e.view, a = ee(); R(!1, e, { tempDom: a.createElement("div"), $el: t.$el, el: t.el, $navbarsEl: t.$navbarsEl, navbarsEl: t.navbarsEl }), e.emit("local::mount routerMount", e) } animatableNavElements(e, t, a, s, r) { const i = this, o = i.dynamicNavbar, l = i.params.iosAnimateNavbarBackIcon; let c, d; function u(p, m) { const f = p.hasClass("sliding") || m.hasClass("sliding"), h = p.hasClass("subnavbar"), b = f ? !h : !0, g = p.find(".back .icon"); let v; return f && l && p.hasClass("left") && g.length > 0 && g.next("span").length && (p = g.next("span"), v = !0), { $el: p, isIconLabel: v, leftOffset: p[0].f7NavbarLeftOffset, rightOffset: p[0].f7NavbarRightOffset, isSliding: f, isSubnavbar: h, needsOpacityTransition: b } } return o && (c = [], d = [], e.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each(p => { const m = y(p); m.hasClass("left") && s && r === "forward" || m.hasClass("title") && a || c.push(u(m, e.children(".navbar-inner"))) }), t.hasClass("navbar-master") && i.params.masterDetailBreakpoint > 0 && i.app.width >= i.params.masterDetailBreakpoint || t.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each(p => { const m = y(p); m.hasClass("left") && a && !s && r === "forward" || m.hasClass("left") && a && r === "backward" || m.hasClass("title") && s || d.push(u(m, t.children(".navbar-inner"))) }), [d, c].forEach(p => { p.forEach(m => { const f = m, { isSliding: h, $el: b } = m, g = p === d ? c : d; h && b.hasClass("title") && g && g.forEach(v => { if (v.isIconLabel) { const E = v.$el[0]; f.leftOffset += E && E.offsetLeft || 0 } }) }) })), { newNavEls: c, oldNavEls: d } } animate(e, t, a, s, r, i, o) { const l = this; if (l.params.animateCustom) { l.params.animateCustom.apply(l, [e, t, a, s, r, o]); return } const c = l.dynamicNavbar, d = l.app.theme === "ios"; if (i) { const w = `router-transition-custom router-transition-${i}-${r}`, C = () => { l.$el.removeClass(w), c && l.$navbarsEl.length && (s && l.$navbarsEl.prepend(s), a && l.$navbarsEl.prepend(a)), o && o() }; (r === "forward" ? t : e).animationEnd(C), c && (s && t && (l.setNavbarPosition(s, ""), s.removeClass("navbar-next navbar-previous navbar-current"), t.prepend(s)), a && e && (l.setNavbarPosition(a, ""), a.removeClass("navbar-next navbar-previous navbar-current"), e.prepend(a))), l.$el.addClass(w); return } const u = `router-transition-${r} router-transition`; let p, m, f, h, b, g, v; if (d && c) { l.params.masterDetailBreakpoint > 0 && l.app.width >= l.params.masterDetailBreakpoint && (a.hasClass("navbar-master") && s.hasClass("navbar-master-detail") || a.hasClass("navbar-master-detail") && s.hasClass("navbar-master")) || (g = a && a.hasClass("navbar-large"), v = s && s.hasClass("navbar-large"), f = g && !a.hasClass("navbar-large-collapsed"), h = v && !s.hasClass("navbar-large-collapsed"), b = f && !h || h && !f); const C = l.animatableNavElements(s, a, h, f, r); p = C.newNavEls, m = C.oldNavEls } function E(w) { d && c && (w === 1 && (h && (s.addClass("router-navbar-transition-to-large"), a.addClass("router-navbar-transition-to-large")), f && (s.addClass("router-navbar-transition-from-large"), a.addClass("router-navbar-transition-from-large"))), p.forEach(C => { const k = C.$el, M = r === "forward" ? C.rightOffset : C.leftOffset; C.isSliding && (C.isSubnavbar && v ? k[0].style.setProperty("transform", `translate3d(${M * (1 - w)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`, "important") : k.transform(`translate3d(${M * (1 - w)}px,0,0)`)) }), m.forEach(C => { const k = C.$el, M = r === "forward" ? C.leftOffset : C.rightOffset; C.isSliding && (C.isSubnavbar && g ? k.transform(`translate3d(${M * w}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`) : k.transform(`translate3d(${M * w}px,0,0)`)) })) } function $() { l.dynamicNavbar && (s && (s.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large"), s.addClass("navbar-no-title-large-transition"), Ae(() => { s.removeClass("navbar-no-title-large-transition") })), a && a.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large"), s.hasClass("sliding") || s.children(".navbar-inner.sliding").length ? s.find(".title, .left, .right, .left .icon, .subnavbar").transform("") : s.find(".sliding").transform(""), a.hasClass("sliding") || a.children(".navbar-inner.sliding").length ? a.find(".title, .left, .right, .left .icon, .subnavbar").transform("") : a.find(".sliding").transform("")), l.$el.removeClass(u), o && o() } (r === "forward" ? t : d ? e : t).animationEnd(() => { $() }), c ? (E(0), Ae(() => { l.$el.addClass(u), b && (l.el._clientLeft = l.el.clientLeft), E(1) })) : l.$el.addClass(u) } removeModal(e) { this.removeEl(e) } removeTabContent(e) { y(e).html("") } removeNavbar(e) { this.removeEl(e) } removePage(e) { const t = y(e), a = t && t[0] && t[0].f7Page, s = this; if (a && a.route && a.route.route && a.route.route.keepAlive) { t.remove(); return } s.removeEl(e) } removeEl(e) { if (!e) return; const t = this, a = y(e); a.length !== 0 && (a.find(".tab").each(s => { y(s).children().each(r => { r.f7Component && (y(r).trigger("tab:beforeremove"), r.f7Component.destroy()) }) }), a[0].f7Component && a[0].f7Component.destroy && a[0].f7Component.destroy(), t.params.removeElements && (t.params.removeElementsWithTimeout ? setTimeout(() => { a.remove() }, t.params.removeElementsTimeout) : a.remove())) } getPageEl(e) { const t = this; if (typeof e == "string") t.tempDom.innerHTML = e; else { if (y(e).hasClass("page")) return e; t.tempDom.innerHTML = "", y(t.tempDom).append(e) } return t.findElement(".page", t.tempDom) } findElement(e, t) { const a = this, s = a.view, r = a.app, i = ".popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page", o = y(t), l = e; let c = o.find(l).filter(d => y(d).parents(i).length === 0); if (c.length > 1 && (typeof s.selector == "string" && (c = o.find(`${s.selector} ${l}`)), c.length > 1 && (c = o.find(`.${r.params.viewMainClass} ${l}`))), c.length === 1 || (c = a.findElement(l, o), c && c.length === 1)) return c; if (c && c.length > 1) return y(c[0]) } flattenRoutes(e) { e === void 0 && (e = this.routes); const t = this; let a = []; return e.forEach(s => { let r = !1; if ("tabs" in s && s.tabs) { const i = s.tabs.map(o => { const l = R({}, s, { path: `${s.path}/${o.path}`.replace("///", "/").replace("//", "/"), parentPath: s.path, tab: o }); return delete l.tabs, delete l.routes, l }); r = !0, a = a.concat(t.flattenRoutes(i)) } if ("detailRoutes" in s) { const i = s.detailRoutes.map(o => { const l = R({}, o); return l.masterRoute = s, l.masterRoutePath = s.path, l }); a = a.concat(s, t.flattenRoutes(i)) } if ("routes" in s) { const i = s.routes.map(o => { const l = R({}, o); return l.path = `${s.path}/${l.path}`.replace("///", "/").replace("//", "/"), l }); r ? a = a.concat(t.flattenRoutes(i)) : a = a.concat(s, t.flattenRoutes(i)) } !("routes" in s) && !("tabs" in s && s.tabs) && !("detailRoutes" in s) && a.push(s) }), a } parseRouteUrl(e) { if (!e) return {}; const t = Bt(e), a = e.split("#")[1], s = {}, r = e.split("#")[0].split("?")[0]; return { query: t, hash: a, params: s, url: e, path: r } } generateUrl(e) { if (e === void 0 && (e = {}), typeof e == "string") return e; const { name: t, path: a, params: s, query: r } = e; if (!t && !a) throw new Error('Framework7: "name" or "path" parameter is required'); const i = this, o = t ? i.findRouteByKey("name", t) : i.findRouteByKey("path", a); if (!o) throw t ? new Error(`Framework7: route with name "${t}" not found`) : new Error(`Framework7: route with path "${a}" not found`); const l = i.constructRouteUrl(o, { params: s, query: r }); if (!l) throw new Error(`Framework7: can't construct URL for route with name "${t}"`); return l } constructRouteUrl(e, t) {
    let { params: a, query: s } = t === void 0 ? {} : t; const { path: r } = e, i = Zi(r); let o; try { o = i(a || {}) } catch (l) {
      throw new Error(`Framework7: error constructing route URL from passed params:
Route: ${r}
${l.toString()}`)
    } return s && (typeof s == "string" ? o += `?${s}` : Object.keys(s).length && (o += `?${dt(s)}`)), o
  } findTabRouteUrl(e) { const t = this, a = y(e), s = t.currentRoute.route.parentPath, r = a.attr("id"), i = t.flattenRoutes(t.routes); let o; return i.forEach(l => { l.parentPath === s && l.tab && l.tab.id === r && (t.currentRoute.params && Object.keys(t.currentRoute.params).length > 0 ? o = t.constructRouteUrl(l, { params: t.currentRoute.params, query: t.currentRoute.query }) : o = l.path) }), o } findRouteByKey(e, t) { const a = this, s = a.routes, r = a.flattenRoutes(s); let i; return r.forEach(o => { i || o[e] === t && (i = o) }), i } findMatchingRoute(e) { if (!e) return; const t = this, a = t.routes, s = t.flattenRoutes(a), { path: r, query: i, hash: o, params: l } = t.parseRouteUrl(e); let c; return s.forEach(d => { if (c) return; const u = [], p = [d.path || "/"]; d.alias && (typeof d.alias == "string" ? p.push(d.alias) : Array.isArray(d.alias) && d.alias.forEach(f => { p.push(f) })); let m; if (p.forEach(f => { m || (m = hs(f, u).exec(r || "/")) }), m) { u.forEach((h, b) => { if (typeof h.name == "number") return; const g = m[b + 1]; typeof g > "u" || g === null ? l[h.name] = g : l[h.name] = decodeURIComponent(g) }); let f; d.parentPath && (f = (r || "/").split("/").slice(0, d.parentPath.split("/").length - 1).join("/")), c = { query: i, hash: o, params: l, url: e, path: r || "/", parentPath: f, route: d, name: d.name } } }), c } replaceRequestUrlParams(e, t) { e === void 0 && (e = ""), t === void 0 && (t = {}); let a = e; return typeof a == "string" && a.indexOf("{{") >= 0 && t && t.route && t.route.params && Object.keys(t.route.params).length && Object.keys(t.route.params).forEach(s => { const r = new RegExp(`{{${s}}}`, "g"); a = a.replace(r, t.route.params[s] || "") }), a } removeFromXhrCache(e) { const a = this.cache.xhr; let s = !1; for (let r = 0; r < a.length; r += 1)a[r].url === e && (s = r); s !== !1 && a.splice(s, 1) } xhrRequest(e, t) { const a = this, s = a.params, { ignoreCache: r } = t; let i = e, o = i.indexOf("?") >= 0; return s.passRouteQueryToRequest && t && t.route && t.route.query && Object.keys(t.route.query).length && (i += `${o ? "&" : "?"}${dt(t.route.query)}`, o = !0), s.passRouteParamsToRequest && t && t.route && t.route.params && Object.keys(t.route.params).length && (i += `${o ? "&" : "?"}${dt(t.route.params)}`, o = !0), i.indexOf("{{") >= 0 && (i = a.replaceRequestUrlParams(i, t)), s.xhrCacheIgnoreGetParameters && i.indexOf("?") >= 0 && (i = i.split("?")[0]), new Promise((l, c) => { if (s.xhrCache && !r && i.indexOf("nocache") < 0 && s.xhrCacheIgnore.indexOf(i) < 0) for (let u = 0; u < a.cache.xhr.length; u += 1) { const p = a.cache.xhr[u]; if (p.url === i && Ie() - p.time < s.xhrCacheDuration) { l(p.content); return } } a.xhrAbortController = new AbortController; let d; fetch(i, { signal: a.xhrAbortController.signal, method: "GET" }).then(u => (d = u, u.text())).then(u => { const { status: p } = d; a.emit("routerAjaxComplete", d), p !== "error" && p !== "timeout" && p >= 200 && p < 300 || p === 0 ? (s.xhrCache && u !== "" && (a.removeFromXhrCache(i), a.cache.xhr.push({ url: i, time: Ie(), content: u })), a.emit("routerAjaxSuccess", d, t), l(u)) : (a.emit("routerAjaxError", d, t), c(d)) }).catch(u => { c(u) }) }) } setNavbarPosition(e, t, a) { const s = this; e.removeClass("navbar-previous navbar-current navbar-next"), t && e.addClass(`navbar-${t}`), a === !1 ? e.removeAttr("aria-hidden") : a === !0 && e.attr("aria-hidden", "true"), e.trigger("navbar:position", { position: t }), s.emit("navbarPosition", e[0], t) } setPagePosition(e, t, a) { const s = this; e.removeClass("page-previous page-current page-next"), e.addClass(`page-${t}`), a === !1 ? e.removeAttr("aria-hidden") : a === !0 && e.attr("aria-hidden", "true"), e.trigger("page:position", { position: t }), s.emit("pagePosition", e[0], t) } removeThemeElements(e) { const a = this.app.theme; let s; a === "ios" ? s = ".md-only, .if-md, .if-not-ios, .not-ios" : a === "md" && (s = ".ios-only, .if-ios, .if-not-md, .not-md"), y(e).find(s).remove() } getPageData(e, t, a, s, r, i) { r === void 0 && (r = {}); const o = this, l = y(e).eq(0), c = y(t).eq(0), d = l[0].f7Page || {}; let u, p; if ((a === "next" && s === "current" || a === "current" && s === "previous") && (u = "forward"), (a === "current" && s === "next" || a === "previous" && s === "current") && (u = "backward"), d && !d.fromPage) { const f = y(i); f.length && (p = f[0].f7Page) } p = d.pageFrom || p, p && p.pageFrom && (p.pageFrom = null); const m = { app: o.app, view: o.view, router: o, $el: l, el: l[0], $pageEl: l, pageEl: l[0], $navbarEl: c, navbarEl: c[0], name: l.attr("data-name"), position: a, from: a, to: s, direction: u, route: d.route ? d.route : r, pageFrom: p }; return l[0].f7Page = m, m } pageCallback(e, t, a, s, r, i, o) { if (i === void 0 && (i = {}), !t) return; const l = this, c = y(t); if (!c.length) return; const d = y(a), { route: u } = i, p = l.params.restoreScrollTopOnBack && !(l.params.masterDetailBreakpoint > 0 && c.hasClass("page-master") && l.app.width >= l.params.masterDetailBreakpoint), m = c[0].f7Page && c[0].f7Page.route && c[0].f7Page.route.route && c[0].f7Page.route.route.keepAlive; e === "beforeRemove" && m && (e = "beforeUnmount"); const f = `page${e[0].toUpperCase() + e.slice(1, e.length)}`, h = `page:${e.toLowerCase()}`; let b = {}; e === "beforeRemove" && c[0].f7Page ? b = R(c[0].f7Page, { from: s, to: r, position: s }) : b = l.getPageData(c[0], d[0], s, r, u, o), b.swipeBack = !!i.swipeBack; const { on: g = {}, once: v = {} } = i.route ? i.route.route : {}; i.on && R(g, i.on), i.once && R(v, i.once); function E() { c[0].f7RouteEventsAttached || (c[0].f7RouteEventsAttached = !0, g && Object.keys(g).length > 0 && (c[0].f7RouteEventsOn = g, Object.keys(g).forEach(w => { g[w] = g[w].bind(l), c.on(Ne(w), g[w]) })), v && Object.keys(v).length > 0 && (c[0].f7RouteEventsOnce = v, Object.keys(v).forEach(w => { v[w] = v[w].bind(l), c.once(Ne(w), v[w]) }))) } function $() { c[0].f7RouteEventsAttached && (c[0].f7RouteEventsOn && Object.keys(c[0].f7RouteEventsOn).forEach(w => { c.off(Ne(w), c[0].f7RouteEventsOn[w]) }), c[0].f7RouteEventsOnce && Object.keys(c[0].f7RouteEventsOnce).forEach(w => { c.off(Ne(w), c[0].f7RouteEventsOnce[w]) }), c[0].f7RouteEventsAttached = null, c[0].f7RouteEventsOn = null, c[0].f7RouteEventsOnce = null, delete c[0].f7RouteEventsAttached, delete c[0].f7RouteEventsOn, delete c[0].f7RouteEventsOnce) } if (e === "mounted" && E(), e === "init") { if (p && (s === "previous" || !s) && r === "current" && l.scrollHistory[b.route.url] && !c.hasClass("no-restore-scroll")) { let w = c.find(".page-content"); w.length > 0 && (w = w.filter(C => y(C).parents(".tab:not(.tab-active)").length === 0 && !y(C).is(".tab:not(.tab-active)"))), w.scrollTop(l.scrollHistory[b.route.url]) } if (E(), c[0].f7PageInitialized) { c.trigger("page:reinit", b), l.emit("pageReinit", b); return } c[0].f7PageInitialized = !0 } if (p && e === "beforeOut" && s === "current" && r === "previous") { let w = c.find(".page-content"); w.length > 0 && (w = w.filter(C => y(C).parents(".tab:not(.tab-active)").length === 0 && !y(C).is(".tab:not(.tab-active)"))), l.scrollHistory[b.route.url] = w.scrollTop() } p && e === "beforeOut" && s === "current" && r === "next" && delete l.scrollHistory[b.route.url], c.trigger(h, b), l.emit(f, b), (e === "beforeRemove" || e === "beforeUnmount") && ($(), m || (c[0].f7Page && c[0].f7Page.navbarEl && delete c[0].f7Page.navbarEl.f7Page, c[0].f7Page = null)) } saveHistory() { const e = this, t = U(); e.view.history = e.history, e.params.browserHistory && e.params.browserHistoryStoreHistory && t.localStorage && (t.localStorage[`f7router-${e.view.id}-history`] = JSON.stringify(e.history)) } restoreHistory() { const e = this, t = U(); e.params.browserHistory && e.params.browserHistoryStoreHistory && t.localStorage && t.localStorage[`f7router-${e.view.id}-history`] && (e.history = JSON.parse(t.localStorage[`f7router-${e.view.id}-history`]), e.view.history = e.history) } clearHistory() { const e = this; e.history = [], e.view && (e.view.history = []), e.saveHistory() } updateCurrentUrl(e) { const t = this; Ct(t, "updateCurrentUrl"), t.history.length ? t.history[t.history.length - 1] = e : t.history.push(e); const { query: a, hash: s, params: r, url: i, path: o } = t.parseRouteUrl(e); if (t.currentRoute && R(t.currentRoute, { query: a, hash: s, params: r, url: i, path: o }), t.params.browserHistory) { const l = t.params.browserHistoryRoot || ""; ae.replace(t.view.id, { url: e }, l + t.params.browserHistorySeparator + e) } t.saveHistory(), t.emit("routeUrlUpdate", t.currentRoute, t) } getInitialUrl() { const e = this; if (e.initialUrl) return { initialUrl: e.initialUrl, historyRestored: e.historyRestored }; const { app: t, view: a } = e, s = ee(), r = U(), i = t.params.url && typeof t.params.url == "string" && typeof URL < "u" ? new URL(t.params.url) : s.location; let o = e.params.url, l = i.href.split(i.origin)[1], c; const { browserHistory: d, browserHistoryOnLoad: u, browserHistorySeparator: p } = e.params; let { browserHistoryRoot: m } = e.params; return (r.cordova || r.Capacitor && r.Capacitor.isNative) && d && !p && !m && i.pathname.indexOf("index.html") && (console.warn("Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot"), m = i.pathname.split("index.html")[0]), !d || !u ? (o || (o = l), i.search && o.indexOf("?") < 0 && (o += i.search), i.hash && o.indexOf("#") < 0 && (o += i.hash)) : (m && l.indexOf(m) >= 0 && (l = l.substring(l.indexOf(m) + m.length), l === "" && (l = "/")), p.length > 0 && l.indexOf(p) >= 0 ? o = l.substring(l.indexOf(p) + p.length) : o = l, e.restoreHistory(), e.history.indexOf(o) >= 0 ? e.history = e.history.slice(0, e.history.indexOf(o) + 1) : e.params.url === o ? e.history = [o] : ae.state && ae.state[a.id] && ae.state[a.id].url === e.history[e.history.length - 1] ? o = e.history[e.history.length - 1] : e.history = [l.split(p)[0] || "/", o], e.history.length > 1 ? c = !0 : e.history = [], e.saveHistory()), e.initialUrl = o, e.historyRestored = c, { initialUrl: o, historyRestored: c } } init() { const e = this, { app: t, view: a } = e, s = ee(); e.mount(); const { initialUrl: r, historyRestored: i } = e.getInitialUrl(); (a && e.params.iosSwipeBack && t.theme === "ios" || a && e.params.mdSwipeBack && t.theme === "md") && so(e); const { browserHistory: o, browserHistoryOnLoad: l, browserHistoryAnimateOnLoad: c, browserHistoryInitialMatch: d } = e.params; let u; if (e.history.length > 1) { const p = d ? r : e.history[0]; u = e.findMatchingRoute(p), u || (u = R(e.parseRouteUrl(p), { route: { url: p, path: p.split("?")[0] } })) } else u = e.findMatchingRoute(r), u || (u = R(e.parseRouteUrl(r), { route: { url: r, path: r.split("?")[0] } })); if (e.$el.children(".page").length === 0 && r && e.params.loadInitialPage) e.navigate(r, { initial: !0, reloadCurrent: !0, browserHistory: !1, animate: !1, once: { modalOpen() { if (!i) return; (e.params.preloadPreviousPage || e.params[`${t.theme}SwipeBack`]) && e.history.length > 1 && e.back({ preload: !0 }) }, pageAfterIn() { if (!i) return; (e.params.preloadPreviousPage || e.params[`${t.theme}SwipeBack`]) && e.history.length > 1 && e.back({ preload: !0 }) } } }); else if (e.$el.children(".page").length) { let p; e.currentRoute = u, e.$el.children(".page").each(m => { const f = y(m); let h; e.setPagePosition(f, "current"), e.dynamicNavbar && (h = f.children(".navbar"), h.length > 0 ? (e.$navbarsEl.parents(s).length || e.$el.prepend(e.$navbarsEl), e.setNavbarPosition(h, "current"), e.$navbarsEl.append(h), h.children(".title-large").length && h.addClass("navbar-large"), f.children(".navbar").remove()) : (e.$navbarsEl.addClass("navbar-hidden"), h.children(".title-large").length && e.$navbarsEl.addClass("navbar-hidden navbar-large-hidden"))), e.currentRoute && e.currentRoute.route && (e.currentRoute.route.master === !0 || typeof e.currentRoute.route.master == "function" && e.currentRoute.route.master(t, e)) && e.params.masterDetailBreakpoint > 0 && (f.addClass("page-master"), f.trigger("page:role", { role: "master" }), h && h.length && h.addClass("navbar-master"), a.checkMasterDetailBreakpoint()); const b = { route: e.currentRoute }; e.currentRoute && e.currentRoute.route && e.currentRoute.route.options && R(b, e.currentRoute.route.options), e.currentPageEl = f[0], e.dynamicNavbar && h.length && (e.currentNavbarEl = h[0]), e.removeThemeElements(f), e.dynamicNavbar && h.length && e.removeThemeElements(h), b.route.route.tab && (p = !0, e.tabLoad(b.route.route.tab, R({}, b))), e.pageCallback("init", f, h, "current", void 0, b), e.pageCallback("beforeIn", f, h, "current", void 0, b), e.pageCallback("afterIn", f, h, "current", void 0, b) }), i && (d ? (e.params.preloadPreviousPage || e.params[`${t.theme}SwipeBack`]) && e.history.length > 1 && e.back({ preload: !0 }) : e.navigate(r, { initial: !0, browserHistory: !1, history: !1, animate: c, once: { pageAfterIn() { (e.params.preloadPreviousPage || e.params[`${t.theme}SwipeBack`]) && e.history.length > 2 && e.back({ preload: !0 }) } } })), !i && !p && (e.history.push(r), e.saveHistory()) } r && o && l && (!ae.state || !ae.state[a.id]) && ae.initViewState(a.id, { url: r }), e.emit("local::init routerInit", e) } destroy() { let e = this; e.emit("local::destroy routerDestroy", e), Object.keys(e).forEach(t => { e[t] = null, delete e[t] }), e = null }
} Le.prototype.navigate = io; Le.prototype.refreshPage = ro; Le.prototype.tabLoad = oo; Le.prototype.tabRemove = lo; Le.prototype.modalLoad = co; Le.prototype.modalRemove = uo; Le.prototype.back = po; Le.prototype.clearPreviousHistory = ho; const Xa = { name: "router", static: { Router: Le }, instance: { cache: { xhr: [], templates: [], components: [] } }, create() { const n = this; n.app ? n.params.router && (n.router = new Le(n.app, n)) : n.router = new Le(n) } }; function mo(n) { const e = n.app, t = Ee(); if (n.resizableInitialized) return; R(n, { resizable: !0, resizableWidth: null, resizableInitialized: !0 }); const a = y("html"), { $el: s } = n; if (!s) return; let r, i, o; const l = {}; let c, d, u, p; function m($) { if (!$) return null; if ($.indexOf("%") >= 0 || $.indexOf("vw") >= 0) return parseInt($, 10) / 100 * e.width; const w = parseInt($, 10); return Number.isNaN(w) ? null : w } function f() { return n.resizable && s.hasClass("view-resizable") && s.hasClass("view-master-detail") } function h($) { if (!f()) return; l.x = $.type === "touchstart" ? $.targetTouches[0].pageX : $.pageX, l.y = $.type === "touchstart" ? $.targetTouches[0].pageY : $.pageY, o = !1, i = !0; const w = s.children(".page-master"); u = m(w.css("min-width")), p = m(w.css("max-width")) } function b($) { if (!i) return; $.f7PreventSwipePanel = !0; const w = $.type === "touchmove" ? $.targetTouches[0].pageX : $.pageX; o || (d = r[0].offsetLeft + r[0].offsetWidth, s.addClass("view-resizing"), a.css("cursor", "col-resize")), o = !0, $.preventDefault(), c = w - l.x; let C = d + c; u && !Number.isNaN(u) && (C = Math.max(C, u)), p && !Number.isNaN(p) && (C = Math.min(C, p)), C = Math.min(Math.max(C, 0), e.width), n.resizableWidth = C, a[0].style.setProperty("--f7-page-master-width", `${C}px`), s.trigger("view:resize", C), n.emit("local::resize viewResize", n, C) } function g() { if (y("html").css("cursor", ""), !i || !o) { i = !1, o = !1; return } i = !1, o = !1, a[0].style.setProperty("--f7-page-master-width", `${n.resizableWidth}px`), s.removeClass("view-resizing") } function v() { n.resizableWidth && (u = m(r.css("min-width")), p = m(r.css("max-width")), u && !Number.isNaN(u) && n.resizableWidth < u && (n.resizableWidth = Math.max(n.resizableWidth, u)), p && !Number.isNaN(p) && n.resizableWidth > p && (n.resizableWidth = Math.min(n.resizableWidth, p)), n.resizableWidth = Math.min(Math.max(n.resizableWidth, 0), e.width), a[0].style.setProperty("--f7-page-master-width", `${n.resizableWidth}px`)) } r = n.$el.children(".view-resize-handler"), r.length || (n.$el.append('<div class="view-resize-handler"></div>'), r = n.$el.children(".view-resize-handler")), n.$resizeHandlerEl = r, s.addClass("view-resizable"); const E = t.passiveListener ? { passive: !0 } : !1; n.$el.on(e.touchEvents.start, ".view-resize-handler", h, E), e.on("touchmove:active", b), e.on("touchend:passive", g), e.on("resize", v), n.on("beforeOpen", v), n.once("viewDestroy", () => { s.removeClass("view-resizable"), n.$resizeHandlerEl.remove(), n.$el.off(e.touchEvents.start, ".view-resize-handler", h, E), e.off("touchmove:active", b), e.off("touchend:passive", g), e.off("resize", v), n.off("beforeOpen", v) }) } let Qt = class extends me { constructor(e, t, a) { a === void 0 && (a = {}), super(a, [e]); const s = this, r = s.params.routerId, i = { routes: [], routesAdd: [] }; if (!r && !y(t).length) { let c = "Framework7: can't create a View instance because "; throw c += typeof t == "string" ? `the selector "${t}" didn't match any element` : "el must be an HTMLElement or Dom7 object", new Error(c) } s.params = R({ el: t }, i, e.params.view, a), s.params.routes.length > 0 ? s.routes = s.params.routes : s.routes = [].concat(e.routes, s.params.routesAdd), R(!1, s, { app: e, name: s.params.name, main: s.params.main, history: [], scrollHistory: {} }), s.useModules(), e.views.push(s), s.main && (e.views.main = s), s.name && (e.views[s.name] = s), s.index = e.views.indexOf(s); let o; return s.name ? o = `view_${s.name}` : s.main ? o = "view_main" : o = `view_${s.index}`, s.id = o, s.params.init && (e.initialized ? s.init() : e.on("init", () => { s.init() })), s } destroy() { let e = this; const t = e.app; e.$el.trigger("view:beforedestroy"), e.emit("local::beforeDestroy viewBeforeDestroy", e), t.off("resize", e.checkMasterDetailBreakpoint), e.main ? (t.views.main = null, delete t.views.main) : e.name && (t.views[e.name] = null, delete t.views[e.name]), e.$el[0].f7View = null, delete e.$el[0].f7View, t.views.splice(t.views.indexOf(e), 1), e.params.router && e.router && e.router.destroy(), e.emit("local::destroy viewDestroy", e), Object.keys(e).forEach(a => { e[a] = null, delete e[a] }), e = null } checkMasterDetailBreakpoint(e) { const t = this, a = t.app, s = t.$el.hasClass("view-master-detail"), r = a.width >= t.params.masterDetailBreakpoint && t.$el.children(".page-master").length; typeof e > "u" && r || e === !0 ? (t.$el.addClass("view-master-detail"), s || (t.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", t), t.$el.trigger("view:masterDetailBreakpoint"))) : (t.$el.removeClass("view-master-detail"), s && (t.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", t), t.$el.trigger("view:masterDetailBreakpoint"))) } initMasterDetail() { const e = this, t = e.app; e.checkMasterDetailBreakpoint = e.checkMasterDetailBreakpoint.bind(e), e.checkMasterDetailBreakpoint(), e.params.masterDetailResizable && mo(e), t.on("resize", e.checkMasterDetailBreakpoint) } mount(e) { const t = this, a = t.app, s = t.params.el || e, r = y(s); let i; typeof s == "string" ? i = s : i = (r.attr("id") ? `#${r.attr("id")}` : "") + (r.attr("class") ? `.${r.attr("class").replace(/ /g, ".").replace(".active", "")}` : ""); let o; a.theme === "ios" && t.params.iosDynamicNavbar && (o = r.children(".navbars").eq(0), o.length === 0 && (o = y('<div class="navbars"></div>'))), R(t, { $el: r, el: r[0], main: t.main || r.hasClass("view-main"), $navbarsEl: o, navbarsEl: o ? o[0] : void 0, selector: i }), t.main && (a.views.main = t), r && r[0] && (r[0].f7View = t), t.emit("local::mount viewMount", t) } init(e) { const t = this; t.mount(e), t.params.router && (t.params.masterDetailBreakpoint > 0 && t.initMasterDetail(), t.params.initRouterOnTabShow && t.$el.hasClass("tab") && !t.$el.hasClass("tab-active") ? t.$el.once("tab:show", () => { t.router.init() }) : t.router.init(), t.$el.trigger("view:init"), t.emit("local::init viewInit", t)) } }; Qt.use(Xa); function go(n) { function e(t) { const a = U(), s = y(t.target), r = s.closest("a"), i = r.length > 0, o = i && r.attr("href"); if (i && (r.is(n.params.clicks.externalLinks) || o && o.indexOf("javascript:") >= 0)) { const d = r.attr("target"); o && a.cordova && a.cordova.InAppBrowser && (d === "_system" || d === "_blank") ? (t.preventDefault(), a.cordova.InAppBrowser.open(o, d)) : o && a.Capacitor && a.Capacitor.Plugins && a.Capacitor.Plugins.Browser && (d === "_system" || d === "_blank") && (t.preventDefault(), a.Capacitor.Plugins.Browser.open({ url: o })); return } Object.keys(n.modules).forEach(d => { const u = n.modules[d].clicks; u && (t.preventF7Router || Object.keys(u).forEach(p => { const m = s.closest(p).eq(0); m.length > 0 && u[p].call(n, m, m.dataset(), t) })) }); let l = {}; if (i && (t.preventDefault(), l = r.dataset()), l.clickedEl = r[0], t.preventF7Router || r.hasClass("prevent-router") || r.hasClass("router-prevent")) return; if (o && o.length > 0 && o[0] !== "#" || r.hasClass("back")) { let d; if (l.view && l.view === "current" ? d = n.views.current : l.view ? d = y(l.view)[0].f7View : (d = s.parents(".view")[0] && s.parents(".view")[0].f7View, !r.hasClass("back") && d && d.params.linksView && (typeof d.params.linksView == "string" ? d = y(d.params.linksView)[0].f7View : d.params.linksView instanceof Qt && (d = d.params.linksView))), d || n.views.main && (d = n.views.main), !d || !d.router) return; r[0].f7RouteProps && (l.props = r[0].f7RouteProps), r.hasClass("back") ? d.router.back(o, l) : d.router.navigate(o, l) } } n.on("click", e) } const gs = { name: "clicks", params: { clicks: { externalLinks: ".external" } }, on: { init() { go(this) } } }, vs = { name: "routerComponentLoader", proto: { openIn(n, e, t) { const a = { url: e, route: { path: e, options: { ...t, openIn: void 0 } } }, s = { ...t }; if (t.openIn === "popup" && (s.content = `<div class="popup popup-router-open-in" data-url="${e}"><div class="view view-init" data-links-view="${n.view.selector}" data-url="${e}" data-ignore-open-in="true"></div></div>`, a.route.popup = s), t.openIn === "loginScreen" && (s.content = `<div class="login-screen login-screen-router-open-in" data-url="${e}"><div class="view view-init" data-links-view="${n.view.selector}" data-url="${e}" data-ignore-open-in="true"></div></div>`, a.route.loginScreen = s), t.openIn === "sheet" && (s.content = `<div class="sheet-modal sheet-modal-router-open-in" data-url="${e}"><div class="sheet-modal-inner"><div class="view view-init" data-links-view="${n.view.selector}" data-url="${e}" data-ignore-open-in="true"></div></div></div>`, a.route.sheet = s), t.openIn === "popover" && (s.targetEl = t.clickedEl || t.targetEl, s.content = `<div class="popover popover-router-open-in" data-url="${e}"><div class="popover-inner"><div class="view view-init" data-links-view="${n.view.selector}" data-url="${e}" data-ignore-open-in="true"></div></div></div>`, a.route.popover = s), t.openIn.indexOf("panel") >= 0) { const r = t.openIn.split(":"), i = r[1] || "left", o = r[2] || "cover"; s.targetEl = t.clickedEl || t.targetEl, s.content = `<div class="panel panel-router-open-in panel-${i} panel-${o}" data-url="${e}"><div class="view view-init" data-links-view="${n.view.selector}" data-url="${e}" data-ignore-open-in="true"></div></div>`, a.route.panel = s } return n.navigate(a) }, componentLoader(n, e, t, a, s) { t === void 0 && (t = {}); const r = this, { app: i } = r, o = typeof n == "string" ? n : e, l = r.replaceRequestUrlParams(o, t); function c(u) { let p = t.context || {}; if (typeof p == "function") p = p.call(r); else if (typeof p == "string") try { p = JSON.parse(p) } catch (g) { throw s(g), g } const m = _t({}, p, { f7route: t.route, f7router: r }), f = _t(t.route ? t.route.params || {} : {}, t.props || {}, t.routeProps || {}); let h, b; t.componentOptions && t.componentOptions.el && (h = t.componentOptions.el), t.componentOptions && t.componentOptions.root && (b = t.componentOptions.root), i.component.create(u, f, { context: m, el: h, root: b }).then(g => { a(g.el) }).catch(g => { throw s(g), new Error(g) }) } let d; l && r.params.componentCache && r.cache.components.forEach(u => { u.url === l && (d = u.component) }), l && d ? c(d) : l && !d ? (r.xhrAbortController && (r.xhrAbortController.abort(), r.xhrAbortController = !1), r.xhrRequest(o, t).then(u => { const p = i.component.parse(u); r.params.componentCache && r.cache.components.push({ url: l, component: p }), c(p) }).catch(u => { throw s(), u })) : c(n) }, modalComponentLoader(n) { let { component: e, componentUrl: t, options: a, resolve: s, reject: r } = n === void 0 ? {} : n; this.componentLoader(e, t, a, o => { s(o) }, r) }, tabComponentLoader(n) { let { component: e, componentUrl: t, options: a, resolve: s, reject: r } = n === void 0 ? {} : n; this.componentLoader(e, t, a, o => { s(o) }, r) }, pageComponentLoader(n) { let { component: e, componentUrl: t, options: a, resolve: s, reject: r } = n === void 0 ? {} : n; this.componentLoader(e, t, a, function (o, l) { l === void 0 && (l = {}), s(o, l) }, r) } } }; var bs = function (n, e, t, a) { var s; e[0] = 0; for (var r = 1; r < e.length; r++) { var i = e[r++], o = e[r] ? (e[0] |= i ? 1 : 2, t[e[r++]]) : e[++r]; i === 3 ? a[0] = o : i === 4 ? a[1] = Object.assign(a[1] || {}, o) : i === 5 ? (a[1] = a[1] || {})[e[++r]] = o : i === 6 ? a[1][e[++r]] += o + "" : i ? (s = n.apply(o, bs(n, o, t, ["", null])), a.push(s), o[0] ? e[0] |= 2 : (e[r - 2] = 0, e[r] = s)) : a.push(o) } return a }, cn = new Map; function vo(n) {
  var e = cn.get(this); return e || (e = new Map, cn.set(this, e)), (e = bs(this, e.get(n) || (e.set(n, e = function (t) {
    for (var a, s, r = 1, i = "", o = "", l = [0], c = function (p) { r === 1 && (p || (i = i.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? l.push(0, p, i) : r === 3 && (p || i) ? (l.push(3, p, i), r = 2) : r === 2 && i === "..." && p ? l.push(4, p, 0) : r === 2 && i && !p ? l.push(5, 0, !0, i) : r >= 5 && ((i || !p && r === 5) && (l.push(r, 0, i, s), r = 6), p && (l.push(r, p, 0, s), r = 6)), i = "" }, d = 0; d < t.length; d++) {
      d && (r === 1 && c(), c(d)); for (var u = 0; u < t[d].length; u++)a = t[d][u], r === 1 ? a === "<" ? (c(), l = [l], r = 3) : i += a : r === 4 ? i === "--" && a === ">" ? (r = 1, i = "") : i = a + i[0] : o ? a === o ? o = "" : i += a : a === '"' || a === "'" ? o = a : a === ">" ? (c(), r = 1) : r && (a === "=" ? (r = 5, s = i, i = "") : a === "/" && (r < 5 || t[d][u + 1] === ">") ? (c(), r === 3 && (l = l[0]), r = l, (l = l[0]).push(2, 0, r), r = 0) : a === " " || a === "	" || a === `
`|| a === "\r" ? (c(), r = 2) : i += a), r === 3 && i === "!--" && (r = 4, l = l[0])
    } return c(), l
  }(n)), e), arguments, [])).length > 1 ? e : e[0]
} const bo = [!1, null, "", void 0], yo = function (n, e) { for (var t = arguments.length, a = new Array(t > 2 ? t - 2 : 0), s = 2; s < t; s++)a[s - 2] = arguments[s]; return { type: n, props: e || {}, children: na(a.filter(r => bo.indexOf(r) < 0)) } }, Eo = vo.bind(yo); function Zt(n, e, t, a, s) { var r = e === void 0 ? void 0 : e.key; return { sel: n, data: e, children: t, text: a, elm: s, key: r } } var Yt = Array.isArray; function qt(n) { return typeof n == "string" || typeof n == "number" } function ys(n, e, t) { if (n.ns = "http://www.w3.org/2000/svg", t !== "foreignObject" && e !== void 0) for (var a = 0; a < e.length; ++a) { var s = e[a].data; s !== void 0 && ys(s, e[a].children, e[a].sel) } } function wo(n, e, t) { var a = {}, s, r, i; if (t !== void 0 ? (a = e, Yt(t) ? s = t : qt(t) ? r = t : t && t.sel && (s = [t])) : e !== void 0 && (Yt(e) ? s = e : qt(e) ? r = e : e && e.sel ? s = [e] : a = e), Yt(s)) for (i = 0; i < s.length; ++i)qt(s[i]) && (s[i] = Zt(void 0, void 0, void 0, s[i], void 0)); return n[0] === "s" && n[1] === "v" && n[2] === "g" && (n.length === 3 || n[3] === "." || n[3] === "#") && ys(a, s, n), Zt(n, a, s, r, void 0) } const ra = {}, Co = "area base br col command embed hr img input keygen link menuitem meta param source track wbr".split(" "), $o = "hidden checked disabled readonly selected autofocus autoplay required multiple value indeterminate routeProps innerHTML".split(" "), dn = "hidden checked disabled readonly selected autofocus autoplay required multiple readOnly indeterminate".split(" "), Ga = n => typeof n.type == "function" ? n.type.name || "CustomComponent" : n.type, xo = n => n.split("-").map((e, t) => t === 0 ? e.toLowerCase() : e[0].toUpperCase() + e.substr(1)).join(""), Es = function () { const n = {}; for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; return t.forEach(function (s) { s === void 0 && (s = {}), Object.keys(s).forEach(r => { n[xo(r)] = s[r] }) }), n }, ko = n => { let { f7: e, treeNode: t, vnode: a, data: s } = n; const r = typeof t.type == "function" ? t.type : ra[t.type]; e.component.create(r, Es(s.attrs || {}, s.props || {}), { el: a.elm, children: t.children }).then(i => { a.data && a.data.on && i && i.$el && Object.keys(a.data.on).forEach(o => { i.$el.on(o, a.data.on[o]) }), a.elm.__component__ = i }) }, To = n => { const e = n && n.elm && n.elm.__component__; if (!e) return; const t = Es(n.data.attrs || {}, n.data.props || {}); e.children = n.data.treeNode.children, Object.assign(e.props, t), e.update() }, So = n => { const e = n && n.elm && n.elm.__component__; if (e) { const { el: t, $el: a } = e; n.data && n.data.on && a && Object.keys(n.data.on).forEach(s => { a.off(s, n.data.on[s]) }), e.destroy && e.destroy(), t && t.parentNode && t.parentNode.removeChild(t), delete n.elm.__component__ } }, ws = n => typeof n == "function" || n && n.indexOf("-") > 0 && ra[n]; function Mo(n, e, t, a, s) { const r = {}, i = [], o = [], l = [], c = []; let d = !1, u = Ga(n); e && e.attrs && e.attrs.component && (u = e.attrs.component, delete e.attrs.component, d = !0); const p = ws(n.type); if (p && (i.push(m => { m.sel !== u && !d || ko({ f7: t, treeNode: n, vnode: m, data: e }) }), o.push(m => { So(m) }), l.push((m, f) => { To(f) })), !p) { if (!e || !e.attrs || !e.attrs.class) return r; e.attrs.class.split(" ").forEach(f => { a || i.push(...t.getVnodeHooks("insert", f)), o.push(...t.getVnodeHooks("destroy", f)), l.push(...t.getVnodeHooks("update", f)), c.push(...t.getVnodeHooks("postpatch", f)) }) } return s && !a && c.push((m, f) => { const h = f || m; h && h.data && h.data.component && h.data.component.hook("onUpdated") }), i.length === 0 && o.length === 0 && l.length === 0 && c.length === 0 || (i.length && (r.insert = m => { i.forEach(f => f(m)) }), o.length && (r.destroy = m => { o.forEach(f => f(m)) }), l.length && (r.update = (m, f) => { l.forEach(h => h(m, f)) }), c.length && (r.postpatch = (m, f) => { c.forEach(h => h(m, f)) })), r } const Po = function (n, e) { let { stop: t, prevent: a, once: s } = e === void 0 ? {} : e, r = !1; function i() { const o = arguments.length <= 0 ? void 0 : arguments[0]; s && r || (t && o.stopPropagation(), a && o.preventDefault(), r = !0, n(...arguments)) } return i }, Ao = (n, e, t, a, s) => { const r = { component: e, treeNode: n }, i = Ga(n); Object.keys(n.props).forEach(l => { const c = n.props[l]; if (!(typeof c > "u")) if ($o.indexOf(l) >= 0) r.props || (r.props = {}), l === "readonly" && (l = "readOnly"), l === "routeProps" && (l = "f7RouteProps"), i === "option" && l === "value" && (r.attrs || (r.attrs = {}), r.attrs.value = c), dn.indexOf(l) >= 0 ? r.props[l] = c !== !1 : r.props[l] = c; else if (l === "key") r.key = c; else if (l.indexOf("@") === 0 || l.indexOf("on") === 0 && l.length > 2) { r.on || (r.on = {}); let d = l.indexOf("@") === 0 ? l.substr(1) : Ne(l.substr(2)), u = !1, p = !1, m = !1; d.indexOf(".") >= 0 && d.split(".").forEach((f, h) => { h === 0 ? d = f : (f === "stop" && (u = !0), f === "prevent" && (p = !0), f === "once" && (m = !0)) }), r.on[d] = Po(c, { stop: u, prevent: p, once: m }) } else l === "style" ? typeof c != "string" ? r.style = c : (r.attrs || (r.attrs = {}), r.attrs.style = c) : (r.attrs || (r.attrs = {}), r.attrs[l] = c, l === "id" && !r.key && !s && (r.key = c)) }); const o = Mo(n, r, t, a, s); return o.prepatch = (l, c) => { !l || !c || l && l.data && l.data.props && Object.keys(l.data.props).forEach(d => { dn.indexOf(d) < 0 || (c.data || (c.data = {}), c.data.props || (c.data.props = {}), l.data.props[d] === !0 && !(d in c.data.props) && (c.data.props[d] = !1)) }) }, r.hook = o, r }, Cs = (n, e, t, a) => { if (n && n.type && Co.indexOf(n.type) >= 0) return []; const s = [], r = n.children; for (let i = 0; i < r.length; i += 1) { const o = r[i], l = Ua(o, e, t, a, !1); Array.isArray(l) ? s.push(...l) : l && s.push(l) } return s }, Io = (n, e, t, a) => { const s = n.props.name || "default", r = (e.children || []).filter(i => { let o = "default"; return i.props && (o = i.props.slot || "default"), o === s }); return r.length === 0 ? Cs(n, e, t, a) : r.map(i => Ua(i, e, t, a)) }, Oo = n => it(n) && "props" in n && "type" in n && "children" in n, Ua = (n, e, t, a, s) => { if (!Oo(n)) return String(n); if (n.type === "slot") return Io(n, e, t, a); const r = Ao(n, e, t, a, s), i = ws(n.type) ? [] : Cs(n, e, t, a); return wo(Ga(n), r, i) }; function fa(n, e, t) { return n === void 0 && (n = {}), Ua(n, e, e.f7, t, !0) } function Bo(n) { return document.createElement(n) } function Do(n, e) { return document.createElementNS(n, e) } function Lo(n) { return document.createTextNode(n) } function Ro(n) { return document.createComment(n) } function Ho(n, e, t) { t && t.parentNode !== n && t.__component__ && (t = t.__component__.el), n.insertBefore(e, t) } function zo(n, e) { n && n.removeChild(e) } function Fo(n, e) { n.appendChild(e) } function Vo(n) { return n.parentNode } function No(n) { return n.nextSibling } function Yo(n) { return n.tagName } function qo(n, e) { n.textContent = e } function jo(n) { return n.textContent } function Wo(n) { return n.nodeType === 1 } function Xo(n) { return n.nodeType === 3 } function Go(n) { return n.nodeType === 8 } var Uo = { createElement: Bo, createElementNS: Do, createTextNode: Lo, createComment: Ro, insertBefore: Ho, removeChild: zo, appendChild: Fo, parentNode: Vo, nextSibling: No, tagName: Yo, setTextContent: qo, getTextContent: jo, isElement: Wo, isText: Xo, isComment: Go }; function ha(n) { return n === void 0 } function ye(n) { return n !== void 0 } var un = Zt("", {}, [], void 0, void 0); function Tt(n, e) { return n.key === e.key && n.sel === e.sel } function _o(n) { return n.sel !== void 0 } function Ko(n, e, t) { var a, s = {}, r, i; for (a = e; a <= t; ++a)i = n[a], i != null && (r = i.key, r !== void 0 && (s[r] = a)); return s } var zt = ["create", "update", "remove", "destroy", "pre", "post"]; function Qo(n, e) { var t, a, s = {}, r = e !== void 0 ? e : Uo; for (t = 0; t < zt.length; ++t)for (s[zt[t]] = [], a = 0; a < n.length; ++a) { var i = n[a][zt[t]]; i !== void 0 && s[zt[t]].push(i) } function o(h) { var b = h.id ? "#" + h.id : "", g = h.className ? "." + h.className.split(" ").join(".") : ""; return Zt(r.tagName(h).toLowerCase() + b + g, {}, [], void 0, h) } function l(h, b) { return function () { if (--b === 0) { var v = r.parentNode(h); r.removeChild(v, h) } } } function c(h, b) { var g, v = h.data; v !== void 0 && ye(g = v.hook) && ye(g = g.init) && (g(h), v = h.data); var E = h.children, $ = h.sel; if ($ === "!") ha(h.text) && (h.text = ""), h.elm = r.createComment(h.text); else if ($ !== void 0) { var w = $.indexOf("#"), C = $.indexOf(".", w), k = w > 0 ? w : $.length, M = C > 0 ? C : $.length, A = w !== -1 || C !== -1 ? $.slice(0, Math.min(k, M)) : $, O = h.elm = ye(v) && ye(g = v.ns) ? r.createElementNS(g, A) : r.createElement(A); for (k < M && O.setAttribute("id", $.slice(k + 1, M)), C > 0 && O.setAttribute("class", $.slice(M + 1).replace(/\./g, " ")), g = 0; g < s.create.length; ++g)s.create[g](un, h); if (Yt(E)) for (g = 0; g < E.length; ++g) { var S = E[g]; S != null && r.appendChild(O, c(S, b)) } else qt(h.text) && r.appendChild(O, r.createTextNode(h.text)); g = h.data.hook, ye(g) && (g.create && g.create(un, h), g.insert && b.push(h)) } else h.elm = r.createTextNode(h.text); return h.elm } function d(h, b, g, v, E, $) { for (; v <= E; ++v) { var w = g[v]; w != null && r.insertBefore(h, c(w, $), b) } } function u(h) { var b, g, v = h.data; if (v !== void 0) { for (ye(b = v.hook) && ye(b = b.destroy) && b(h), b = 0; b < s.destroy.length; ++b)s.destroy[b](h); if (h.children !== void 0) for (g = 0; g < h.children.length; ++g)b = h.children[g], b != null && typeof b != "string" && u(b) } } function p(h, b, g, v) { for (; g <= v; ++g) { var E = void 0, $ = void 0, w = void 0, C = b[g]; if (C != null) if (ye(C.sel)) { for (u(C), $ = s.remove.length + 1, w = l(C.elm, $), E = 0; E < s.remove.length; ++E)s.remove[E](C, w); ye(E = C.data) && ye(E = E.hook) && ye(E = E.remove) ? E(C, w) : w() } else r.removeChild(h, C.elm) } } function m(h, b, g, v) { for (var E = 0, $ = 0, w = b.length - 1, C = b[0], k = b[w], M = g.length - 1, A = g[0], O = g[M], S, P, T, I; E <= w && $ <= M;)C == null ? C = b[++E] : k == null ? k = b[--w] : A == null ? A = g[++$] : O == null ? O = g[--M] : Tt(C, A) ? (f(C, A, v), C = b[++E], A = g[++$]) : Tt(k, O) ? (f(k, O, v), k = b[--w], O = g[--M]) : Tt(C, O) ? (f(C, O, v), r.insertBefore(h, C.elm, r.nextSibling(k.elm)), C = b[++E], O = g[--M]) : Tt(k, A) ? (f(k, A, v), r.insertBefore(h, k.elm, C.elm), k = b[--w], A = g[++$]) : (S === void 0 && (S = Ko(b, E, w)), P = S[A.key], ha(P) ? (r.insertBefore(h, c(A, v), C.elm), A = g[++$]) : (T = b[P], T.sel !== A.sel ? r.insertBefore(h, c(A, v), C.elm) : (f(T, A, v), b[P] = void 0, r.insertBefore(h, T.elm, C.elm)), A = g[++$])); (E <= w || $ <= M) && (E > w ? (I = g[M + 1] == null ? null : g[M + 1].elm, d(h, I, g, $, M, v)) : p(h, b, E, w)) } function f(h, b, g) { var v, E; ye(v = b.data) && ye(E = v.hook) && ye(v = E.prepatch) && v(h, b); var $ = b.elm = h.elm, w = h.children, C = b.children; if (h !== b) { if (b.data !== void 0) { for (v = 0; v < s.update.length; ++v)s.update[v](h, b); v = b.data.hook, ye(v) && ye(v = v.update) && v(h, b) } ha(b.text) ? ye(w) && ye(C) ? w !== C && m($, w, C, g) : ye(C) ? (ye(h.text) && r.setTextContent($, ""), d($, null, C, 0, C.length - 1, g)) : ye(w) ? p($, w, 0, w.length - 1) : ye(h.text) && r.setTextContent($, "") : h.text !== b.text && r.setTextContent($, b.text), ye(E) && ye(v = E.postpatch) && v(h, b) } } return function (b, g) { var v, E, $, w = []; for (v = 0; v < s.pre.length; ++v)s.pre[v](); for (_o(b) || (b = o(b)), Tt(b, g) ? f(b, g, w) : (E = b.elm, $ = r.parentNode(E), c(g, w), $ !== null && (r.insertBefore($, g.elm, r.nextSibling(E)), p($, [b], 0, 0))), v = 0; v < w.length; ++v)w[v].data.hook.insert(w[v]); for (v = 0; v < s.post.length; ++v)s.post[v](); return g } } var Zo = "http://www.w3.org/1999/xlink", Jo = "http://www.w3.org/XML/1998/namespace", pn = 58, el = 120; function fn(n, e) { var t, a = e.elm, s = n.data.attrs, r = e.data.attrs; if (!(!s && !r) && s !== r) { s = s || {}, r = r || {}; for (t in r) { var i = r[t], o = s[t]; o !== i && (i === !0 ? a.setAttribute(t, "") : i === !1 ? a.removeAttribute(t) : t.charCodeAt(0) !== el ? a.setAttribute(t, i) : t.charCodeAt(3) === pn ? a.setAttributeNS(Jo, t, i) : t.charCodeAt(5) === pn ? a.setAttributeNS(Zo, t, i) : a.setAttribute(t, i)) } for (t in s) t in r || a.removeAttribute(t) } } var tl = { create: fn, update: fn }; function hn(n, e) { var t, a, s, r = e.elm, i = n.data.props, o = e.data.props; if (!(!i && !o) && i !== o) { i = i || {}, o = o || {}; for (t in i) o[t] || delete r[t]; for (t in o) a = o[t], s = i[t], s !== a && (t !== "value" || r[t] !== a) && (r[t] = a) } } var al = { create: hn, update: hn }, mn = typeof window < "u" && window.requestAnimationFrame || setTimeout, nl = function (n) { mn(function () { mn(n) }) }; function sl(n, e, t) { nl(function () { n[e] = t }) } function gn(n, e) { var t, a, s = e.elm, r = n.data.style, i = e.data.style; if (!(!r && !i) && r !== i) { r = r || {}, i = i || {}; var o = "delayed" in r; for (a in r) i[a] || (a[0] === "-" && a[1] === "-" ? s.style.removeProperty(a) : s.style[a] = ""); for (a in i) if (t = i[a], a === "delayed" && i.delayed) for (var l in i.delayed) t = i.delayed[l], (!o || t !== r.delayed[l]) && sl(s.style, l, t); else a !== "remove" && t !== r[a] && (a[0] === "-" && a[1] === "-" ? s.style.setProperty(a, t) : s.style[a] = t) } } function rl(n) { var e, t, a = n.elm, s = n.data.style; if (!(!s || !(e = s.destroy))) for (t in e) a.style[t] = e[t] } function il(n, e) { var t = n.data.style; if (!t || !t.remove) { e(); return } var a, s = n.elm, r = 0, i, o = t.remove, l = 0, c = []; for (a in o) c.push(a), s.style[a] = o[a]; i = getComputedStyle(s); for (var d = i["transition-property"].split(", "); r < d.length; ++r)c.indexOf(d[r]) !== -1 && l++; s.addEventListener("transitionend", function (u) { u.target === s && --l, l === 0 && e() }) } var ol = { create: gn, update: gn, destroy: rl, remove: il }; function ll(n, e, t) { typeof n == "function" && n(e, ...t) } function cl(n, e, t) { const a = n.type, s = t.data.on; s && s[a] && ll(s[a], n, e, t) } function dl() { return function n(e) { for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)a[s - 1] = arguments[s]; cl(e, a, n.vnode) } } function ma(n, e) { const t = n.data.on, a = n.listener, s = n.elm, r = e && e.data.on, i = e && e.elm; if (t !== r && (t && a && (r ? Object.keys(t).forEach(o => { r[o] || y(s).off(o, a) }) : Object.keys(t).forEach(o => { y(s).off(o, a) })), r)) { const o = n.listener || dl(); e.listener = o, o.vnode = e, t ? Object.keys(r).forEach(l => { t[l] || y(i).on(l, o) }) : Object.keys(r).forEach(l => { y(i).on(l, o) }) } } const ul = { create: ma, update: ma, destroy: ma }, Ft = Qo([tl, al, ol, ul]), pl = [!1, null, "", void 0], fl = function (n, e) { for (var t = arguments.length, a = new Array(t > 2 ? t - 2 : 0), s = 2; s < t; s++)a[s - 2] = arguments[s]; const r = na((a || []).filter(i => pl.indexOf(i) < 0)); return n === "Fragment" ? r : { type: n, props: e || {}, children: r } }, hl = [{ name: "array", init: n => n, type: n => [n].find(Array.isArray), update: (n, e) => [e].filter(Array.isArray).find(() => (n.length = 0, n.push(...e))), insert: function (n, e, t) { return t === void 0 && (t = []), n.splice(Math.max(e, 0), 0, ...[t].flat()) }, replace: function (n, e, t) { return t === void 0 && (t = []), n.splice(Math.max(e, 0), Math.min(++e, 1), ...[t].flat()) }, append: function (n, e) { return e === void 0 && (e = []), n.push(...[e].flat()) }, prepend: function (n, e) { return e === void 0 && (e = []), n.unshift(...[e].flat()) }, swap: (n, e, t) => { [n[e], n[t]] = [n[t], n[e]] }, fromTo: function (n, e, t) { return t === void 0 && (t = e), n.splice(Math.max(t, 0), 0, ...n.splice(Math.max(e, 0), 1)) }, remove: function (n, e, t) { return t === void 0 && (t = n.map((a, s) => s)), [e].flat().filter(a => t.includes(a)).sort((a, s) => s - a).forEach(a => n.splice(a, 1)) }, clear: n => n.length = 0 }, { name: "object", init: n => n, type: n => [n].filter(e => [e !== null, e !== void 0].every(t => t)).find(e => Object.getPrototypeOf(e) === Object.prototype), update: (n, e) => Object.assign(n, e), insert: () => { }, replace: () => { }, append: () => { }, prepend: () => { }, swap: () => ({}), fromTo: () => ({}), remove: (n, e) => [e].flat().forEach(t => delete n[t]), clear: n => Object.keys(n).forEach(e => delete n[e]) }, { name: "atoms", type: () => !0, init: function (n, e) { return e === void 0 && (e = {}), Object.defineProperty(e, "value", { get: () => n, set: t => { n = t } }), e }, update: function (n, e) { e === void 0 && (e = n.value), n.value = e }, insert: () => ({}), replace: () => ({}), append: () => ({}), prepend: () => ({}), swap: () => ({}), fromTo: () => ({}), remove: () => ({}), clear: n => { n.value = void 0 } }]; class Ba { constructor(e, t, a, s) { a === void 0 && (a = {}); let { el: r, context: i, children: o } = s === void 0 ? {} : s; const l = ee(); _t(this, { f7: e, props: a || {}, context: i || {}, id: t.id || wt(), children: o || [], theme: { ios: e.theme === "ios", md: e.theme === "md" }, style: t.style, __updateQueue: [], __eventHandlers: [], __onceEventHandlers: [], __onBeforeMount: [], __onMounted: [], __onBeforeUpdate: [], __onUpdated: [], __onBeforeUnmount: [], __onUnmounted: [] }); const c = () => t(this.props, this.getComponentContext(!0)), d = u => new Promise((p, m) => { typeof u == "function" ? p(u) : u instanceof Promise ? u.then(f => { p(f) }).catch(f => { m(f) }) : m(new Error(`Framework7: Component render function is not a "function" type. Didn't you forget to "return $render"?`)) }); return new Promise((u, p) => { const m = c(); d(m).then(f => { this.renderFunction = f; const h = this.render(); if (r) { this.vnode = fa(h, this, !0), this.style && (this.styleEl = l.createElement("style"), this.styleEl.innerHTML = this.style), this.el = r, Ft(this.el, this.vnode), this.el = this.vnode.elm, this.$el = y(this.el), this.attachEvents(), this.el.f7Component = this, this.mount(), u(this); return } h && (this.vnode = fa(h, this, !0), this.el = l.createElement(this.vnode.sel || "div"), Ft(this.el, this.vnode), this.$el = y(this.el)), this.style && (this.styleEl = l.createElement("style"), this.styleEl.innerHTML = this.style), this.attachEvents(), this.el && (this.el.f7Component = this), u(this) }).catch(f => { p(f) }) }) } on(e, t) { this.__eventHandlers && this.__eventHandlers.push({ eventName: e, handler: t }) } once(e, t) { this.__eventHandlers && this.__onceEventHandlers.push({ eventName: e, handler: t }) } getComponentRef() { const e = this; return t => { let a = t; const s = {}; return Object.defineProperty(s, "value", { get() { return a }, set(r) { a = r, e.update() } }), s } } getComponentStore() { const { state: e, _gettersPlain: t, dispatch: a } = this.f7.store, s = { state: e, dispatch: a }; return s.getters = new Proxy(t, { get: (r, i) => { const o = r[i], l = c => { o.value = c, this.update() }; return o.onUpdated(l), o } }), s } getUseState() { var e = this; return t => { const a = [t].reduce(function (s, r, i, o, l) { return l === void 0 && (l = s.init(r)), { state: l, update: c => (s.update(l, c), e.update()), remove: c => (s.remove(l, c), e.update()), clear: () => (s.clear(l), e.update()), insert: (c, d) => (s.insert(l, c, d), e.update()), replace: (c, d) => (s.replace(l, c, d), e.update()), append: c => (s.append(l, c), e.update()), prepend: c => (s.prepend(l, c), e.update()), swap: (c, d) => (s.swap(l, c, d), e.update()), fromTo: (c, d) => (s.fromTo(l, c, d), e.update()), method: function (c) { return c === void 0 && (c = () => ({})), c(l), e.update() }, async: function (c) { return c === void 0 && (c = () => Promise.reject(l)), c(l).then(() => e.update()) } } }, hl.find(s => s.type(t))); return a.length = 12, a[Symbol.iterator] = function () { const r = Object.values(this); r.splice(r.indexOf(12), 1); let i = 0; return { next() { if (i < r.length) { const o = r[i]; return i += 1, { value: o, done: !1 } } return { done: !0 } } } }, a } } getComponentContext(e) { const t = { $f7route: this.context.f7route, $f7router: this.context.f7router, $h: Eo, $: y, $id: this.id, $f7: this.f7, $f7ready: this.f7ready.bind(this), $theme: this.theme, $tick: this.tick.bind(this), $update: this.update.bind(this), $emit: this.emit.bind(this), $store: this.getComponentStore(), $ref: this.getComponentRef(), $el: {}, $useState: this.getUseState() }; return Object.defineProperty(t.$el, "value", { get: () => this.$el }), e && Object.assign(t, { $on: this.on.bind(this), $once: this.once.bind(this), $onBeforeMount: a => this.__onBeforeMount.push(a), $onMounted: a => this.__onMounted.push(a), $onBeforeUpdate: a => this.__onBeforeUpdate.push(a), $onUpdated: a => this.__onUpdated.push(a), $onBeforeUnmount: a => this.__onBeforeUnmount.push(a), $onUnmounted: a => this.__onUnmounted.push(a) }), t } render() { return this.renderFunction(this.getComponentContext()) } emit(e, t) { this.el && this.$el.trigger(e, t) } attachEvents() { const { $el: e } = this; this.__eventHandlers && (this.__eventHandlers.forEach(t => { let { eventName: a, handler: s } = t; e.on(Ne(a), s) }), this.__onceEventHandlers.forEach(t => { let { eventName: a, handler: s } = t; e.once(Ne(a), s) })) } detachEvents() { const { $el: e } = this; this.__eventHandlers && (this.__eventHandlers.forEach(t => { let { eventName: a, handler: s } = t; e.on(Ne(a), s) }), this.__onceEventHandlers.forEach(t => { let { eventName: a, handler: s } = t; e.once(Ne(a), s) })) } startUpdateQueue() { const e = U(); if (this.__requestAnimationFrameId) return; const t = () => { this.hook("onBeforeUpdate"); const a = this.render(); if (a) { const s = fa(a, this, !1); this.vnode = Ft(this.vnode, s) } }; this.__requestAnimationFrameId = e.requestAnimationFrame(() => { this.__updateIsPending && t(); let a = [...this.__updateQueue]; this.__updateQueue = [], this.__updateIsPending = !1, e.cancelAnimationFrame(this.__requestAnimationFrameId), delete this.__requestAnimationFrameId, delete this.__updateIsPending, a.forEach(s => s()), a = [] }) } tick(e) { return new Promise(t => { function a() { t(), e && e() } this.__updateQueue.push(a), this.startUpdateQueue() }) } update(e) { return this.__destroyed ? new Promise(() => { }) : new Promise(t => { const a = () => { t(), e && e() }; this.__updateIsPending = !0, this.__updateQueue.push(a), this.startUpdateQueue() }) } setState(e) { return this.update(e) } f7ready(e) { if (this.f7.initialized) { e(this.f7); return } this.f7.once("init", () => { e(this.f7) }) } mount(e) { this.hook("onBeforeMount", this.$el), this.styleEl && y("head").append(this.styleEl), e && e(this.el), this.hook("onMounted", this.$el) } destroy() { if (this.__destroyed) return; const e = U(); this.hook("onBeforeUnmount"), this.styleEl && y(this.styleEl).remove(), this.detachEvents(), this.hook("onUnmounted"), this.el && this.el.f7Component && (this.el.f7Component = null, delete this.el.f7Component), this.vnode && (this.vnode = Ft(this.vnode, { sel: this.vnode.sel, data: {} })), e.cancelAnimationFrame(this.__requestAnimationFrameId), this.__updateQueue = [], this.__eventHandlers = [], this.__onceEventHandlers = [], this.__onBeforeMount = [], this.__onMounted = [], this.__onBeforeUpdate = [], this.__onUpdated = [], this.__onBeforeUnmount = [], this.__onUnmounted = [], ve(this), this.__destroyed = !0 } hook(e) { for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)a[s - 1] = arguments[s]; this.__destroyed || this[`__${e}`].forEach(r => { r(...a) }) } } Ba.$jsx = fl; function vn(n) {
  const e = U(), t = ee(), a = wt(), s = `f7_component_create_callback_${a}`; let r; n.match(/<template([ ]?)([a-z0-9-]*)>/) && (r = n.split(/<template[ ]?[a-z0-9-]*>/).filter((u, p) => p > 0).join("<template>").split("</template>").filter((u, p, m) => p < m.length - 1).join("</template>").replace(/{{#raw}}([ \n]*)<template/g, "{{#raw}}<template").replace(/\/template>([ \n]*){{\/raw}}/g, "/template>{{/raw}}").replace(/([ \n])<template/g, "$1{{#raw}}<template").replace(/\/template>([ \n])/g, "/template>{{/raw}}$1")); let o = null; n.indexOf("<style>") >= 0 && (o = n.split("<style>")[1].split("</style>")[0]), n.indexOf("<style scoped>") >= 0 && (o = n.split("<style scoped>")[1].split("</style>")[0]); let l; if (n.indexOf("<script>") >= 0) { const u = n.split("<script>"); l = u[u.length - 1].split("<\/script>")[0].trim() } else l = "return () => {return $render}"; (!l || !l.trim()) && (l = "return () => {return $render}"), r && (l = l.replace("$render", `function ($$ctx) {
          var $ = $$ctx.$$;
          var $h = $$ctx.$h;
          var $root = $$ctx.$root;
          var $f7 = $$ctx.$f7;
          var $f7route = $$ctx.$f7route;
          var $f7router = $$ctx.$f7router;
          var $theme = $$ctx.$theme;
          var $update = $$ctx.$update;
          var $store = $$ctx.$store;
          var $ref = $$ctx.$ref;
          var $useState = $$ctx.$useState;

          return $h\`${r}\`
        }
        `).replace(/export default/g, "return")), l = `window.${s} = function () {${l}}`; const c = t.createElement("script"); c.innerHTML = l, y("head").append(c); const d = e[s](); return y(c).remove(), e[s] = null, delete e[s], o && (d.style = o), d.id = a, d
} function bn(n, e) { ra[n] = e } function yn(n) { delete ra[n] } const $s = { name: "component", static: { Component: Ba, parseComponent: vn, registerComponent: bn, unregisterComponent: yn }, create() { const n = this; n.component = { registerComponent: bn, unregisterComponent: yn, parse(e) { return vn(e) }, create(e, t, a) { let { root: s, el: r, context: i, children: o } = a; return new Ba(n, e, t, { root: s, el: r, context: i, children: o }) } } } }, xs = { name: "history", static: { history: ae }, on: { init() { ae.init(this) } } }, tt = { registrations: [], register(n, e) { const t = this; return !("serviceWorker" in U().navigator) || !t.serviceWorker.container ? new Promise((s, r) => { r(new Error("Service worker is not supported")) }) : new Promise((s, r) => { t.serviceWorker.container.register(n, e ? { scope: e } : {}).then(i => { tt.registrations.push(i), t.emit("serviceWorkerRegisterSuccess", i), s(i) }).catch(i => { t.emit("serviceWorkerRegisterError", i), r(i) }) }) }, unregister(n) { const e = this; if (!("serviceWorker" in U().navigator) || !e.serviceWorker.container) return new Promise((s, r) => { r(new Error("Service worker is not supported")) }); let a; return n ? Array.isArray(n) ? a = n : a = [n] : a = tt.registrations, Promise.all(a.map(s => new Promise((r, i) => { s.unregister().then(() => { tt.registrations.indexOf(s) >= 0 && tt.registrations.splice(tt.registrations.indexOf(s), 1), e.emit("serviceWorkerUnregisterSuccess", s), r() }).catch(o => { e.emit("serviceWorkerUnregisterError", s, o), i(o) }) }))) } }, ks = { name: "sw", params: { serviceWorker: { path: void 0, scope: void 0 } }, create() { const n = this, e = U(); R(n, { serviceWorker: { container: "serviceWorker" in e.navigator ? e.navigator.serviceWorker : void 0, registrations: tt.registrations, register: tt.register.bind(n), unregister: tt.unregister.bind(n) } }) }, on: { init() { const n = U(); if (!("serviceWorker" in n.navigator)) return; const e = this; if (e.device.cordova || n.Capacitor && n.Capacitor.isNative || !e.serviceWorker.container) return; const t = e.params.serviceWorker.path, a = e.params.serviceWorker.scope; if (!t || Array.isArray(t) && !t.length) return; (Array.isArray(t) ? t : [t]).forEach(r => { e.serviceWorker.register(r, a) }) } } }; function Da(n) { n === void 0 && (n = {}); const e = { __store: !0 }, t = { ...n.state || {} }, a = { ...n.actions || {} }, s = { ...n.getters || {} }, r = R({}, t); let i = []; const o = {}, l = {}; Object.keys(s).forEach(h => { o[h] = [], l[h] = [] }); const c = h => s[h]({ state: e.state }), d = (h, b) => { o[h] || (o[h] = []), b.forEach(g => { o[h].indexOf(g) < 0 && o[h].push(g) }) }, u = (h, b) => { l[h] || (l[h] = []), l[h].push(b) }, p = h => { Object.keys(o).filter(g => o[g].indexOf(h) >= 0).forEach(g => { !l[g] || !l[g].length || l[g].forEach(v => { v(c(g)) }) }) }, m = h => { Object.keys(l).forEach(b => { const g = l[b]; g.indexOf(h) >= 0 && g.splice(g.indexOf(h), 1) }) }; e.__removeCallback = h => { m(h) }; const f = function (h, b) { if (b === void 0 && (b = !0), h === "constructor") return; i = []; const g = c(h); d(h, i); const E = { value: g, onUpdated: w => { u(h, w) } }; if (!b) return E; const $ = w => { E.value = w }; return E.__callback = $, u(h, $), E }; return e.state = new Proxy(r, { set: (h, b, g) => (h[b] = g, p(b), !0), get: (h, b) => (i.push(b), h[b]) }), e.getters = new Proxy(s, { set: () => !1, get: (h, b) => { if (h[b]) return f(b, !0) } }), e._gettersPlain = new Proxy(s, { set: () => !1, get: (h, b) => { if (h[b]) return f(b, !1) } }), e.dispatch = (h, b) => new Promise((g, v) => { if (!a[h]) throw v(), new Error(`Framework7: Store action "${h}" is not found`); const E = a[h]({ state: e.state, dispatch: e.dispatch }, b); g(E) }), e } const Ts = { name: "store", static: { createStore: Da }, proto: { createStore: Da } }, rt = () => { const n = U(); return n.Capacitor && n.Capacitor.isNative && n.Capacitor.Plugins && n.Capacitor.Plugins.StatusBar }, Oe = { hide() { const n = U(); ue().cordova && n.StatusBar && n.StatusBar.hide(), rt() && n.Capacitor.Plugins.StatusBar.hide() }, show() { const n = U(); ue().cordova && n.StatusBar && n.StatusBar.show(), rt() && n.Capacitor.Plugins.StatusBar.show() }, onClick() { const n = this; let e; y(".popup.modal-in").length > 0 ? e = y(".popup.modal-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : y(".panel.panel-in").length > 0 ? e = y(".panel.panel-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : y(".views > .view.tab-active").length > 0 ? e = y(".views > .view.tab-active").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : y(".views").length > 0 ? e = y(".views").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content") : e = n.$el.children(".view").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content"), e && e.length > 0 && (e.hasClass("tab") && (e = e.parent(".tabs").children(".page-content.tab-active")), e.length > 0 && e.scrollTop(0, 300)) }, setTextColor(n) { const e = U(); ue().cordova && e.StatusBar && (n === "white" ? e.StatusBar.styleLightContent() : e.StatusBar.styleDefault()), rt() && (n === "white" ? e.Capacitor.Plugins.StatusBar.setStyle({ style: "DARK" }) : e.Capacitor.Plugins.StatusBar.setStyle({ style: "LIGHT" })) }, setBackgroundColor(n) { const e = U(); ue().cordova && e.StatusBar && e.StatusBar.backgroundColorByHexString(n), rt() && e.Capacitor.Plugins.StatusBar.setBackgroundColor({ color: n }) }, isVisible() { const n = U(), e = ue(); return new Promise(t => { e.cordova && n.StatusBar && t(n.StatusBar.isVisible), rt() && n.Capacitor.Plugins.StatusBar.getInfo().then(a => { t(a.visible) }), t(!1) }) }, overlaysWebView(n) { n === void 0 && (n = !0); const e = U(); ue().cordova && e.StatusBar && e.StatusBar.overlaysWebView(n), rt() && e.Capacitor.Plugins.StatusBar.setOverlaysWebView({ overlay: n }) }, init() { const n = this, e = U(), t = ue(), a = n.params.statusbar; if (!a.enabled) return; const s = t.cordova && e.StatusBar, r = rt(); (s || r) && (a.scrollTopOnClick && y(e).on("statusTap", Oe.onClick.bind(n)), t.ios && (a.iosOverlaysWebView ? Oe.overlaysWebView(!0) : Oe.overlaysWebView(!1), a.iosTextColor === "white" ? Oe.setTextColor("white") : Oe.setTextColor("black")), t.android && (a.androidOverlaysWebView ? Oe.overlaysWebView(!0) : Oe.overlaysWebView(!1), a.androidTextColor === "white" ? Oe.setTextColor("white") : Oe.setTextColor("black"))), a.iosBackgroundColor && t.ios && Oe.setBackgroundColor(a.iosBackgroundColor), a.androidBackgroundColor && t.android && Oe.setBackgroundColor(a.androidBackgroundColor) } }, Ss = { name: "statusbar", params: { statusbar: { enabled: !0, scrollTopOnClick: !0, iosOverlaysWebView: !0, iosTextColor: "black", iosBackgroundColor: null, androidOverlaysWebView: !1, androidTextColor: "black", androidBackgroundColor: null } }, create() { Se(this, { statusbar: Oe }) }, on: { init() { const n = this; Oe.init.call(n) } } }; function ml(n) { const e = y(".popover.modal-in .view"), t = y(".popup.modal-in .view"), a = y(".panel.panel-in .view"); let s = y(".views"); s.length === 0 && (s = n.$el); let r = s.children(".view"); if (r.length === 0 && (r = s.children(".tabs").children(".view")), r.length > 1 && r.hasClass("tab") && (r = s.children(".view.tab-active"), r.length === 0 && (r = s.children(".tabs").children(".view.tab-active"))), e.length > 0 && e[0].f7View) return e[0].f7View; if (t.length > 0 && t[0].f7View) return t[0].f7View; if (a.length > 0 && a[0].f7View) return a[0].f7View; if (r.length > 0) { if (r.length === 1 && r[0].f7View) return r[0].f7View; if (r.length > 1) return n.views.main } } const Ms = { name: "view", params: { view: { init: !0, initRouterOnTabShow: !1, name: void 0, main: !1, router: !0, linksView: null, xhrCache: !0, xhrCacheIgnore: [], xhrCacheIgnoreGetParameters: !1, xhrCacheDuration: 1e3 * 60 * 10, componentCache: !0, preloadPreviousPage: !0, allowDuplicateUrls: !1, reloadPages: !1, reloadDetail: !1, masterDetailBreakpoint: 0, masterDetailResizable: !1, removeElements: !0, removeElementsWithTimeout: !1, removeElementsTimeout: 0, restoreScrollTopOnBack: !0, unloadTabContent: !0, passRouteQueryToRequest: !0, passRouteParamsToRequest: !1, loadInitialPage: !0, iosSwipeBack: !0, iosSwipeBackAnimateShadow: !0, iosSwipeBackAnimateOpacity: !0, iosSwipeBackActiveArea: 30, iosSwipeBackThreshold: 0, mdSwipeBack: !1, mdSwipeBackAnimateShadow: !0, mdSwipeBackAnimateOpacity: !1, mdSwipeBackActiveArea: 30, mdSwipeBackThreshold: 0, browserHistory: !1, browserHistoryRoot: void 0, browserHistoryAnimate: !0, browserHistoryAnimateOnLoad: !1, browserHistorySeparator: "#!", browserHistoryOnLoad: !0, browserHistoryInitialMatch: !1, browserHistoryStoreHistory: !0, browserHistoryTabs: "replace", animate: !0, iosDynamicNavbar: !0, iosAnimateNavbarBackIcon: !0, iosPageLoadDelay: 0, mdPageLoadDelay: 0, routesBeforeEnter: null, routesBeforeLeave: null } }, static: { View: Qt }, create() { const n = this; R(n, { views: R([], { create(e, t) { return new Qt(n, e, t) }, get(e) { const t = y(e); if (t.length && t[0].f7View) return t[0].f7View } }) }), Object.defineProperty(n.views, "current", { enumerable: !0, configurable: !0, get() { return ml(n) } }), n.view = n.views }, on: { init() { const n = this; y(".view-init").each(e => { if (e.f7View) return; const t = y(e).dataset(); n.views.create(e, t) }) }, "modalOpen panelOpen": function (e) { const t = this; e.$el.find(".view-init").each(a => { if (a.f7View) return; const s = y(a).dataset(); t.views.create(a, s) }) }, "modalBeforeDestroy panelBeforeDestroy": function (e) { !e || !e.$el || e.$el.find(".view-init").each(t => { const a = t.f7View; a && a.destroy() }) } }, vnode: { "view-init": { insert(n) { const e = this, t = n.elm; if (t.f7View) return; const a = y(t).dataset(); e.views.create(t, a) }, destroy(n) { const t = n.elm.f7View; t && t.destroy() } } } }, gl = { size(n) { const e = this; let t = y(n); if (t.hasClass("navbars")) { t = t.children(".navbar").each(S => { e.navbar.size(S) }); return } const a = t.children(".navbar-inner"); if (!a.length) return; const s = a.hasClass("navbar-inner-centered-title") || e.params.navbar[`${e.theme}CenterTitle`], r = e.theme === "ios" && !e.params.navbar[`${e.theme}CenterTitle`]; if (!s && !r || t.parents(".tab:not(.tab-active)").length > 0 || t.parents(".popup:not(.modal-in)").length > 0) return; e.theme !== "ios" && e.params.navbar[`${e.theme}CenterTitle`] && a.addClass("navbar-inner-centered-title"), e.theme === "ios" && !e.params.navbar.iosCenterTitle && a.addClass("navbar-inner-left-title"); const i = t.parents(".view").eq(0), o = e.rtl ? a.children(".right") : a.children(".left"), l = e.rtl ? a.children(".left") : a.children(".right"), c = a.children(".title"), d = a.children(".subnavbar"), u = o.length === 0, p = l.length === 0, m = u ? 0 : o.outerWidth(!0), f = p ? 0 : l.outerWidth(!0), h = c.outerWidth(!0), b = a.styles(), v = a[0].offsetWidth - parseInt(b.paddingLeft, 10) - parseInt(b.paddingRight, 10), E = t.hasClass("navbar-previous"), $ = a.hasClass("sliding"); let w, C; i.length > 0 && i[0].f7View && (w = i[0].f7View.router, C = w && w.dynamicNavbar); let k, M; p && (k = v - h), u && (k = 0), !u && !p && (k = (v - f - h + m) / 2); let A = (v - h) / 2; v - m - f > h ? (A < m && (A = m), A + h > v - f && (A = v - f - h), M = A - k) : M = 0; const O = e.rtl ? -1 : 1; if (C && e.theme === "ios") { if (c.hasClass("sliding") || c.length > 0 && $) { let S = -(k + M) * O; const P = (v - k - M - h) * O; if (E && w && w.params.iosAnimateNavbarBackIcon) { const T = t.parent().find(".navbar-current").children(".left.sliding").find(".back .icon ~ span"); T.length > 0 && (S += T[0].offsetLeft) } c[0].f7NavbarLeftOffset = S, c[0].f7NavbarRightOffset = P } if (!u && (o.hasClass("sliding") || $)) { if (e.rtl) o[0].f7NavbarLeftOffset = -(v - o[0].offsetWidth) / 2 * O, o[0].f7NavbarRightOffset = m * O; else if (o[0].f7NavbarLeftOffset = -m, o[0].f7NavbarRightOffset = (v - o[0].offsetWidth) / 2, w && w.params.iosAnimateNavbarBackIcon && o.find(".back .icon").length > 0 && o.find(".back .icon ~ span").length) { const S = o[0].f7NavbarLeftOffset, P = o[0].f7NavbarRightOffset; o[0].f7NavbarLeftOffset = 0, o[0].f7NavbarRightOffset = 0, o.find(".back .icon ~ span")[0].f7NavbarLeftOffset = S, o.find(".back .icon ~ span")[0].f7NavbarRightOffset = P - o.find(".back .icon")[0].offsetWidth } } !p && (l.hasClass("sliding") || $) && (e.rtl ? (l[0].f7NavbarLeftOffset = -f * O, l[0].f7NavbarRightOffset = (v - l[0].offsetWidth) / 2 * O) : (l[0].f7NavbarLeftOffset = -(v - l[0].offsetWidth) / 2, l[0].f7NavbarRightOffset = f)), d.length && (d.hasClass("sliding") || $) && (d[0].f7NavbarLeftOffset = e.rtl ? d[0].offsetWidth : -d[0].offsetWidth, d[0].f7NavbarRightOffset = -d[0].f7NavbarLeftOffset) } if (s) { let S = M; e.rtl && u && p && c.length > 0 && (S = -S), c.css({ left: `${S}px` }) } }, hide(n, e, t, a) { e === void 0 && (e = !0), t === void 0 && (t = !1), a === void 0 && (a = !1); const s = this; let r = y(n); const i = r.hasClass("navbar") && r.parent(".navbars").length && !a; if (i && (r = r.parents(".navbars")), !r.length || r.hasClass("navbar-hidden")) return; let o = `navbar-hidden${e ? " navbar-transitioning" : ""}`; (i ? r.find(".navbar-current .title-large").length : r.find(".title-large").length) && (o += " navbar-large-hidden"), t && (o += " navbar-hidden-statusbar"), r.transitionEnd(() => { r.removeClass("navbar-transitioning") }), r.addClass(o), i ? r.children(".navbar").each(c => { y(c).trigger("navbar:hide"), s.emit("navbarHide", c) }) : (r.trigger("navbar:hide"), s.emit("navbarHide", r[0])) }, show(n, e, t) { n === void 0 && (n = ".navbar-hidden"), e === void 0 && (e = !0), t === void 0 && (t = !1); const a = this; let s = y(n); const r = s.hasClass("navbar") && s.parent(".navbars").length && !t; r && (s = s.parents(".navbars")), s.length && s.hasClass("navbar-hidden") && (e && (s.addClass("navbar-transitioning"), s.transitionEnd(() => { s.removeClass("navbar-transitioning") })), s.removeClass("navbar-hidden navbar-large-hidden navbar-hidden-statusbar"), r ? s.children(".navbar").each(i => { y(i).trigger("navbar:show"), a.emit("navbarShow", i) }) : (s.trigger("navbar:show"), a.emit("navbarShow", s[0]))) }, getElByPage(n) { let e, t, a; if (n.$navbarEl || n.$el ? (a = n, e = n.$el) : (e = y(n), e.length > 0 && (a = e[0].f7Page)), a && a.$navbarEl && a.$navbarEl.length > 0 ? t = a.$navbarEl : e && (t = e.children(".navbar")), !(!t || t && t.length === 0)) return t[0] }, getPageByEl(n) { const e = y(n); if (e.parents(".page").length) return e.parents(".page")[0]; let t; return e.parents(".view").find(".page").each(a => { a && a.f7Page && a.f7Page.navbarEl && e[0] === a.f7Page.navbarEl && (t = a) }), t }, collapseLargeTitle(n) { const e = this; let t = y(n); if (t.hasClass("navbars") && (t = t.find(".navbar"), t.length > 1 && (t = y(n).find(".navbar-large.navbar-current")), t.length > 1 || !t.length)) return; const a = y(e.navbar.getPageByEl(t)); t.addClass("navbar-large-collapsed"), a.eq(0).addClass("page-with-navbar-large-collapsed").trigger("page:navbarlargecollapsed"), e.emit("pageNavbarLargeCollapsed", a[0]), t.trigger("navbar:collapse"), e.emit("navbarCollapse", t[0]) }, expandLargeTitle(n) { const e = this; let t = y(n); if (t.hasClass("navbars") && (t = t.find(".navbar-large"), t.length > 1 && (t = y(n).find(".navbar-large.navbar-current")), t.length > 1 || !t.length)) return; const a = y(e.navbar.getPageByEl(t)); t.removeClass("navbar-large-collapsed"), a.eq(0).removeClass("page-with-navbar-large-collapsed").trigger("page:navbarlargeexpanded"), e.emit("pageNavbarLargeExpanded", a[0]), t.trigger("navbar:expand"), e.emit("navbarExpand", t[0]) }, toggleLargeTitle(n) { const e = this; let t = y(n); t.hasClass("navbars") && (t = t.find(".navbar-large"), t.length > 1 && (t = y(n).find(".navbar-large.navbar-current")), t.length > 1 || !t.length) || (t.hasClass("navbar-large-collapsed") ? e.navbar.expandLargeTitle(t) : e.navbar.collapseLargeTitle(t)) }, initNavbarOnScroll(n, e, t, a, s) { const r = this, i = Ee(), o = y(n), l = y(e), c = l.find(".title-large"), d = c.length || l.hasClass(".navbar-large"); let u = 44; const p = r.params.navbar.snapPageScrollToLargeTitle, m = r.params.navbar.snapPageScrollToTransparentNavbar; let f, h, b, g, v, E, $, w, C, k; (a || t && d) && (C = l.css("--f7-navbar-large-title-height"), C && C.indexOf("px") >= 0 ? (C = parseInt(C, 10), Number.isNaN(C) && c.length ? C = c[0].offsetHeight : Number.isNaN(C) && (r.theme === "ios" ? C = 52 : r.theme === "md" && (C = 88))) : c.length ? C = c[0].offsetHeight : r.theme === "ios" ? C = 52 : r.theme === "md" && (C = 88)), t && d && (u += C); let M, A, O, S; const P = 70, T = 300; function I() { o.find(".page-content").each(Q => { Q.f7ScrollableDistance = Q.scrollHeight - Q.offsetHeight }) } function H() { l.hasClass("with-searchbar-expandable-enabled") || !A || h < 0 || (h >= C / 2 && h < C ? y(A).scrollTop(C, 100) : h < C && y(A).scrollTop(0, 200)) } function D() { l.hasClass("with-searchbar-expandable-enabled") || !A || h < 0 || (h >= k / 2 && h < k ? y(A).scrollTop(k, 100) : h < k && y(A).scrollTop(0, 200)) } function z() { const Q = l.hasClass("navbar-hidden") || l.parent(".navbars").hasClass("navbar-hidden"); if (l.hasClass("with-searchbar-expandable-enabled") || Q) return; k || (k = e.offsetHeight); let Y = h / k; const X = l.hasClass("navbar-transparent-visible"); if (Y = Math.max(Math.min(Y, 1), 0), X && Y === 1 || !X && Y === 0) { l.find(".navbar-bg, .title").css("opacity", ""); return } if (X && Y === 0) { l.trigger("navbar:transparenthide"), r.emit("navbarTransparentHide", l[0]), l.removeClass("navbar-transparent-visible"), l.find(".navbar-bg, .title").css("opacity", ""); return } if (!X && Y === 1) { l.trigger("navbar:transparentshow"), r.emit("navbarTransparentShow", l[0]), l.addClass("navbar-transparent-visible"), l.find(".navbar-bg, .title").css("opacity", ""); return } l.find(".navbar-bg, .title").css("opacity", Y), m && (i.touch ? S && (clearTimeout(S), S = null, S = setTimeout(() => { D(), clearTimeout(S), S = null }, P)) : (clearTimeout(O), O = setTimeout(() => { D() }, T))) } let B = null, L = null; function N(Q) { if (l.hasClass("navbar-hidden") || l.parent(".navbars").hasClass("navbar-hidden")) return; const Y = l.hasClass("navbar-large-transparent") || l.hasClass("navbar-large") && l.hasClass("navbar-transparent"); B = L; const X = Math.min(C, Q.f7ScrollableDistance || C); L = Math.min(Math.max(h / X, 0), 1); const K = B > 0 && B < 1; if (l.hasClass("with-searchbar-expandable-enabled")) return; w = l.hasClass("navbar-large-collapsed"); const G = l.find(".navbar-bg"); L === 0 && w ? r.navbar.expandLargeTitle(l[0]) : L === 1 && !w && r.navbar.collapseLargeTitle(l[0]), L === 0 && w || L === 0 && K || L === 1 && !w || L === 1 && K ? (r.theme === "md" && l.find(".navbar-inner").css("overflow", ""), l.find(".title").css("opacity", ""), l.find(".title-large-text, .subnavbar").css("transform", ""), l.find(".title-large-text").css("opacity", ""), Y && G.css("opacity", ""), G.css("transform", "")) : L > 0 && L < 1 && (r.theme === "md" && l.find(".navbar-inner").css("overflow", "visible"), l.find(".title").css("opacity", -.5 + L * 1.5), l.find(".title-large-text, .subnavbar").css("transform", `translate3d(0px, ${-1 * L * C}px, 0)`), l.find(".title-large-text").css("opacity", 1 - L * 2), Y && G.css("opacity", L), G.css("transform", `translate3d(0px, ${-1 * L * C}px, 0)`)), p && (i.touch ? S && (clearTimeout(S), S = null, S = setTimeout(() => { H(), clearTimeout(S), S = null }, P)) : (clearTimeout(O), O = setTimeout(() => { H() }, T))) } function F() { o.hasClass("page-with-card-opened") || (b = A.scrollHeight, g = A.offsetHeight, v = h + g >= b, $ = l.hasClass("navbar-hidden") || l.parent(".navbars").hasClass("navbar-hidden"), v ? r.params.navbar.showOnPageScrollEnd && (E = "show") : f > h ? r.params.navbar.showOnPageScrollTop || h <= u ? E = "show" : E = "hide" : h > u ? E = "hide" : E = "show", E === "show" && $ ? (r.navbar.show(l, !0, !0), $ = !1) : E === "hide" && !$ && (r.navbar.hide(l, !0, !1, !0), $ = !0), f = h) } function V(Q) { A = this, !(Q && Q.target && Q.target !== A) && (h = A.scrollTop, M = h, a ? N(A) : s && z(), !o.hasClass("page-previous") && t && F()) } function _() { M = !1 } function J() { clearTimeout(S), S = null, S = setTimeout(() => { M !== !1 && (s && !a ? D() : H(), clearTimeout(S), S = null) }, P) } o.on("scroll", ".page-content", V, !0), i.touch && (a && p || s && m) && (r.on("touchstart:passive", _), r.on("touchend:passive", J)), I(), (a || s) && o.find(".page-content").each(Q => { Q.scrollTop > 0 && V.call(Q) }), r.on("resize", I), o[0].f7DetachNavbarScrollHandlers = function () { r.off("resize", I), delete o[0].f7DetachNavbarScrollHandlers, o.off("scroll", ".page-content", V, !0), i.touch && (a && p || s && m) && (r.off("touchstart:passive", _), r.off("touchend:passive", J)) } } }, Ps = { name: "navbar", create() { Se(this, { navbar: gl }) }, params: { navbar: { scrollTopOnTitleClick: !0, iosCenterTitle: !0, mdCenterTitle: !1, hideOnPageScroll: !1, showOnPageScrollEnd: !0, showOnPageScrollTop: !0, collapseLargeTitleOnScroll: !0, snapPageScrollToLargeTitle: !0, snapPageScrollToTransparentNavbar: !0 } }, on: { "panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint": function () { const e = this; y(".navbar").each(t => { e.navbar.size(t) }) }, pageBeforeRemove(n) { n.$el[0].f7DetachNavbarScrollHandlers && n.$el[0].f7DetachNavbarScrollHandlers() }, pageBeforeIn(n) { const e = this; if (e.theme !== "ios") return; let t; const a = n.$el.parents(".view")[0].f7View, s = e.navbar.getElByPage(n); if (s ? t = y(s).parents(".navbars") : t = n.$el.parents(".view").children(".navbars"), n.$el.hasClass("no-navbar") || a.router.dynamicNavbar && !s) { const r = !!(n.pageFrom && n.router.history.length > 0); e.navbar.hide(t, r) } else e.navbar.show(t) }, pageReinit(n) { const e = this, t = y(e.navbar.getElByPage(n)); !t || t.length === 0 || e.navbar.size(t) }, pageInit(n) { const e = this, t = y(e.navbar.getElByPage(n)); if (!t || t.length === 0) return; e.navbar.size(t); let a; t.find(".title-large").length > 0 && t.addClass("navbar-large"), t.hasClass("navbar-large") && (e.params.navbar.collapseLargeTitleOnScroll && (a = !0), n.$el.addClass("page-with-navbar-large")); let s; !a && t.hasClass("navbar-transparent") && (s = !0); let r; (e.params.navbar.hideOnPageScroll || n.$el.find(".hide-navbar-on-scroll").length || n.$el.hasClass("hide-navbar-on-scroll") || n.$el.find(".hide-bars-on-scroll").length || n.$el.hasClass("hide-bars-on-scroll")) && (n.$el.find(".keep-navbar-on-scroll").length || n.$el.hasClass("keep-navbar-on-scroll") || n.$el.find(".keep-bars-on-scroll").length || n.$el.hasClass("keep-bars-on-scroll") ? r = !1 : r = !0), (a || r || s) && e.navbar.initNavbarOnScroll(n.el, t[0], r, a, s) }, "panelOpen panelSwipeOpen modalOpen": function (e) { const t = this; e.$el.find(".navbar:not(.navbar-previous)").each(a => { t.navbar.size(a) }) }, tabShow(n) { const e = this; y(n).find(".navbar:not(.navbar-previous)").each(t => { e.navbar.size(t) }) } }, clicks: { ".navbar .title": function (e, t, a) { if (!this.params.navbar.scrollTopOnTitleClick || y(a.target).closest("a, button").length > 0) return; let r; const i = e.parents(".navbar"), o = i.parents(".navbars"); r = i.parents(".page-content"), r.length === 0 && (i.parents(".page").length > 0 && (r = i.parents(".page").find(".page-content")), r.length === 0 && o.length && o.nextAll(".page-current").length > 0 && (r = o.nextAll(".page-current").find(".page-content")), r.length === 0 && i.nextAll(".page-current").length > 0 && (r = i.nextAll(".page-current").find(".page-content"))), r && r.length > 0 && (r.hasClass("tab") && (r = r.parent(".tabs").children(".page-content.tab-active")), r.length > 0 && r.scrollTop(0, 300)) } }, vnode: { navbar: { postpatch(n) { this.navbar.size(n.elm) } } } }, vl = { setHighlight(n) { const e = this, t = y(n); if (e.theme === "ios" && !t.hasClass("tabbar-highlight") || t.length === 0 || !(t.hasClass("tabbar") || t.hasClass("tabbar-icons"))) return; let a = t.find(".tab-link-highlight"); const s = t.find(".tab-link").length; if (s === 0) { a.remove(); return } a.length === 0 ? (t.children(".toolbar-inner").append('<span class="tab-link-highlight"></span>'), a = t.find(".tab-link-highlight")) : a.next().length && t.children(".toolbar-inner").append(a); const r = t.find(".tab-link-active"); let i, o; if (t.hasClass("tabbar-scrollable") && r && r[0]) i = `${r[0].offsetWidth}px`, o = `${r[0].offsetLeft}px`; else { const l = r.index(); i = `${100 / s}%`, o = `${(e.rtl ? -l : l) * 100}%` } Ae(() => { a.css("width", i).transform(`translate3d(${o},0,0)`) }) }, init(n) { this.toolbar.setHighlight(n) }, hide(n, e) { e === void 0 && (e = !0); const t = this, a = y(n); if (a.hasClass("toolbar-hidden")) return; const s = `toolbar-hidden${e ? " toolbar-transitioning" : ""}`; a.transitionEnd(() => { a.removeClass("toolbar-transitioning") }), a.addClass(s), a.trigger("toolbar:hide"), t.emit("toolbarHide", a[0]) }, show(n, e) { e === void 0 && (e = !0); const t = this, a = y(n); a.hasClass("toolbar-hidden") && (e && (a.addClass("toolbar-transitioning"), a.transitionEnd(() => { a.removeClass("toolbar-transitioning") })), a.removeClass("toolbar-hidden"), a.trigger("toolbar:show"), t.emit("toolbarShow", a[0])) }, initToolbarOnScroll(n) { const e = this, t = y(n); let a = t.parents(".view").children(".toolbar"); if (a.length === 0 && (a = t.find(".toolbar")), a.length === 0 && (a = t.parents(".views").children(".tabbar, .tabbar-icons")), a.length === 0) return; let s, r, i, o, l, c, d; function u(p) { if (t.hasClass("page-with-card-opened") || t.hasClass("page-previous")) return; const m = this; p && p.target && p.target !== m || (r = m.scrollTop, i = m.scrollHeight, o = m.offsetHeight, l = r + o >= i, d = a.hasClass("toolbar-hidden"), l ? e.params.toolbar.showOnPageScrollEnd && (c = "show") : s > r ? e.params.toolbar.showOnPageScrollTop || r <= 44 ? c = "show" : c = "hide" : r > 44 ? c = "hide" : c = "show", c === "show" && d ? (e.toolbar.show(a), d = !1) : c === "hide" && !d && (e.toolbar.hide(a), d = !0), s = r) } t.on("scroll", ".page-content", u, !0), t[0].f7ScrollToolbarHandler = u } }, As = { name: "toolbar", create() { Se(this, { toolbar: vl }) }, params: { toolbar: { hideOnPageScroll: !1, showOnPageScrollEnd: !0, showOnPageScrollTop: !0 } }, on: { pageBeforeRemove(n) { n.$el[0].f7ScrollToolbarHandler && n.$el.off("scroll", ".page-content", n.$el[0].f7ScrollToolbarHandler, !0) }, pageBeforeIn(n) { const e = this; let t = n.$el.parents(".view").children(".toolbar"); t.length === 0 && (t = n.$el.parents(".views").children(".tabbar, .tabbar-icons")), t.length === 0 && (t = n.$el.find(".toolbar")), t.length !== 0 && (n.$el.hasClass("no-toolbar") ? e.toolbar.hide(t) : e.toolbar.show(t)) }, pageInit(n) { const e = this; if (n.$el.find(".tabbar, .tabbar-icons").each(t => { e.toolbar.init(t) }), e.params.toolbar.hideOnPageScroll || n.$el.find(".hide-toolbar-on-scroll").length || n.$el.hasClass("hide-toolbar-on-scroll") || n.$el.find(".hide-bars-on-scroll").length || n.$el.hasClass("hide-bars-on-scroll")) { if (n.$el.find(".keep-toolbar-on-scroll").length || n.$el.hasClass("keep-toolbar-on-scroll") || n.$el.find(".keep-bars-on-scroll").length || n.$el.hasClass("keep-bars-on-scroll")) return; e.toolbar.initToolbarOnScroll(n.el) } }, init() { const n = this; n.$el.find(".tabbar, .tabbar-icons").each(e => { n.toolbar.init(e) }) } }, vnode: { tabbar: { insert(n) { this.toolbar.init(n.elm) } } } }, Is = { name: "subnavbar", on: { pageInit(n) { n.$navbarEl && n.$navbarEl.length && n.$navbarEl.find(".subnavbar").length && n.$el.addClass("page-with-subnavbar"), n.$el.find(".subnavbar").filter(t => y(t).parents(".page")[0] === n.$el[0]).length && n.$el.addClass("page-with-subnavbar") } } }; let En = class { constructor(e, t, a, s) { const r = this; if (!t) return; const { left: i, top: o, width: l, height: c } = t[0].getBoundingClientRect(), d = { x: a - i, y: s - o }; let u = Math.max((c ** 2 + l ** 2) ** .5, 48), p = !1; const m = e.params.touch.touchRippleInsetElements || ""; if (m && t.is(m) && (p = !0), p && (u = Math.max(Math.min(l, c), 48)), !p && t.css("overflow") === "hidden") { const f = ((d.x - l / 2) ** 2 + (d.y - c / 2) ** 2) ** .5, h = (u / 2 + f) / (u / 2); r.rippleTransform = `translate3d(0px, 0px, 0) scale(${h * 2})` } else r.rippleTransform = `translate3d(${-d.x + l / 2}px, ${-d.y + c / 2}px, 0) scale(1)`; return p && t.addClass("ripple-inset"), r.$rippleWaveEl = y(`<div class="ripple-wave${p ? " ripple-wave-inset" : ""}" style="width: ${u}px; height: ${u}px; margin-top:-${u / 2}px; margin-left:-${u / 2}px; left:${d.x}px; top:${d.y}px; --f7-ripple-transform: ${r.rippleTransform}"></div>`), t.prepend(r.$rippleWaveEl), r.$rippleWaveEl.animationEnd(() => { r.$rippleWaveEl && (r.$rippleWaveEl.hasClass("ripple-wave-out") || (r.$rippleWaveEl.addClass("ripple-wave-in"), r.shouldBeRemoved && r.out())) }), r } destroy() { let e = this; e.$rippleWaveEl && e.$rippleWaveEl.remove(), Object.keys(e).forEach(t => { e[t] = null, delete e[t] }), e = null } out() { const e = this, { $rippleWaveEl: t } = this; clearTimeout(e.removeTimeout), t.addClass("ripple-wave-out"), e.removeTimeout = setTimeout(() => { e.destroy() }, 300), t.animationEnd(() => { clearTimeout(e.removeTimeout), e.destroy() }) } remove() { const e = this; e.shouldBeRemoved || (e.removeTimeout = setTimeout(() => { e.destroy() }, 400), e.shouldBeRemoved = !0, e.$rippleWaveEl.hasClass("ripple-wave-in") && e.out()) } }; const Os = { name: "touch-ripple", static: { TouchRipple: En }, create() { const n = this; n.touchRipple = { create() { for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; return new En(...t) } } } }, St = [], gt = []; function bl() { if (gt.length === 0) return; gt.shift().open() } let Ye = class extends me { constructor(e, t) { super(t, [e]); const a = this, s = {}; a.useModulesParams(s), a.params = R(s, t), a.opened = !1; let r = a.params.containerEl ? y(a.params.containerEl).eq(0) : e.$el; return r.length || (r = e.$el), a.$containerEl = r, a.containerEl = r[0], a.useModules(), this } onOpen() { const e = this; e.opened = !0, St.push(e), y("html").addClass(`with-modal-${e.type.toLowerCase()}`), e.$el.trigger(`modal:open ${e.type.toLowerCase()}:open`), e.emit(`local::open modalOpen ${e.type}Open`, e) } onOpened() { const e = this; e.$el.trigger(`modal:opened ${e.type.toLowerCase()}:opened`), e.emit(`local::opened modalOpened ${e.type}Opened`, e) } onClose() { const e = this; e.opened = !1, !(!e.type || !e.$el) && (St.splice(St.indexOf(e), 1), y("html").removeClass(`with-modal-${e.type.toLowerCase()}`), e.$el.trigger(`modal:close ${e.type.toLowerCase()}:close`), e.emit(`local::close modalClose ${e.type}Close`, e)) } onClosed() { const e = this; !e.type || !e.$el || (e.$el.removeClass("modal-out"), e.$el.hide(), e.params.backdrop && (e.params.backdropUnique || e.forceBackdropUnique) && e.$backdropEl && e.$backdropEl.remove(), e.$el.trigger(`modal:closed ${e.type.toLowerCase()}:closed`), e.emit(`local::closed modalClosed ${e.type}Closed`, e)) } open(e, t) { const a = this, s = ee(), r = a.app, i = a.$el, o = a.$backdropEl, l = a.type; let c = !0; if (typeof e < "u" ? c = e : typeof a.params.animate < "u" && (c = a.params.animate), (!i || i.hasClass("modal-in")) && (e === !1 && i[0] && l !== "dialog" && (i[0].style.display = "block"), !t)) return a; if (l === "dialog" && r.params.modal.queueDialogs) { let m; if (y(".dialog.modal-in").length > 0 ? m = !0 : St.length > 0 && St.forEach(f => { f.type === "dialog" && (m = !0) }), m) return gt.push(a), a } const d = i.parent(), u = i.parents(s).length > 0; d.is(a.$containerEl) || (a.$containerEl.append(i), a.once(`${l}Closed`, () => { u ? d.append(i) : i.remove() })), i.show(), a.params.backdrop && (a.params.backdropUnique || a.forceBackdropUnique) && a.$backdropEl && a.$backdropEl.insertBefore(i), a._clientLeft = i[0].clientLeft; function p() { i.hasClass("modal-out") ? a.onClosed() : i.hasClass("modal-in") && a.onOpened() } return c ? (o && (o.removeClass("not-animated"), o.addClass("backdrop-in")), i.animationEnd(() => { p() }), i.transitionEnd(() => { p() }), i.removeClass("modal-out not-animated").addClass("modal-in"), a.onOpen()) : (o && o.addClass("backdrop-in not-animated"), i.removeClass("modal-out").addClass("modal-in not-animated"), a.onOpen(), a.onOpened()), a } close(e) { const t = this, a = t.$el, s = t.$backdropEl; let r = !0; if (typeof e < "u" ? r = e : typeof t.params.animate < "u" && (r = t.params.animate), !a || !a.hasClass("modal-in")) return gt.indexOf(t) >= 0 && gt.splice(gt.indexOf(t), 1), t; if (s) { let o = !0; t.type === "popup" && t.$el.prevAll(".popup.modal-in").add(t.$el.nextAll(".popup.modal-in")).each(l => { const c = l.f7Modal; c && c.params.closeByBackdropClick && c.params.backdrop && c.backdropEl === t.backdropEl && (o = !1) }), o && (s[r ? "removeClass" : "addClass"]("not-animated"), s.removeClass("backdrop-in")) } a[r ? "removeClass" : "addClass"]("not-animated"); function i() { a.hasClass("modal-out") ? t.onClosed() : a.hasClass("modal-in") && t.onOpened() } return r ? (a.animationEnd(() => { i() }), a.transitionEnd(() => { i() }), a.removeClass("modal-in").addClass("modal-out"), t.onClose()) : (a.addClass("not-animated").removeClass("modal-in").addClass("modal-out"), t.onClose(), t.onClosed()), t.type === "dialog" && bl(), t } destroy() { const e = this; e.destroyed || (e.emit(`local::beforeDestroy modalBeforeDestroy ${e.type}BeforeDestroy`, e), e.$el && (e.$el.trigger(`modal:beforedestroy ${e.type.toLowerCase()}:beforedestroy`), e.$el.length && e.$el[0].f7Modal && delete e.$el[0].f7Modal), ve(e), e.destroyed = !0) } }; class wn extends Ye { constructor(e, t) { const a = R({ backdrop: !0, closeByBackdropClick: !0, on: {} }, t); super(e, a); const s = this; s.params = a; let r; if (s.params.el ? r = y(s.params.el) : r = y(s.params.content), r && r.length > 0 && r[0].f7Modal) return r[0].f7Modal; if (r.length === 0) return s.destroy(); let i; s.params.backdrop && (i = e.$el.children(".custom-modal-backdrop"), i.length === 0 && (i = y('<div class="custom-modal-backdrop"></div>'), e.$el.append(i))); function o(l) { !s || s.destroyed || i && l.target === i[0] && s.close() } return s.on("customModalOpened", () => { s.params.closeByBackdropClick && s.params.backdrop && e.on("click", o) }), s.on("customModalClose", () => { s.params.closeByBackdropClick && s.params.backdrop && e.off("click", o) }), R(s, { app: e, $el: r, el: r[0], $backdropEl: i, backdropEl: i && i[0], type: "customModal" }), r[0].f7Modal = s, s } } const Bs = { name: "modal", static: { Modal: Ye, CustomModal: wn }, create() { const n = this; n.customModal = { create(e) { return new wn(n, e) } } }, params: { modal: { queueDialogs: !0 } } }; let We = class extends Ye { constructor(e, t) { const a = R({ title: e.params.dialog.title, text: void 0, content: "", buttons: [], verticalButtons: !1, onClick: void 0, cssClass: void 0, destroyOnClose: !1, on: {} }, t); typeof a.closeByBackdropClick > "u" && (a.closeByBackdropClick = e.params.dialog.closeByBackdropClick), typeof a.backdrop > "u" && (a.backdrop = e.params.dialog.backdrop), super(e, a); const s = this, r = ue(), i = ee(), { title: o, text: l, content: c, buttons: d, verticalButtons: u, cssClass: p, backdrop: m } = a; s.params = a; let f; if (s.params.el) f = y(s.params.el); else { const $ = ["dialog"]; d.length === 0 && $.push("dialog-no-buttons"), d.length > 0 && $.push(`dialog-buttons-${d.length}`), u && $.push("dialog-buttons-vertical"), p && $.push(p); let w = ""; d.length > 0 && (w = x("div", { class: "dialog-buttons" }, d.map(k => x("span", { class: `dialog-button${k.strong ? " dialog-button-strong" : ""}${k.color ? ` color-${k.color}` : ""}${k.cssClass ? ` ${k.cssClass}` : ""}` }, k.text)))); const C = x("div", { class: $.join(" ") }, x("div", { class: "dialog-inner" }, o && x("div", { class: "dialog-title" }, o), l && x("div", { class: "dialog-text" }, l), c), w); f = y(C) } if (f && f.length > 0 && f[0].f7Modal) return f[0].f7Modal; if (f.length === 0) return s.destroy(); let h; m && (h = e.$el.children(".dialog-backdrop"), h.length === 0 && (h = y('<div class="dialog-backdrop"></div>'), e.$el.append(h))); function b($) { const C = y(this).index(), k = d[C]; k.onClick && k.onClick(s, $), s.params.onClick && s.params.onClick(s, C), k.close !== !1 && s.close() } let g; function v($) { const w = $.keyCode; d.forEach((C, k) => { C.keyCodes && C.keyCodes.indexOf(w) >= 0 && (i.activeElement && i.activeElement.blur(), C.onClick && C.onClick(s, $), s.params.onClick && s.params.onClick(s, k), C.close !== !1 && s.close()) }) } d && d.length > 0 && (s.on("open", () => { f.find(".dialog-button").each(($, w) => { d[w].keyCodes && (g = !0), y($).on("click", b) }), g && !r.ios && !r.android && !r.cordova && !r.capacitor && y(i).on("keydown", v) }), s.on("close", () => { f.find(".dialog-button").each($ => { y($).off("click", b) }), g && !r.ios && !r.android && !r.cordova && !r.capacitor && y(i).off("keydown", v), g = !1 })), R(s, { app: e, $el: f, el: f[0], $backdropEl: h, backdropEl: h && h[0], type: "dialog", setProgress($, w) { return e.progressbar.set(f.find(".progressbar"), $, w), s }, setText($) { let w = f.find(".dialog-text"); return w.length === 0 && (w = y('<div class="dialog-text"></div>'), typeof o < "u" ? w.insertAfter(f.find(".dialog-title")) : f.find(".dialog-inner").prepend(w)), w.html($), s.params.text = $, s }, setTitle($) { let w = f.find(".dialog-title"); return w.length === 0 && (w = y('<div class="dialog-title"></div>'), f.find(".dialog-inner").prepend(w)), w.html($), s.params.title = $, s } }); function E($) { const w = $.target; y(w).closest(s.el).length === 0 && s.params.closeByBackdropClick && s.backdropEl && s.backdropEl === w && s.close() } return s.on("opened", () => { s.params.closeByBackdropClick && e.on("click", E) }), s.on("close", () => { s.params.closeByBackdropClick && e.off("click", E) }), f[0].f7Modal = s, s.params.destroyOnClose && s.once("closed", () => { setTimeout(() => { s.destroy() }, 0) }), s } }; const yl = {
  name: "dialog", params: { dialog: { title: void 0, buttonOk: "OK", buttonCancel: "Cancel", usernamePlaceholder: "Username", passwordPlaceholder: "Password", preloaderTitle: "Loading... ", progressTitle: "Loading... ", backdrop: !0, closeByBackdropClick: !1, destroyPredefinedDialogs: !0, keyboardActions: !0, autoFocus: !0 } }, static: { Dialog: We }, create() {
    const n = this; function e() { return n.params.dialog.title || n.name } const t = n.params.dialog.destroyPredefinedDialogs, a = n.params.dialog.keyboardActions, r = n.params.dialog.autoFocus ? { on: { opened(o) { o.$el.find("input").eq(0).focus() } } } : {}, i = n.theme === "ios"; n.dialog = R(Ze({ app: n, constructor: We, defaultSelector: ".dialog.modal-in" }), {
      alert() { for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; let [d, u, p] = l; return l.length === 2 && typeof l[1] == "function" && ([d, p, u] = l), new We(n, { title: typeof u > "u" ? e() : u, text: d, buttons: [{ text: n.params.dialog.buttonOk, strong: i, onClick: p, keyCodes: a ? [13, 27] : null }], destroyOnClose: t }).open() }, prompt() { for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; let [d, u, p, m, f] = l; return typeof l[1] == "function" && ([d, p, m, f, u] = l), f = typeof f > "u" || f === null ? "" : f, new We(n, { title: typeof u > "u" ? e() : u, text: d, content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${f}"></div>`, buttons: [{ text: n.params.dialog.buttonCancel, keyCodes: a ? [27] : null, color: null }, { text: n.params.dialog.buttonOk, strong: i, keyCodes: a ? [13] : null }], onClick(h, b) { const g = h.$el.find(".dialog-input").val(); b === 0 && m && m(g), b === 1 && p && p(g) }, destroyOnClose: t, ...r }).open() }, confirm() { for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; let [d, u, p, m] = l; return typeof l[1] == "function" && ([d, p, m, u] = l), new We(n, { title: typeof u > "u" ? e() : u, text: d, buttons: [{ text: n.params.dialog.buttonCancel, onClick: m, keyCodes: a ? [27] : null, color: null }, { text: n.params.dialog.buttonOk, strong: i, onClick: p, keyCodes: a ? [13] : null }], destroyOnClose: t }).open() }, login() {
        for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; let [d, u, p, m] = l; return typeof l[1] == "function" && ([d, p, m, u] = l), new We(n, {
          title: typeof u > "u" ? e() : u, text: d, content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${n.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${n.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`, buttons: [{ text: n.params.dialog.buttonCancel, keyCodes: a ? [27] : null, color: null }, { text: n.params.dialog.buttonOk, strong: i, keyCodes: a ? [13] : null }], onClick(f, h) { const b = f.$el.find('[name="dialog-username"]').val(), g = f.$el.find('[name="dialog-password"]').val(); h === 0 && m && m(b, g), h === 1 && p && p(b, g) }, destroyOnClose: t, ...r
        }).open()
      }, password() {
        for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; let [d, u, p, m] = l; return typeof l[1] == "function" && ([d, p, m, u] = l), new We(n, {
          title: typeof u > "u" ? e() : u, text: d, content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${n.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`, buttons: [{ text: n.params.dialog.buttonCancel, keyCodes: a ? [27] : null, color: null }, { text: n.params.dialog.buttonOk, strong: i, keyCodes: a ? [13] : null }], onClick(f, h) { const b = f.$el.find('[name="dialog-password"]').val(); h === 0 && m && m(b), h === 1 && p && p(b) }, destroyOnClose: t, ...r
        }).open()
      }, preloader(o, l) { const d = { iosPreloaderContent: ct, mdPreloaderContent: lt }[`${n.theme}PreloaderContent`] || ""; return new We(n, { title: typeof o > "u" || o === null ? n.params.dialog.preloaderTitle : o, content: `<div class="preloader${l ? ` color-${l}` : ""}">${d}</div>`, cssClass: "dialog-preloader", destroyOnClose: t }).open() }, progress() {
        for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)l[c] = arguments[c]; let [d, u, p] = l; l.length === 2 ? typeof l[0] == "number" ? [u, p, d] = l : typeof l[0] == "string" && typeof l[1] == "string" && ([d, p, u] = l) : l.length === 1 && typeof l[0] == "number" && ([u, d, p] = l); const m = typeof u > "u", f = new We(n, {
          title: typeof d > "u" ? n.params.dialog.progressTitle : d, cssClass: "dialog-progress", content: `
              <div class="progressbar${m ? "-infinite" : ""}${p ? ` color-${p}` : ""}">
                ${m ? "" : "<span></span>"}
              </div>
            `, destroyOnClose: t
        }); return m || f.setProgress(u), f.open()
      }
    })
  }
}; let Cn = class extends Ye { constructor(e, t) { const a = R({ on: {} }, e.params.popup, t); super(e, a); const s = this, r = U(), i = ee(), o = Ee(), l = ue(); s.params = a; let c; if (s.params.el ? c = y(s.params.el).eq(0) : c = y(s.params.content).filter(F => F.nodeType === 1).eq(0), c && c.length > 0 && c[0].f7Modal) return c[0].f7Modal; if (c.length === 0) return s.destroy(); let d; s.params.backdrop && s.params.backdropEl ? d = y(s.params.backdropEl) : s.params.backdrop && (s.params.backdropUnique ? (d = y('<div class="popup-backdrop popup-backdrop-unique"></div>'), s.$containerEl.append(d)) : d = s.$containerEl.children(".popup-backdrop"), d.length === 0 && (d = y('<div class="popup-backdrop"></div>'), s.$containerEl.append(d))), R(s, { app: e, push: c.hasClass("popup-push") || s.params.push, $el: c, el: c[0], $backdropEl: d, backdropEl: d && d[0], type: "popup", $htmlEl: y("html") }), s.params.push && c.addClass("popup-push"); function u(F) { const V = F.target, _ = y(V); if (!(!l.desktop && l.cordova && (r.Keyboard && r.Keyboard.isVisible || r.cordova.plugins && r.cordova.plugins.Keyboard && r.cordova.plugins.Keyboard.isVisible)) && _.closest(s.el).length === 0 && s.params && s.params.closeByBackdropClick && s.params.backdrop && s.backdropEl && s.backdropEl === V) { let Q = !0; s.$el.nextAll(".popup.modal-in").each(j => { const Y = j.f7Modal; Y && Y.params.closeByBackdropClick && Y.params.backdrop && Y.backdropEl === s.backdropEl && (Q = !1) }), Q && s.close() } } function p(F) { F.keyCode === 27 && s.params.closeOnEscape && s.close() } let m, f; function h(F) { return (e.height - F * 2) / e.height } let b = !0, g = !1, v, E, $, w, C, k = !1, M, A, O, S, P, T; function I(F) { g || !b || !s.params.swipeToClose || !F.isTrusted || s.params.swipeHandler && y(F.target).closest(s.params.swipeHandler).length === 0 || (g = !0, k = !1, v = { x: F.type === "touchstart" ? F.targetTouches[0].pageX : F.pageX, y: F.type === "touchstart" ? F.targetTouches[0].pageY : F.pageY }, w = Ie(), $ = void 0, !s.params.swipeHandler && F.type === "touchstart" && (M = y(F.target).closest(".page-content")[0])) } function H(F) { if (!g || !F.isTrusted) return; if (E = { x: F.type === "touchmove" ? F.targetTouches[0].pageX : F.pageX, y: F.type === "touchmove" ? F.targetTouches[0].pageY : F.pageY }, typeof $ > "u" && ($ = !!($ || Math.abs(E.x - v.x) > Math.abs(E.y - v.y))), $) { g = !1, k = !1; return } C = v.y - E.y, f && m && C > 0 && (C = 0); const V = C < 0 ? "to-bottom" : "to-top"; if (c.transition(0), typeof s.params.swipeToClose == "string" && V !== s.params.swipeToClose) { c.transform(""), c.transition(""); return } if (k) s.emit("local::swipeMove popupSwipeMove", s), s.$el.trigger("popup:swipemove"); else { if (f && m && (P = c[0].offsetHeight, T = c.prevAll(".popup.modal-in").eq(0), T.length === 0 && (T = e.$el.children(".view, .views"))), M && (A = M.scrollTop, S = M.scrollHeight, O = M.offsetHeight, S !== O && !(V === "to-bottom" && A === 0) && !(V === "to-top" && A === S - O))) { c.transform(""), c.transition(""), g = !1, k = !1; return } k = !0, s.emit("local::swipeStart popupSwipeStart", s), s.$el.trigger("popup:swipestart") } if (F.preventDefault(), f && m) { const _ = 1 - Math.abs(C / P), J = 1 - (1 - h(m)) * _; T.hasClass("popup") ? T.hasClass("popup-push") ? T.transition(0).forEach(Q => { Q.style.setProperty("transform", `translate3d(0, calc(-1 * ${_} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${J})`, "important") }) : T.transition(0).forEach(Q => { Q.style.setProperty("transform", `translate3d(0, 0px , 0px) scale(${J})`, "important") }) : T.transition(0).forEach(Q => { Q.style.setProperty("transform", `translate3d(0,0,0) scale(${J})`, "important") }) } c.transition(0).transform(`translate3d(0,${-C}px,0)`) } function D(F) { if (!F.isTrusted || (g = !1, !k)) return; s.emit("local::swipeEnd popupSwipeEnd", s), s.$el.trigger("popup:swipeend"), k = !1, b = !1, c.transition(""), f && m && T.transition("").transform(""); const V = C <= 0 ? "to-bottom" : "to-top"; if (typeof s.params.swipeToClose == "string" && V !== s.params.swipeToClose) { c.transform(""), b = !0; return } const _ = Math.abs(C), J = new Date().getTime() - w; if (J < 300 && _ > 20 || J >= 300 && _ > 100) { $e(() => { V === "to-bottom" ? c.addClass("swipe-close-to-bottom") : c.addClass("swipe-close-to-top"), c.transform(""), s.emit("local::swipeclose popupSwipeClose", s), s.$el.trigger("popup:swipeclose"), s.close(), b = !0 }); return } b = !0, c.transform("") } const z = o.passiveListener ? { passive: !0 } : !1; s.params.swipeToClose && (c.on(e.touchEvents.start, I, z), e.on("touchmove", H), e.on("touchend:passive", D), s.once("popupDestroy", () => { c.off(e.touchEvents.start, I, z), e.off("touchmove", H), e.off("touchend:passive", D) })); let B; const L = () => { const F = f; s.push && (f = s.push && (e.width < 630 || e.height < 630 || c.hasClass("popup-tablet-fullscreen"))), f && !F ? N() : f && F ? s.$htmlEl[0].style.setProperty("--f7-popup-push-scale", h(m)) : !f && F && (s.$htmlEl.removeClass("with-modal-popup-push"), s.$htmlEl[0].style.removeProperty("--f7-popup-push-scale")) }, N = () => { e.off("resize", L), s.push && (f = s.push && (e.width < 630 || e.height < 630 || c.hasClass("popup-tablet-fullscreen"))), f && (m = parseInt(c.css("--f7-popup-push-offset"), 10), Number.isNaN(m) && (m = 0), m || (m = e.theme === "ios" ? 44 : 48), s.$htmlEl[0].style.setProperty("--f7-popup-push-offset", `${m}px`), c.addClass("popup-push"), s.$htmlEl.addClass("with-modal-popup-push"), s.$htmlEl[0].style.setProperty("--f7-popup-push-scale", h(m))), e.on("resize", L) }; return s.on("open", () => { B = !1, s.params.closeOnEscape && y(i).on("keydown", p), c.prevAll(".popup.modal-in").addClass("popup-behind"), N() }), s.on("opened", () => { c.removeClass("swipe-close-to-bottom swipe-close-to-top"), s.params.closeByBackdropClick && e.on("click", u) }), s.on("close", () => { B = s.$el.prevAll(".popup-push.modal-in").length > 0, s.params.closeOnEscape && y(i).off("keydown", p), s.params.closeByBackdropClick && e.off("click", u), c.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind"), f && m && !B && (s.$htmlEl.removeClass("with-modal-popup-push"), s.$htmlEl.addClass("with-modal-popup-push-closing")), e.off("resize", L) }), s.on("closed", () => { c.removeClass("popup-behind"), f && m && !B && (s.$htmlEl.removeClass("with-modal-popup-push-closing"), s.$htmlEl[0].style.removeProperty("--f7-popup-push-scale"), s.$htmlEl[0].style.removeProperty("--f7-popup-push-offset")) }), c[0].f7Modal = s, s } }; const El = { name: "popup", params: { popup: { backdrop: !0, backdropEl: void 0, backdropUnique: !1, closeByBackdropClick: !0, closeOnEscape: !1, swipeToClose: !1, swipeHandler: null, push: !1, containerEl: null } }, static: { Popup: Cn }, create() { const n = this; n.popup = Ze({ app: n, constructor: Cn, defaultSelector: ".popup.modal-in", parentSelector: ".popup" }) }, clicks: { ".popup-open": function (e, t) { t === void 0 && (t = {}), this.popup.open(t.popup, t.animate, e) }, ".popup-close": function (e, t) { t === void 0 && (t = {}), this.popup.close(t.popup, t.animate, e) } } }; let $n = class extends Ye { constructor(e, t) { const a = R({ on: {} }, t); super(e, a); const s = this; s.params = a; let r; return s.params.el ? r = y(s.params.el).eq(0) : r = y(s.params.content).filter(i => i.nodeType === 1).eq(0), r && r.length > 0 && r[0].f7Modal ? r[0].f7Modal : r.length === 0 ? s.destroy() : (R(s, { app: e, $el: r, el: r[0], type: "loginScreen" }), r[0].f7Modal = s, s) } }; const wl = { name: "loginScreen", static: { LoginScreen: $n }, create() { const n = this; n.loginScreen = Ze({ app: n, constructor: $n, defaultSelector: ".login-screen.modal-in" }) }, clicks: { ".login-screen-open": function (e, t) { t === void 0 && (t = {}), this.loginScreen.open(t.loginScreen, t.animate, e) }, ".login-screen-close": function (e, t) { t === void 0 && (t = {}), this.loginScreen.close(t.loginScreen, t.animate, e) } } }; let ga = class extends Ye { constructor(e, t) { const a = R({ on: {} }, e.params.popover, t); super(e, a); const s = this, r = ue(), i = U(), o = ee(); s.params = a; let l; if (s.params.el ? l = y(s.params.el).eq(0) : l = y(s.params.content).filter(E => E.nodeType === 1).eq(0), l && l.length > 0 && l[0].f7Modal) return l[0].f7Modal; const c = y(s.params.targetEl).eq(0); if (l.length === 0) return s.destroy(); let d; const u = s.params.backdrop && e.$el.find(".popover.modal-in").filter(E => E !== l[0]).length > 0; s.params.backdrop && s.params.backdropEl ? d = y(s.params.backdropEl) : s.params.backdrop && (s.params.backdropUnique || u ? (d = y('<div class="popover-backdrop popover-backdrop-unique"></div>'), d[0].f7PopoverRef = s, s.$containerEl.append(d)) : d = s.$containerEl.children(".popover-backdrop"), d.length === 0 && (d = y('<div class="popover-backdrop"></div>'), s.$containerEl.append(d))); let p; l.find(".popover-arrow").length === 0 && s.params.arrow ? (p = y('<div class="popover-arrow"></div>'), l.prepend(p)) : p = l.find(".popover-arrow"); const m = s.open; R(s, { app: e, $el: l, el: l[0], $targetEl: c, targetEl: c[0], $arrowEl: p, arrowEl: p[0], $backdropEl: d, backdropEl: d && d[0], type: "popover", forceBackdropUnique: u, open() { for (var E = arguments.length, $ = new Array(E), w = 0; w < E; w++)$[w] = arguments[w]; let [C, k] = $; return typeof $[0] == "boolean" && ([k, C] = $), C && (s.$targetEl = y(C), s.targetEl = s.$targetEl[0]), m.call(s, k) } }); function f() { s.resize() } s.on("popoverOpen", () => { s.resize(), e.on("resize", f), y(i).on("keyboardDidShow keyboardDidHide", f), s.on("popoverClose popoverBeforeDestroy", () => { e.off("resize", f), y(i).off("keyboardDidShow keyboardDidHide", f) }) }); let h = null; function b(E) { h = E.target } function g(E) { const $ = E.target, w = y($); if (!(!r.desktop && r.cordova && (i.Keyboard && i.Keyboard.isVisible || i.cordova.plugins && i.cordova.plugins.Keyboard && i.cordova.plugins.Keyboard.isVisible)) && w.closest(s.el).length === 0) { if (s.params.closeByBackdropClick && s.params.backdrop && s.backdropEl && s.backdropEl === $ && h === $) s.close(); else if (s.params.closeByOutsideClick && h === $) { const k = w.hasClass("popover-backdrop-unique") && $.f7PopoverRef !== s || w.hasClass("popover-backdrop") && $ !== s.backdropEl, M = $.closest(".popover") && $.closest(".popover") !== s.$el[0]; !k && !M && s.close() } } } function v(E) { E.keyCode === 27 && s.params.closeOnEscape && s.close() } return s.params.closeOnEscape && (s.on("popoverOpen", () => { y(o).on("keydown", v) }), s.on("popoverClose", () => { y(o).off("keydown", v) })), s.on("popoverOpened", () => { (s.params.closeByOutsideClick || s.params.closeByBackdropClick) && (e.on("touchstart", b), e.on("click", g)) }), s.on("popoverClose", () => { (s.params.closeByOutsideClick || s.params.closeByBackdropClick) && (e.off("touchstart", b), e.off("click", g)) }), l[0].f7Modal = s, s } resize() { const e = this, { app: t, $el: a, $targetEl: s, $arrowEl: r } = e, { targetX: i, targetY: o, verticalPosition: l } = e.params; a.css({ left: "", top: "" }); const [c, d] = [a.width(), a.height()]; let u = 0, p, m; const f = r.length > 0, h = t.theme === "ios" ? 13 : 24; f && (r.removeClass("on-left on-right on-top on-bottom").css({ left: "", top: "" }), u = r.width() / 2), a.removeClass("popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle").css({ left: "", top: "" }); let b, g, v, E, $ = parseInt(y("html").css("--f7-safe-area-top"), 10), w = parseInt(y("html").css("--f7-safe-area-left"), 10), C = parseInt(y("html").css("--f7-safe-area-right"), 10); if (Number.isNaN($) && ($ = 0), Number.isNaN(w) && (w = 0), Number.isNaN(C) && (C = 0), s && s.length > 0) { b = s.outerWidth(), g = s.outerHeight(); const T = s.offset(); v = T.left - t.left, E = T.top - t.top; const I = s.parents(".page"); I.length > 0 && (E -= I[0].scrollTop) } else typeof i < "u" && o !== "undefined" && (v = i, E = o, b = e.params.targetWidth || 0, g = e.params.targetHeight || 0); let [k, M, A] = [0, 0, 0]; const O = l === "auto" ? !1 : l; let S = O || "top"; O === "top" || !O && d + u < E - $ ? M = E - d - u : O === "bottom" || !O && d + u < t.height - E - g ? (S = "bottom", M = E + g + u) : (S = "middle", M = g / 2 + E - d / 2, A = M, M = Math.max(5, Math.min(M, t.height - d - 5)), A -= M), S === "top" || S === "bottom" ? (k = b / 2 + v - c / 2, A = k, k = Math.max(5, Math.min(k, t.width - c - 5)), w && (k = Math.max(k, w)), C && k + c > t.width - 5 - C && (k = t.width - 5 - C - c), A -= k, f && (S === "top" && r.addClass("on-bottom"), S === "bottom" && r.addClass("on-top"), p = c / 2 - u + A, p = Math.max(Math.min(p, c - u * 2 - h), h), r.css({ left: `${p}px` }))) : S === "middle" && (k = v - c - u, f && r.addClass("on-right"), (k < 5 || k + c + C > t.width || k < w) && (k < 5 && (k = v + b + u), k + c + C > t.width && (k = t.width - c - 5 - C), k < w && (k = w), f && r.removeClass("on-right").addClass("on-left")), f && (m = d / 2 - u + A, m = Math.max(Math.min(m, d - u * 2 - h), h), r.css({ top: `${m}px` }))); let P; v < t.width / 2 ? P = "right" : P = "left", a.addClass(`popover-on-${S} popover-on-${P}`), a.css({ top: `${M}px`, left: `${k}px` }) } }; const Cl = { name: "popover", params: { popover: { verticalPosition: "auto", arrow: !0, backdrop: !0, backdropEl: void 0, backdropUnique: !1, closeByBackdropClick: !0, closeByOutsideClick: !0, closeOnEscape: !1, containerEl: null } }, static: { Popover: ga }, create() { const n = this; n.popover = R(Ze({ app: n, constructor: ga, defaultSelector: ".popover.modal-in" }), { open(e, t, a) { let s = y(e); if (s.length > 1) { const o = y(t).parents(".page"); o.length && s.each(l => { const c = y(l); c.parents(o)[0] === o[0] && (s = c) }) } s.length > 1 && (s = s.eq(s.length - 1)); let r = s[0].f7Modal; const i = s.dataset(); return r || (r = new ga(n, Object.assign({ el: s, targetEl: t }, i))), r.open(t, a) } }) }, clicks: { ".popover-open": function (e, t) { t === void 0 && (t = {}), this.popover.open(t.popover, e, t.animate) }, ".popover-close": function (e, t) { t === void 0 && (t = {}), this.popover.close(t.popover, t.animate, e) } } }; let xn = class extends Ye { constructor(e, t) { const a = R({ on: {} }, e.params.actions, t); super(e, a); const s = this, r = ue(), i = U(), o = ee(); s.params = a; let l; s.params.buttons && (l = s.params.buttons, Array.isArray(l[0]) || (l = [l])), s.groups = l; let c; if (s.params.el ? c = y(s.params.el).eq(0) : s.params.content ? c = y(s.params.content).filter(g => g.nodeType === 1).eq(0) : s.params.buttons && (s.params.convertToPopover && (s.popoverHtml = s.renderPopover()), s.actionsHtml = s.render()), c && c.length > 0 && c[0].f7Modal) return c[0].f7Modal; if (c && c.length === 0 && !(s.actionsHtml || s.popoverHtml)) return s.destroy(); let d; s.params.backdrop && s.params.backdropEl ? d = y(s.params.backdropEl) : s.params.backdrop && (s.params.backdropUnique ? (d = y('<div class="popup-backdrop popup-backdrop-unique"></div>'), s.$containerEl.append(d)) : d = s.$containerEl.children(".actions-backdrop"), d.length === 0 && (d = y('<div class="actions-backdrop"></div>'), s.$containerEl.append(d))); const u = s.open, p = s.close; let m; function f(g) { const v = y(this); let E, $; if (v.hasClass("list-button") || v.hasClass("item-link") ? (E = v.parents("li").index(), $ = v.parents(".list").index()) : (E = v.index(), $ = v.parents(".actions-group").index()), typeof l < "u") { const w = l[$][E]; w.onClick && w.onClick(s, g), s.params.onClick && s.params.onClick(s, g), w.close !== !1 && s.close() } } s.open = function (v) { let E = !1; const { targetEl: $, targetX: w, targetY: C, targetWidth: k, targetHeight: M } = s.params; return s.params.convertToPopover && ($ || w !== void 0 && C !== void 0) && (s.params.forceToPopover || r.ios && r.ipad || e.width >= 768 || r.desktop) && (E = !0), E && s.popoverHtml ? (m = e.popover.create({ containerEl: s.params.containerEl, content: s.popoverHtml, backdrop: s.params.backdrop, targetEl: $, targetX: w, targetY: C, targetWidth: k, targetHeight: M, on: { open() { s.$el || (s.$el = m.$el), s.$el.trigger(`modal:open ${s.type.toLowerCase()}:open`), s.emit(`local::open modalOpen ${s.type}Open`, s) }, opened() { s.$el || (s.$el = m.$el), s.$el.trigger(`modal:opened ${s.type.toLowerCase()}:opened`), s.emit(`local::opened modalOpened ${s.type}Opened`, s) }, close() { s.$el || (s.$el = m.$el), s.$el.trigger(`modal:close ${s.type.toLowerCase()}:close`), s.emit(`local::close modalClose ${s.type}Close`, s) }, closed() { s.$el || (s.$el = m.$el), s.$el.trigger(`modal:closed ${s.type.toLowerCase()}:closed`), s.emit(`local::closed modalClosed ${s.type}Closed`, s) } } }), m.open(v), m.once("popoverOpened", () => { m.$el.find(".list-button, .item-link").each(A => { y(A).on("click", f) }) }), m.once("popoverClosed", () => { m.$el.find(".list-button, .item-link").each(A => { y(A).off("click", f) }), $e(() => { m.destroy(), m = void 0 }) })) : (s.$el = s.actionsHtml ? y(s.actionsHtml) : s.$el, s.$el[0].f7Modal = s, s.groups && (s.$el.find(".actions-button").each(A => { y(A).on("click", f) }), s.once("actionsClosed", () => { s.$el.find(".actions-button").each(A => { y(A).off("click", f) }) })), s.el = s.$el[0], u.call(s, v)), s }, s.close = function (v) { return m ? m.close(v) : p.call(s, v), s }, R(s, { app: e, $el: c, el: c ? c[0] : void 0, $backdropEl: d, backdropEl: d && d[0], type: "actions" }); function h(g) { const v = g.target, E = y(v); !r.desktop && r.cordova && (i.Keyboard && i.Keyboard.isVisible || i.cordova.plugins && i.cordova.plugins.Keyboard && i.cordova.plugins.Keyboard.isVisible) || E.closest(s.el).length === 0 && (s.params.closeByBackdropClick && s.params.backdrop && s.backdropEl && s.backdropEl === v || s.params.closeByOutsideClick) && s.close() } function b(g) { g.keyCode === 27 && s.params.closeOnEscape && s.close() } return s.params.closeOnEscape && (s.on("open", () => { y(o).on("keydown", b) }), s.on("close", () => { y(o).off("keydown", b) })), s.on("opened", () => { (s.params.closeByBackdropClick || s.params.closeByOutsideClick) && e.on("click", h) }), s.on("close", () => { (s.params.closeByBackdropClick || s.params.closeByOutsideClick) && e.off("click", h) }), c && (c[0].f7Modal = s), s } render() { const e = this; if (e.params.render) return e.params.render.call(e, e); const { groups: t } = e, a = e.params.cssClass; return x("div", { class: `actions-modal${e.params.grid ? " actions-grid" : ""} ${a || ""}` }, t.map(s => x("div", { class: "actions-group" }, s.map(r => { const i = [`actions-${r.label ? "label" : "button"}`], { color: o, bg: l, strong: c, disabled: d, label: u, text: p, icon: m } = r; return o && i.push(`color-${o}`), l && i.push(`bg-color-${l}`), c && i.push("actions-button-strong"), d && i.push("disabled"), u ? x("div", { class: i.join(" ") }, p) : x("div", { class: i.join(" ") }, m && x("div", { class: "actions-button-media" }, m), x("div", { class: "actions-button-text" }, p)) })))) } renderPopover() { const e = this; if (e.params.renderPopover) return e.params.renderPopover.call(e, e); const { groups: t } = e, a = e.params.cssClass; return x("div", { class: `popover popover-from-actions ${a || ""}` }, x("div", { class: "popover-inner" }, t.map(s => x("div", { class: "list" }, x("ul", null, s.map(r => { const i = [], { color: o, bg: l, strong: c, disabled: d, label: u, text: p, icon: m } = r; return o && i.push(`color-${o}`), l && i.push(`bg-color-${l}`), c && i.push("popover-from-actions-strong"), d && i.push("disabled"), u ? (i.push("popover-from-actions-label"), `<li class="${i.join(" ")}">${p}</li>`) : m ? (i.push("item-link item-content"), x("li", null, x("a", { class: i.join(" ") }, x("div", { class: "item-media" }, m), x("div", { class: "item-inner" }, x("div", { class: "item-title" }, p))))) : (i.push("list-button"), x("li", null, x("a", { class: i.join(" ") }, p))) })))))) } }; const $l = { name: "actions", params: { actions: { convertToPopover: !0, forceToPopover: !1, backdrop: !0, backdropEl: void 0, backdropUnique: !1, cssClass: null, closeByBackdropClick: !0, closeOnEscape: !1, render: null, renderPopover: null, containerEl: null } }, static: { Actions: xn }, create() { const n = this; n.actions = Ze({ app: n, constructor: xn, defaultSelector: ".actions-modal.modal-in" }) }, clicks: { ".actions-open": function (e, t) { t === void 0 && (t = {}), this.actions.open(t.actions, t.animate, e) }, ".actions-close": function (e, t) { t === void 0 && (t = {}), this.actions.close(t.actions, t.animate, e) } } }; let kn = class extends Ye { constructor(e, t) { const a = R({ on: {} }, e.params.sheet, t); super(e, a); const s = this, r = U(), i = ee(), o = Ee(), l = ue(); s.params = a, typeof s.params.backdrop > "u" && (s.params.backdrop = e.theme !== "ios"); let c; if (s.params.el ? c = y(s.params.el).eq(0) : c = y(s.params.content).filter(Y => Y.nodeType === 1).eq(0), c && c.length > 0 && c[0].f7Modal) return c[0].f7Modal; if (c.length === 0) return s.destroy(); let d; s.params.backdrop && s.params.backdropEl ? d = y(s.params.backdropEl) : s.params.backdrop && (s.params.backdropUnique ? (d = y('<div class="sheet-backdrop sheet-backdrop-unique"></div>'), s.$containerEl.append(d)) : d = s.$containerEl.children(".sheet-backdrop"), d.length === 0 && (d = y('<div class="sheet-backdrop"></div>'), s.$containerEl.append(d))), R(s, { app: e, push: c.hasClass("sheet-modal-push") || s.params.push, $el: c, el: c[0], $backdropEl: d, backdropEl: d && d[0], type: "sheet", $htmlEl: y("html") }), s.params.push && c.addClass("sheet-modal-push"); let u; function p() { const Y = y(s.params.scrollToEl).eq(0); if (Y.length === 0 || (u = Y.parents(".page-content"), u.length === 0)) return; const X = parseInt(u.css("padding-top"), 10), K = parseInt(u.css("padding-bottom"), 10), W = u[0].offsetHeight - X - c.height(), G = u[0].scrollHeight - X - c.height(), Z = u.scrollTop(); let ie; const ge = Y.offset().top - X + Y[0].offsetHeight; if (ge > W) { const te = Z + ge - W; te + W > G && (ie = te + W - G + K, W === G && (ie = c.height()), u.css({ "padding-bottom": `${ie}px` })), u.scrollTop(te, 300) } } function m() { u && u.length > 0 && u.css({ "padding-bottom": "" }) } function f(Y) { const X = Y.target, K = y(X); !l.desktop && l.cordova && (r.Keyboard && r.Keyboard.isVisible || r.cordova.plugins && r.cordova.plugins.Keyboard && r.cordova.plugins.Keyboard.isVisible) || K.closest(s.el).length === 0 && (s.params.closeByBackdropClick && s.params.backdrop && s.backdropEl && s.backdropEl === X || s.params.closeByOutsideClick) && s.close() } function h(Y) { Y.keyCode === 27 && s.params.closeOnEscape && s.close() } let b; function g(Y) { return (e.height - Y * 2) / e.height } let v = !1, E, $, w, C, k, M = !1, A, O, S, P, T, I, H, D, z, B, L, N, F; function V(Y) { v || !(s.params.swipeToClose || s.params.swipeToStep) || !Y.isTrusted || s.params.swipeHandler && y(Y.target).closest(s.params.swipeHandler).length === 0 || (v = !0, M = !1, E = { x: Y.type === "touchstart" ? Y.targetTouches[0].pageX : Y.pageX, y: Y.type === "touchstart" ? Y.targetTouches[0].pageY : Y.pageY }, C = Ie(), w = void 0, A = c.hasClass("sheet-modal-top"), !s.params.swipeHandler && Y.type === "touchstart" && (B = y(Y.target).closest(".page-content")[0])) } function _(Y) { if (!v || !Y.isTrusted) return; if ($ = { x: Y.type === "touchmove" ? Y.targetTouches[0].pageX : Y.pageX, y: Y.type === "touchmove" ? Y.targetTouches[0].pageY : Y.pageY }, typeof w > "u" && (w = !!(w || Math.abs($.x - E.x) > Math.abs($.y - E.y))), w) { v = !1, M = !1; return } k = E.y - $.y; const X = k < 0 ? "to-bottom" : "to-top"; if (!M) { if (B && !c.hasClass("modal-in-swipe-step") && (L = B.scrollTop, N = B.scrollHeight, F = B.offsetHeight, N !== F && !(X === "to-bottom" && L === 0) && !(X === "to-top" && L === N - F))) { c.transform(""), v = !1, M = !1; return } s.push && b && (D = e.$el.children(".view, .views")), T = c[0].offsetHeight, S = Ut(c[0], "y"), A ? (I = s.params.swipeToClose ? -T : -O, H = 0) : (I = 0, H = s.params.swipeToClose ? T : O), M = !0 } if (P = S - k, P = Math.min(Math.max(P, I), H), Y.preventDefault(), s.push && b) { let K = (P - S) / T; s.params.swipeToStep && (A ? K = P / O : K = 1 - (O - P) / O), K = Math.abs(K), K = Math.min(Math.max(K, 0), 1); const W = 1 - K, G = 1 - (1 - g(b)) * W; D.transition(0).forEach(Z => { Z.style.setProperty("transform", `translate3d(0,0,0) scale(${G})`, "important") }), s.params.swipeToStep && D.css("border-radius", `${z * W}px`) } if (c.transition(0).transform(`translate3d(0,${P}px,0)`), s.params.swipeToStep) { let K; A ? K = 1 - P / O : K = (O - P) / O, K = Math.min(Math.max(K, 0), 1), c.trigger("sheet:stepprogress", K), s.emit("local::stepProgress sheetStepProgress", s, K) } } function J() { if (v = !1, !M) return; M = !1, c.transform("").transition(""), s.push && b && (D.transition("").transform(""), D.css("border-radius", "")); const Y = k < 0 ? "to-bottom" : "to-top", X = Math.abs(k); if (X === 0 || P === S) return; const K = new Date().getTime() - C; if (!s.params.swipeToStep) { if (Y !== (A ? "to-top" : "to-bottom")) return; (K < 300 && X > 20 || K >= 300 && X > T / 2) && s.close(); return } const W = A ? "to-bottom" : "to-top", G = A ? "to-top" : "to-bottom", Z = Math.abs(P), ie = Math.abs(O); if (K < 300 && X > 10) { Y === W && Z < ie && (c.removeClass("modal-in-swipe-step"), c.trigger("sheet:stepprogress", 1), s.emit("local::stepProgress sheetStepProgress", s, 1), s.emit("local::_swipeStep", !1), c.trigger("sheet:stepopen"), s.emit("local::stepOpen sheetStepOpen", s), s.push && b && (s.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", g(b)), D.css("border-radius", ""))), Y === G && Z > ie && (s.params.swipeToClose ? s.close() : (c.addClass("modal-in-swipe-step"), c.trigger("sheet:stepprogress", 0), s.emit("local::stepProgress sheetStepProgress", s, 0), s.emit("local::_swipeStep", !0), c.trigger("sheet:stepclose"), s.emit("local::stepClose sheetStepClose", s), s.push && b && (s.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"), D.css("border-radius", "0px")))), Y === G && Z <= ie && (c.addClass("modal-in-swipe-step"), c.trigger("sheet:stepprogress", 0), s.emit("local::stepProgress sheetStepProgress", s, 0), s.emit("local::_swipeStep", !0), c.trigger("sheet:stepclose"), s.emit("local::stepClose sheetStepClose", s), s.push && b && (s.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"), D.css("border-radius", "0px"))); return } if (K >= 300) { const ge = !c.hasClass("modal-in-swipe-step"); ge ? ge && (Z > ie + (T - ie) / 2 ? s.params.swipeToClose && s.close() : Z > ie / 2 && (c.addClass("modal-in-swipe-step"), c.trigger("sheet:stepprogress", 0), s.emit("local::stepProgress sheetStepProgress", s, 0), s.emit("local::_swipeStep", !0), c.trigger("sheet:stepclose"), s.emit("local::stepClose sheetStepClose", s), s.push && b && (s.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"), D.css("border-radius", "0px")))) : Z < ie / 2 ? (c.removeClass("modal-in-swipe-step"), c.trigger("sheet:stepprogress", 1), s.emit("local::stepProgress sheetStepProgress", s, 1), s.emit("local::_swipeStep", !1), c.trigger("sheet:stepopen"), s.emit("local::stepOpen sheetStepOpen", s), s.push && b && (s.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", g(b)), D.css("border-radius", ""))) : Z - ie > (T - ie) / 2 && s.params.swipeToClose && s.close() } } s.setSwipeStep = function (X) { X === void 0 && (X = !0); const K = c.find(".sheet-modal-swipe-step").eq(0); K.length && (c.hasClass("sheet-modal-top") ? O = -(K.offset().top - c.offset().top + K[0].offsetHeight) : O = c[0].offsetHeight - (K.offset().top - c.offset().top + K[0].offsetHeight), c[0].style.setProperty("--f7-sheet-swipe-step", `${O}px`), X || (c.addClass("modal-in-swipe-step"), s.emit("local::_swipeStep", !0))) }; function Q() { s.setSwipeStep(!0) } const j = o.passiveListener ? { passive: !0 } : !1; return (s.params.swipeToClose || s.params.swipeToStep) && (c.on(e.touchEvents.start, V, j), e.on("touchmove", _), e.on("touchend:passive", J), s.once("sheetDestroy", () => { c.off(e.touchEvents.start, V, j), e.off("touchmove", _), e.off("touchend:passive", J) })), s.on("open", () => { s.params.closeOnEscape && y(i).on("keydown", h), c.prevAll(".popup.modal-in").addClass("popup-behind"), s.params.swipeToStep && (s.setSwipeStep(!1), e.on("resize", Q)), s.params.scrollToEl && p(), s.push && (b = parseInt(c.css("--f7-sheet-push-offset"), 10), Number.isNaN(b) && (b = 0), b || (b = e.theme === "ios" ? 44 : 48), s.$htmlEl[0].style.setProperty("--f7-sheet-push-offset", `${b}px`), c.addClass("sheet-modal-push"), s.$htmlEl.addClass("with-modal-sheet-push"), s.params.swipeToStep ? (D = e.$el.children(".view, .views"), z = parseFloat(c.css(`border-${A ? "bottom" : "top"}-left-radius`)), D.css("border-radius", "0px")) : s.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", g(b))) }), s.on("opened", () => { (s.params.closeByOutsideClick || s.params.closeByBackdropClick) && e.on("click", f) }), s.on("close", () => { s.params.swipeToStep && (c.removeClass("modal-in-swipe-step"), s.emit("local::_swipeStep", !1), e.off("resize", Q)), s.params.closeOnEscape && y(i).off("keydown", h), s.params.scrollToEl && m(), (s.params.closeByOutsideClick || s.params.closeByBackdropClick) && e.off("click", f), c.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind"), s.push && b && (s.$htmlEl.removeClass("with-modal-sheet-push"), s.$htmlEl.addClass("with-modal-sheet-push-closing")) }), s.on("closed", () => { s.push && b && (s.$htmlEl.removeClass("with-modal-sheet-push-closing"), s.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale"), s.$htmlEl[0].style.removeProperty("--f7-sheet-push-offset")) }), s.stepOpen = function () { c.removeClass("modal-in-swipe-step"), s.emit("local::_swipeStep", !1), s.push && (b || (b = parseInt(c.css("--f7-sheet-push-offset"), 10), Number.isNaN(b) && (b = 0)), b && s.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", g(b))) }, s.stepClose = function () { c.addClass("modal-in-swipe-step"), s.emit("local::_swipeStep", !0), s.push && s.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale") }, s.stepToggle = function () { c.toggleClass("modal-in-swipe-step"), s.emit("local::_swipeStep", c.hasClass("modal-in-swipe-step")) }, c[0].f7Modal = s, s } }; const xl = { name: "sheet", params: { sheet: { push: !1, backdrop: void 0, backdropEl: void 0, backdropUnique: !1, closeByBackdropClick: !0, closeByOutsideClick: !1, closeOnEscape: !1, swipeToClose: !1, swipeToStep: !1, swipeHandler: null, containerEl: null } }, static: { Sheet: kn }, create() { const n = this; n.sheet = R({}, Ze({ app: n, constructor: kn, defaultSelector: ".sheet-modal.modal-in" }), { stepOpen(e) { const t = n.sheet.get(e); if (t && t.stepOpen) return t.stepOpen() }, stepClose(e) { const t = n.sheet.get(e); if (t && t.stepClose) return t.stepClose() }, stepToggle(e) { const t = n.sheet.get(e); if (t && t.stepToggle) return t.stepToggle() } }) }, clicks: { ".sheet-open": function (e, t) { t === void 0 && (t = {}); const a = this; y(".sheet-modal.modal-in").length > 0 && t.sheet && y(t.sheet)[0] !== y(".sheet-modal.modal-in")[0] && a.sheet.close(".sheet-modal.modal-in"), a.sheet.open(t.sheet, t.animate, e) }, ".sheet-close": function (e, t) { t === void 0 && (t = {}), this.sheet.close(t.sheet, t.animate, e) } } }; let va = class extends Ye { constructor(e, t) { const a = R({ on: {} }, e.params.toast, t); super(e, a); const s = this, r = U(); s.app = e, s.params = a; const { closeButton: i, closeTimeout: o } = s.params; let l; if (s.params.el) l = y(s.params.el); else { const d = s.render(); l = y(d) } if (l && l.length > 0 && l[0].f7Modal) return l[0].f7Modal; if (l.length === 0) return s.destroy(); R(s, { $el: l, el: l[0], type: "toast" }), l[0].f7Modal = s, i && (l.find(".toast-button").on("click", () => { s.emit("local::closeButtonClick toastCloseButtonClick", s), s.close() }), s.on("beforeDestroy", () => { l.find(".toast-button").off("click") })); let c; return s.on("open", () => { y(".toast.modal-in").each(d => { const u = e.toast.get(d); d !== s.el && u && u.close() }), o && (c = $e(() => { s.close() }, o)) }), s.on("close", () => { r.clearTimeout(c) }), s.params.destroyOnClose && s.once("closed", () => { setTimeout(() => { s.destroy() }, 0) }), s } render() { const e = this; if (e.params.render) return e.params.render.call(e, e); const { position: t, horizontalPosition: a, cssClass: s, icon: r, text: i, closeButton: o, closeButtonColor: l, closeButtonText: c } = e.params, d = t === "top" || t === "bottom" ? `toast-horizontal-${a}` : ""; return x("div", { class: `toast toast-${t} ${d} ${s || ""} ${r ? "toast-with-icon" : ""}` }, x("div", { class: "toast-content" }, r && x("div", { class: "toast-icon" }, r), x("div", { class: "toast-text" }, i), o && !r && x("a", { class: `toast-button button ${l ? `color-${l}` : ""}` }, c))) } }; const kl = { name: "toast", static: { Toast: va }, create() { const n = this; n.toast = R({}, Ze({ app: n, constructor: va, defaultSelector: ".toast.modal-in" }), { show(e) { return R(e, { destroyOnClose: !0 }), new va(n, e).open() } }) }, params: { toast: { icon: null, text: null, position: "bottom", horizontalPosition: "left", closeButton: !1, closeButtonColor: null, closeButtonText: "Ok", closeTimeout: null, cssClass: null, render: null, containerEl: null } } }, Pt = {
  init(n) { const e = this, t = { iosPreloaderContent: ct, mdPreloaderContent: lt }, a = y(n); a.length === 0 || a.children(".preloader-inner").length > 0 || a.children(".preloader-inner-line").length > 0 || a.append(t[`${e.theme}PreloaderContent`]) }, visible: !1, show(n) {
    n === void 0 && (n = "white"); const e = this; if (Pt.visible) return; const a = { iosPreloaderContent: ct, mdPreloaderContent: lt }[`${e.theme}PreloaderContent`] || ""; y("html").addClass("with-modal-preloader"), e.$el.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${n}">${a}</div>
      </div>
    `), Pt.visible = !0
  }, showIn(n, e) {
    e === void 0 && (e = "white"); const t = this, s = { iosPreloaderContent: ct, mdPreloaderContent: lt }[`${t.theme}PreloaderContent`] || ""; y(n || "html").addClass("with-modal-preloader"), y(n || t.$el).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${e}">${s}</div>
      </div>
    `)
  }, hide() { const n = this; Pt.visible && (y("html").removeClass("with-modal-preloader"), n.$el.find(".preloader-backdrop, .preloader-modal").remove(), Pt.visible = !1) }, hideIn(n) { const e = this; y(n || "html").removeClass("with-modal-preloader"), y(n || e.$el).find(".preloader-backdrop, .preloader-modal").remove() }
}, Tl = { name: "preloader", create() { Se(this, { preloader: Pt }) }, on: { photoBrowserOpen(n) { const e = this; n.$el.find(".preloader").each(t => { e.preloader.init(t) }) }, tabMounted(n) { const e = this; y(n).find(".preloader").each(t => { e.preloader.init(t) }) }, pageInit(n) { const e = this; n.$el.find(".preloader").each(t => { e.preloader.init(t) }) } }, vnode: { preloader: { insert(n) { const e = this, t = n.elm; e.preloader.init(t) } } } }, Sl = {
  set() { const n = this; for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; let [s, r, i] = t; if (typeof t[0] == "number" && ([r, i] = t, s = n.$el), typeof r > "u" || r === null) return s; r || (r = 0); const o = y(s || n.$el); if (o.length === 0) return s; const l = Math.min(Math.max(r, 0), 100); let c; if (o.hasClass("progressbar") ? c = o.eq(0) : c = o.children(".progressbar"), c.length === 0 || c.hasClass("progressbar-infinite")) return c; let d = c.children("span"); return d.length === 0 && (d = y("<span></span>"), c.append(d)), d.transition(typeof i < "u" ? i : "").transform(`translate3d(${(-100 + l) * (n.rtl ? -1 : 1)}%,0,0)`), c[0] }, show() {
    const n = this; for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; let [s, r, i] = t, o = "determined"; t.length === 2 ? (typeof t[0] == "string" || typeof t[0] == "object") && typeof t[1] == "string" ? ([s, i, r] = t, o = "infinite") : typeof t[0] == "number" && typeof t[1] == "string" && ([r, i] = t, s = n.$el) : t.length === 1 ? typeof t[0] == "number" ? (s = n.$el, r = t[0]) : typeof t[0] == "string" && (o = "infinite", s = n.$el, i = t[0]) : t.length === 0 && (o = "infinite", s = n.$el); const l = y(s); if (l.length === 0) return; let c; return l.hasClass("progressbar") || l.hasClass("progressbar-infinite") ? c = l : (c = l.children(".progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)"), c.length === 0 && (c = y(`
          <span class="progressbar${o === "infinite" ? "-infinite" : ""}${i ? ` color-${i}` : ""} progressbar-in">
            ${o === "infinite" ? "" : "<span></span>"}
          </span>`), l.append(c))), typeof r < "u" && n.progressbar.set(c, r), c[0]
  }, hide(n, e) { e === void 0 && (e = !0); const a = y(n || this.$el); if (a.length === 0) return; let s; return a.hasClass("progressbar") || a.hasClass("progressbar-infinite") ? s = a : s = a.children(".progressbar, .progressbar-infinite"), s.length === 0 || !s.hasClass("progressbar-in") || s.hasClass("progressbar-out") || s.removeClass("progressbar-in").addClass("progressbar-out").animationEnd(() => { e && s.remove() }), s }
}, Ml = { name: "progressbar", create() { Se(this, { progressbar: Sl }) }, on: { tabMounted(n) { const e = this; y(n).find(".progressbar").each(t => { const a = y(t); e.progressbar.set(a, a.attr("data-progress")) }) }, pageInit(n) { const e = this; n.$el.find(".progressbar").each(t => { const a = y(t); e.progressbar.set(a, a.attr("data-progress")) }) } }, vnode: { progressbar: { insert(n) { const e = this, t = n.elm; e.progressbar.set(t, t.getAttribute("data-progress")) }, update(n) { const e = this, t = n.elm; e.progressbar.set(t, t.getAttribute("data-progress")) } } } }, Pl = { init() { const n = this, e = ee(); let t, a, s, r, i, o, l, c, d, u, p, m, f, h, b, g, v, E, $, w, C; function k(S, P) { a = !1, t = !0, C = !1, s = S.type === "touchstart" ? S.targetTouches[0].pageY : S.pageY, i = y(S.target).closest("li").eq(0), f = i.index(), l = i.parents(".sortable"); const T = i.parents(".list-group"); T.length && T.parents(l).length && (l = T), o = l.children("ul").children("li:not(.disallow-sorting):not(.no-sorting)"), n.panel && (n.panel.allowOpen = !1), n.swipeout && (n.swipeout.allow = !1), P && (i.addClass("sorting"), l.addClass("sortable-sorting"), C = !0) } function M(S) { if (!t || !i) return; const P = S.type === "touchmove" ? S.targetTouches[0].pageY : S.pageY; if (!a) { h = i.parents(".page"), b = i.parents(".page-content"); const B = parseInt(b.css("padding-top"), 10), L = parseInt(b.css("padding-bottom"), 10); w = b[0].scrollTop, v = h.offset().top + B, g = h.height() - B - L, i.addClass("sorting"), l.addClass("sortable-sorting"), E = i[0].offsetTop, d = i[0].offsetTop, u = i.parent().height() - E - i.height(), c = i[0].offsetHeight, $ = i.offset().top } a = !0, S.preventDefault(), S.f7PreventSwipePanel = !0, r = P - s; const T = b[0].scrollTop - w, I = Math.min(Math.max(r + T, -d), u); i.transform(`translate3d(0,${I}px,0)`); const H = 44; let D = !0; r + T + H < -d && (D = !1), r + T - H > u && (D = !1), m = void 0, p = void 0; let z; D && ($ + r + c + H > v + g && (z = $ + r + c + H - (v + g)), $ + r < v + H && (z = $ + r - v - H), z && (b[0].scrollTop += z)), o.each(B => { const L = y(B); if (L[0] === i[0]) return; const N = L[0].offsetTop, F = L.height(), V = E + I; let _; const J = L[0].f7Translate; V >= N - F / 2 && i.index() < L.index() ? (_ = -c, L.transform(`translate3d(0, ${_}px,0)`), p = L, m = void 0) : V <= N + F / 2 && i.index() > L.index() ? (_ = c, L[0].f7Translate = _, L.transform(`translate3d(0, ${_}px,0)`), p = void 0, m || (m = L)) : (_ = void 0, L.transform("translate3d(0, 0%,0)")), J !== _ && (L.trigger("sortable:move"), n.emit("sortableMove", L[0], l[0])), L[0].f7Translate = _ }) } function A() { if (!t || !a) { t && !a && (n.panel && (n.panel.allowOpen = !0), n.swipeout && (n.swipeout.allow = !0), C && (i.removeClass("sorting"), l.removeClass("sortable-sorting"))), t = !1, a = !1; return } n.panel && (n.panel.allowOpen = !0), n.swipeout && (n.swipeout.allow = !0), o.transform(""), i.removeClass("sorting"), l.removeClass("sortable-sorting"); let S; p ? S = p.index() : m && (S = m.index()); let P = l.dataset().sortableMoveElements; if (typeof P > "u" && (P = n.params.sortable.moveElements), P && (p && i.insertAfter(p), m && i.insertBefore(m)), (p || m) && l.hasClass("virtual-list")) { f = i[0].f7VirtualListIndex, typeof f > "u" && (f = i.attr("data-virtual-list-index")), m ? (S = m[0].f7VirtualListIndex, typeof S > "u" && (S = m.attr("data-virtual-list-index"))) : (S = p[0].f7VirtualListIndex, typeof S > "u" && (S = p.attr("data-virtual-list-index"))), S !== null ? S = parseInt(S, 10) : S = void 0; const T = l[0].f7VirtualList; f && (f = parseInt(f, 10)), S && (S = parseInt(S, 10)), T && T.moveItem(f, S) } typeof S < "u" && !Number.isNaN(S) && S !== f && (i.trigger("sortable:sort", { from: f, to: S }), n.emit("sortableSort", i[0], { from: f, to: S, el: i[0] }, l[0])), m = void 0, p = void 0, t = !1, a = !1 } const O = Ee().passiveListener ? { passive: !1, capture: !1 } : !1; y(e).on(n.touchEvents.start, ".list.sortable .sortable-handler", k, O), n.on("touchmove:active", M), n.on("touchend:passive", A), y(e).on("taphold", ".sortable-tap-hold", (S, P) => { k(P, !0) }) }, enable(n) { n === void 0 && (n = ".list.sortable"); const e = this, t = y(n); t.length !== 0 && (t.addClass("sortable-enabled"), t.trigger("sortable:enable"), e.emit("sortableEnable", t[0])) }, disable(n) { n === void 0 && (n = ".list.sortable"); const e = this, t = y(n); t.length !== 0 && (t.removeClass("sortable-enabled"), t.trigger("sortable:disable"), e.emit("sortableDisable", t[0])) }, toggle(n) { n === void 0 && (n = ".list.sortable"); const e = this, t = y(n); t.length !== 0 && (t.hasClass("sortable-enabled") ? e.sortable.disable(t) : e.sortable.enable(t)) } }, Al = { name: "sortable", params: { sortable: { moveElements: !0 } }, create() { Se(this, { sortable: Pl }) }, on: { init() { const n = this; n.params.sortable && n.sortable.init() } }, clicks: { ".sortable-enable": function (e, t) { t === void 0 && (t = {}), this.sortable.enable(t.sortable) }, ".sortable-disable": function (e, t) { t === void 0 && (t = {}), this.sortable.disable(t.sortable) }, ".sortable-toggle": function (e, t) { t === void 0 && (t = {}), this.sortable.toggle(t.sortable) } } }, Re = { init() { const n = this, e = ee(), t = {}; let a, s, r, i, o, l, c, d, u, p, m, f, h, b, g, v, E, $, w, C, k; function M(P) { n.swipeout.allow && (s = !1, a = !0, r = void 0, t.x = P.type === "touchstart" ? P.targetTouches[0].pageX : P.pageX, t.y = P.type === "touchstart" ? P.targetTouches[0].pageY : P.pageY, i = new Date().getTime(), l = y(this)) } function A(P) { if (!a) return; const T = P.type === "touchmove" ? P.targetTouches[0].pageX : P.pageX, I = P.type === "touchmove" ? P.targetTouches[0].pageY : P.pageY; if (typeof r > "u" && (r = !!(r || Math.abs(I - t.y) > Math.abs(T - t.x))), r) { a = !1; return } if (!s) { if (y(".list.sortable-opened").length > 0) return; c = l.find(".swipeout-content"), d = l.find(".swipeout-actions-right"), u = l.find(".swipeout-actions-left"), p = null, m = null, g = null, v = null, w = null, $ = null, u.length > 0 && (p = u.outerWidth(), g = u.children("a"), $ = u.find(".swipeout-overswipe")), d.length > 0 && (m = d.outerWidth(), v = d.children("a"), w = d.find(".swipeout-overswipe")), h = l.hasClass("swipeout-opened"), h && (b = l.find(".swipeout-actions-left.swipeout-actions-opened").length > 0 ? "left" : "right"), l.removeClass("swipeout-transitioning"), n.params.swipeout.noFollow || (l.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened"), l.removeClass("swipeout-opened")) } if (s = !0, P.cancelable && P.preventDefault(), o = T - t.x, f = o, h && (b === "right" ? f -= m : f += p), f > 0 && u.length === 0 || f < 0 && d.length === 0) { if (!h) { a = !1, s = !1, c.transform(""), v && v.length > 0 && v.transform(""), g && g.length > 0 && g.transform(""); return } f = 0 } f < 0 ? E = "to-left" : f > 0 ? E = "to-right" : E || (E = "to-left"); let H, D; if (P.f7PreventSwipePanel = !0, n.params.swipeout.noFollow) { h ? (b === "right" && o > 0 && n.swipeout.close(l), b === "left" && o < 0 && n.swipeout.close(l)) : (o < 0 && d.length > 0 && n.swipeout.open(l, "right"), o > 0 && u.length > 0 && n.swipeout.open(l, "left")), a = !1, s = !1; return } if (C = !1, k = !1, d.length > 0) { let z = f; if (D = z / m, z < -m) { const B = z / -m; z = -m - (-z - m) ** .8, f = z, w.length > 0 && B > n.params.swipeout.overswipeRatio && (k = !0) } E !== "to-left" && (D = 0, z = 0), v.each(B => { const L = y(B); typeof B.f7SwipeoutButtonOffset > "u" && (L[0].f7SwipeoutButtonOffset = B.offsetLeft), H = B.f7SwipeoutButtonOffset, w.length > 0 && L.hasClass("swipeout-overswipe") && E === "to-left" && (L.css({ left: `${k ? -H : 0}px` }), k ? (L.hasClass("swipeout-overswipe-active") || (l.trigger("swipeout:overswipeenter"), n.emit("swipeoutOverswipeEnter", l[0])), L.addClass("swipeout-overswipe-active")) : (L.hasClass("swipeout-overswipe-active") && (l.trigger("swipeout:overswipeexit"), n.emit("swipeoutOverswipeExit", l[0])), L.removeClass("swipeout-overswipe-active"))), L.transform(`translate3d(${z - H * (1 + Math.max(D, -1))}px,0,0)`) }) } if (u.length > 0) { let z = f; if (D = z / p, z > p) { const B = z / m; z = p + (z - p) ** .8, f = z, $.length > 0 && B > n.params.swipeout.overswipeRatio && (C = !0) } E !== "to-right" && (z = 0, D = 0), g.each((B, L) => { const N = y(B); typeof B.f7SwipeoutButtonOffset > "u" && (N[0].f7SwipeoutButtonOffset = p - B.offsetLeft - B.offsetWidth), H = B.f7SwipeoutButtonOffset, $.length > 0 && N.hasClass("swipeout-overswipe") && E === "to-right" && (N.css({ left: `${C ? H : 0}px` }), C ? (N.hasClass("swipeout-overswipe-active") || (l.trigger("swipeout:overswipeenter"), n.emit("swipeoutOverswipeEnter", l[0])), N.addClass("swipeout-overswipe-active")) : (N.hasClass("swipeout-overswipe-active") && (l.trigger("swipeout:overswipeexit"), n.emit("swipeoutOverswipeExit", l[0])), N.removeClass("swipeout-overswipe-active"))), g.length > 1 && N.css("z-index", g.length - L), N.transform(`translate3d(${z + H * (1 - Math.min(D, 1))}px,0,0)`) }) } l.trigger("swipeout", D), n.emit("swipeout", l[0], D), c.transform(`translate3d(${f}px,0,0)`) } function O() { if (!a || !s) { a = !1, s = !1; return } a = !1, s = !1; const P = new Date().getTime() - i, T = E === "to-left" ? d : u, I = E === "to-left" ? m : p; let H, D, z; if (P < 300 && (o < -10 && E === "to-left" || o > 10 && E === "to-right") || P >= 300 && Math.abs(f) > I / 2 ? H = "open" : H = "close", P < 300 && (Math.abs(f) === 0 && (H = "close"), Math.abs(f) === I && (H = "open")), H === "open") { Re.el = l[0], l.trigger("swipeout:open"), n.emit("swipeoutOpen", l[0]), l.addClass("swipeout-opened swipeout-transitioning"); const L = E === "to-left" ? -I : I; if (c.transform(`translate3d(${L}px,0,0)`), T.addClass("swipeout-actions-opened"), D = E === "to-left" ? v : g, D) for (z = 0; z < D.length; z += 1)y(D[z]).transform(`translate3d(${L}px,0,0)`); k && d.find(".swipeout-overswipe").trigger("click", "f7Overswipe"), C && u.find(".swipeout-overswipe").trigger("click", "f7Overswipe") } else l.trigger("swipeout:close"), n.emit("swipeoutClose", l[0]), Re.el = void 0, l.addClass("swipeout-transitioning").removeClass("swipeout-opened"), c.transform(""), T.removeClass("swipeout-actions-opened"); let B; g && g.length > 0 && g !== D && g.each(L => { const N = y(L); B = L.f7SwipeoutButtonOffset, typeof B > "u" && (N[0].f7SwipeoutButtonOffset = p - L.offsetLeft - L.offsetWidth), N.transform(`translate3d(${B}px,0,0)`) }), v && v.length > 0 && v !== D && v.each(L => { const N = y(L); B = L.f7SwipeoutButtonOffset, typeof B > "u" && (N[0].f7SwipeoutButtonOffset = L.offsetLeft), N.transform(`translate3d(${-B}px,0,0)`) }), c.transitionEnd(() => { h && H === "open" || !h && H === "close" || (l.trigger(H === "open" ? "swipeout:opened" : "swipeout:closed"), n.emit(H === "open" ? "swipeoutOpened" : "swipeoutClosed", l[0]), l.removeClass("swipeout-transitioning"), h && H === "close" && (d.length > 0 && v.transform(""), u.length > 0 && g.transform(""))) }) } const S = Ee().passiveListener ? { passive: !0 } : !1; n.on("touchstart", P => { if (Re.el) { const T = y(P.target); y(Re.el).is(T[0]) || T.parents(".swipeout").is(Re.el) || T.hasClass("modal-in") || (T.attr("class") || "").indexOf("-backdrop") > 0 || T.hasClass("actions-modal") || T.parents(".actions-modal.modal-in, .dialog.modal-in").length > 0 || n.swipeout.close(Re.el) } }), y(e).on(n.touchEvents.start, "li.swipeout", M, S), n.on("touchmove:active", A), n.on("touchend:passive", O) }, allow: !0, el: void 0, open() { const n = this; for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)t[a] = arguments[a]; let [s, r, i] = t; typeof t[1] == "function" && ([s, i, r] = t); const o = y(s).eq(0); if (o.length === 0 || !o.hasClass("swipeout") || o.hasClass("swipeout-opened")) return; r || (o.find(".swipeout-actions-right").length > 0 ? r = "right" : r = "left"); const l = o.find(`.swipeout-actions-${r}`), c = o.find(".swipeout-content"); if (l.length === 0) return; o.trigger("swipeout:open").addClass("swipeout-opened").removeClass("swipeout-transitioning"), n.emit("swipeoutOpen", o[0]), l.addClass("swipeout-actions-opened"); const d = l.children("a"), u = l.outerWidth(), p = r === "right" ? -u : u; d.length > 1 && d.each((m, f) => { const h = y(m); r === "right" ? h.transform(`translate3d(${-m.offsetLeft}px,0,0)`) : h.css("z-index", d.length - f).transform(`translate3d(${u - m.offsetWidth - m.offsetLeft}px,0,0)`) }), o.addClass("swipeout-transitioning"), c.transitionEnd(() => { o.trigger("swipeout:opened"), n.emit("swipeoutOpened", o[0]), i && i.call(o[0]) }), Ae(() => { d.transform(`translate3d(${p}px,0,0)`), c.transform(`translate3d(${p}px,0,0)`) }), Re.el = o[0] }, close(n, e) { const t = this, a = y(n).eq(0); if (a.length === 0 || !a.hasClass("swipeout-opened")) return; const s = a.find(".swipeout-actions-opened").hasClass("swipeout-actions-right") ? "right" : "left", r = a.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened"), i = r.children("a"), o = r.outerWidth(); t.swipeout.allow = !1, a.trigger("swipeout:close"), t.emit("swipeoutClose", a[0]), a.removeClass("swipeout-opened").addClass("swipeout-transitioning"); let l; function c() { t.swipeout.allow = !0, !a.hasClass("swipeout-opened") && (a.removeClass("swipeout-transitioning"), i.transform(""), a.trigger("swipeout:closed"), t.emit("swipeoutClosed", a[0]), e && e.call(a[0]), l && clearTimeout(l)) } a.find(".swipeout-content").transform("").transitionEnd(c), l = setTimeout(c, 500), i.each(d => { const u = y(d); s === "right" ? u.transform(`translate3d(${-d.offsetLeft}px,0,0)`) : u.transform(`translate3d(${o - d.offsetWidth - d.offsetLeft}px,0,0)`), u.css({ left: "0px" }).removeClass("swipeout-overswipe-active") }), Re.el && Re.el === a[0] && (Re.el = void 0) }, delete(n, e) { const t = this, a = y(n).eq(0); a.length !== 0 && (Re.el = void 0, a.trigger("swipeout:delete"), t.emit("swipeoutDelete", a[0]), a.css({ height: `${a.outerHeight()}px` }), a.transitionEnd(() => { if (a.trigger("swipeout:deleted"), t.emit("swipeoutDeleted", a[0]), e && e.call(a[0]), a.parents(".virtual-list").length > 0) { const s = a.parents(".virtual-list")[0].f7VirtualList, r = a[0].f7VirtualListIndex; s && typeof r < "u" && s.deleteItem(r) } else t.params.swipeout.removeElements ? t.params.swipeout.removeElementsWithTimeout ? setTimeout(() => { a.remove() }, t.params.swipeout.removeElementsTimeout) : a.remove() : a.removeClass("swipeout-deleting swipeout-transitioning") }), Ae(() => { a.addClass("swipeout-deleting swipeout-transitioning").css({ height: "0px" }).find(".swipeout-content").transform("translate3d(-100%,0,0)") })) } }, Il = { name: "swipeout", params: { swipeout: { actionsNoFold: !1, noFollow: !1, removeElements: !0, removeElementsWithTimeout: !1, removeElementsTimeout: 0, overswipeRatio: 1.2 } }, create() { Se(this, { swipeout: Re }) }, clicks: { ".swipeout-open": function (e, t) { t === void 0 && (t = {}), this.swipeout.open(t.swipeout, t.side) }, ".swipeout-close": function (e) { const t = this, a = e.closest(".swipeout"); a.length !== 0 && t.swipeout.close(a) }, ".swipeout-delete": function (e, t) { t === void 0 && (t = {}); const a = this, s = e.closest(".swipeout"); if (s.length === 0) return; const { confirm: r, confirmTitle: i } = t; t.confirm ? a.dialog.confirm(r, i, () => { a.swipeout.delete(s) }) : a.swipeout.delete(s) } }, on: { init() { const n = this; n.params.swipeout && n.swipeout.init() } } }, Tn = { toggleClicked(n) { const e = this; let t = n.closest(".accordion-item").eq(0); t.length || (t = n.parents("li").eq(0)); const a = n.parents(".accordion-item-content").eq(0); a.length && a.parents(t).length || n.parents("li").length > 1 && n.parents("li")[0] !== t[0] || e.accordion.toggle(t) }, open(n) { const e = this, t = y(n); let a = !1; function s() { a = !0 } if (t.trigger("accordion:beforeopen", { prevent: s }, s), e.emit("accordionBeforeOpen", t[0], s), a) return; const r = t.parents(".accordion-list").eq(0); let i = t.children(".accordion-item-content"); if (i.removeAttr("aria-hidden"), i.length === 0 && (i = t.find(".accordion-item-content")), i.length === 0) return; const o = r.length > 0 && t.parent().children(".accordion-item-opened"); o.length > 0 && e.accordion.close(o), i.transitionEnd(() => { t.hasClass("accordion-item-opened") ? (i.transition(0), i.css("height", "auto"), Ae(() => { i.transition(""), t.trigger("accordion:opened"), e.emit("accordionOpened", t[0]) })) : (i.css("height", ""), t.trigger("accordion:closed"), e.emit("accordionClosed", t[0])) }), i.css("height", `${i[0].scrollHeight}px`), t.trigger("accordion:open"), t.addClass("accordion-item-opened"), e.emit("accordionOpen", t[0]) }, close(n) { const e = this, t = y(n); let a = !1; function s() { a = !0 } if (t.trigger("accordion:beforeclose", { prevent: s }, s), e.emit("accordionBeforeClose", t[0], s), a) return; let r = t.children(".accordion-item-content"); r.length === 0 && (r = t.find(".accordion-item-content")), t.removeClass("accordion-item-opened"), r.attr("aria-hidden", !0), r.transition(0), r.css("height", `${r[0].scrollHeight}px`), r.transitionEnd(() => { t.hasClass("accordion-item-opened") ? (r.transition(0), r.css("height", "auto"), Ae(() => { r.transition(""), t.trigger("accordion:opened"), e.emit("accordionOpened", t[0]) })) : (r.css("height", ""), t.trigger("accordion:closed"), e.emit("accordionClosed", t[0])) }), Ae(() => { r.transition(""), r.css("height", ""), t.trigger("accordion:close"), e.emit("accordionClose", t[0]) }) }, toggle(n) { const e = this, t = y(n); t.length !== 0 && (t.hasClass("accordion-item-opened") ? e.accordion.close(n) : e.accordion.open(n)) } }, Ol = { name: "accordion", create() { Se(this, { accordion: Tn }) }, clicks: { ".accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a": function (e) { const t = this; Tn.toggleClicked.call(t, e) } } }, Bl = { name: "contactsList" }; let Sn = class extends me {
  constructor(e, t) {
    t === void 0 && (t = {}), super(t, [e]); const a = this, s = ue(), r = ee(); let i; e.theme === "md" ? i = 48 : e.theme === "ios" && (i = 44); const o = {
      cols: 1, height: i, cache: !0, dynamicHeightBufferSize: 1, showFilteredItemsOnly: !1, renderExternal: void 0, setListHeight: !0, searchByItem: void 0, searchAll: void 0, ul: null, createUl: !0, scrollableParentEl: void 0, renderItem(b) {
        return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${b}</div>
              </div>
            </div>
          </li>
        `.trim()
      }, on: {}
    }; if (a.useModulesParams(o), a.params = R(o, t), (a.params.height === void 0 || !a.params.height) && (a.params.height = i), a.$el = y(t.el), a.el = a.$el[0], a.$el.length === 0) return; a.$el[0].f7VirtualList = a, a.items = a.params.items, a.params.showFilteredItemsOnly && (a.filteredItems = []), a.params.renderItem && (a.renderItem = a.params.renderItem), a.$pageContentEl = a.$el.parents(".page-content"), a.pageContentEl = a.$pageContentEl[0], a.$scrollableParentEl = a.params.scrollableParentEl ? y(a.params.scrollableParentEl).eq(0) : a.$pageContentEl, !a.$scrollableParentEl.length && a.$pageContentEl.length && (a.$scrollableParentEl = a.$pageContentEl), a.scrollableParentEl = a.$scrollableParentEl[0], typeof a.params.updatableScroll < "u" ? a.updatableScroll = a.params.updatableScroll : (a.updatableScroll = !0, s.ios && s.osVersion.split(".")[0] < 8 && (a.updatableScroll = !1)); const l = a.params.ul; a.$ul = l ? y(a.params.ul) : a.$el.children("ul"), a.$ul.length === 0 && a.params.createUl && (a.$el.append("<ul></ul>"), a.$ul = a.$el.children("ul")), a.ul = a.$ul[0]; let c; !a.ul && !a.params.createUl ? c = a.$el : c = a.$ul, R(a, { $itemsWrapEl: c, itemsWrapEl: c[0], domCache: {}, tempDomElement: r.createElement("ul"), lastRepaintY: null, fragment: r.createDocumentFragment(), pageHeight: void 0, rowsPerScreen: void 0, rowsBefore: void 0, rowsAfter: void 0, rowsToRender: void 0, maxBufferHeight: 0, listHeight: void 0, dynamicHeight: typeof a.params.height == "function", autoHeight: a.params.height === "auto" }), a.useModules(); const d = a.handleScroll.bind(a), u = a.handleResize.bind(a); let p, m, f, h; return a.attachEvents = function () { p = a.$el.parents(".page").eq(0), m = a.$el.parents(".tab").filter(g => y(g).parent(".tabs").parent(".tabs-animated-wrap, swiper-container.tabs").length === 0).eq(0), f = a.$el.parents(".panel").eq(0), h = a.$el.parents(".popup").eq(0), a.$scrollableParentEl.on("scroll", d), p.length && p.on("page:reinit", u), m.length && m.on("tab:show", u), f.length && f.on("panel:open", u), h.length && h.on("popup:open", u), e.on("resize", u) }, a.detachEvents = function () { a.$scrollableParentEl.off("scroll", d), p.length && p.off("page:reinit", u), m.length && m.off("tab:show", u), f.length && f.off("panel:open", u), h.length && h.off("popup:open", u), e.off("resize", u) }, a.init(), a
  } setListSize(e) { const t = this, a = t.filteredItems || t.items; if (e || (t.pageHeight = t.$scrollableParentEl[0].offsetHeight), t.dynamicHeight) { t.listHeight = 0, t.heights = []; for (let s = 0; s < a.length; s += 1) { const r = t.params.height(a[s]); t.listHeight += r, t.heights.push(r) } } else if (t.autoHeight) { t.listHeight = 0, t.heights || (t.heights = []), t.heightsCalculated || (t.heightsCalculated = []); const s = {}; t.$itemsWrapEl.find("[data-virtual-list-index]").forEach(r => { s[parseInt(r.getAttribute("data-virtual-list-index"), 10)] = r }); for (let r = 0; r < a.length; r += 1) { const i = s[r]; i && (t.heightsCalculated.includes(r) || (t.heights[r] = i.offsetHeight, t.heightsCalculated.push(r))), typeof t.heights[r] > "u" && (t.heights[r] = 40), t.listHeight += t.heights[r] } } else t.listHeight = Math.ceil(a.length / t.params.cols) * t.params.height, t.rowsPerScreen = Math.ceil(t.pageHeight / t.params.height), t.rowsBefore = t.params.rowsBefore || t.rowsPerScreen * 2, t.rowsAfter = t.params.rowsAfter || t.rowsPerScreen, t.rowsToRender = t.rowsPerScreen + t.rowsBefore + t.rowsAfter, t.maxBufferHeight = t.rowsBefore / 2 * t.params.height; (t.updatableScroll || t.params.setListHeight) && t.$itemsWrapEl.css({ height: `${t.listHeight}px` }) } render(e, t) { const a = this; e && (a.lastRepaintY = null); let s = -(a.$el[0].getBoundingClientRect().top - a.$scrollableParentEl[0].getBoundingClientRect().top); if (typeof t < "u" && (s = t), a.lastRepaintY === null || Math.abs(s - a.lastRepaintY) > a.maxBufferHeight || !a.updatableScroll && a.$scrollableParentEl[0].scrollTop + a.pageHeight >= a.$scrollableParentEl[0].scrollHeight) a.lastRepaintY = s; else return; const r = a.filteredItems || a.items; let i, o, l = 0, c = 0; if (a.dynamicHeight || a.autoHeight) { let m = 0, f; a.maxBufferHeight = a.pageHeight; for (let h = 0; h < a.heights.length; h += 1)f = a.heights[h], typeof i > "u" && (m + f >= s - a.pageHeight * 2 * a.params.dynamicHeightBufferSize ? i = h : l += f), typeof o > "u" && ((m + f >= s + a.pageHeight * 2 * a.params.dynamicHeightBufferSize || h === a.heights.length - 1) && (o = h + 1), c += f), m += f; o = Math.min(o, r.length) } else i = (parseInt(s / a.params.height, 10) - a.rowsBefore) * a.params.cols, i < 0 && (i = 0), o = Math.min(i + a.rowsToRender * a.params.cols, r.length); let d; const u = []; a.reachEnd = !1; let p; for (p = i; p < o; p += 1) { let m; const f = a.items.indexOf(r[p]); p === i && (a.currentFromIndex = f), p === o - 1 && (a.currentToIndex = f), a.filteredItems ? a.items[f] === a.filteredItems[a.filteredItems.length - 1] && (a.reachEnd = !0) : f === a.items.length - 1 && (a.reachEnd = !0), a.params.renderExternal ? u.push(r[p]) : a.domCache[f] ? (m = a.domCache[f], m.f7VirtualListIndex = f) : (a.renderItem ? a.tempDomElement.innerHTML = a.renderItem(r[p], f).trim() : a.tempDomElement.innerHTML = r[p].toString().trim(), m = a.tempDomElement.childNodes[0], a.params.cache && (a.domCache[f] = m), m.f7VirtualListIndex = f), p === i && (a.dynamicHeight || a.autoHeight ? d = l : d = p * a.params.height / a.params.cols), a.params.renderExternal || (m.style.top = `${d}px`, a.emit("local::itemBeforeInsert vlItemBeforeInsert", a, m, r[p]), a.fragment.appendChild(m)) } a.updatableScroll || (a.dynamicHeight || a.autoHeight ? a.itemsWrapEl.style.height = `${c}px` : a.itemsWrapEl.style.height = `${p * a.params.height / a.params.cols}px`), a.params.renderExternal ? r && r.length === 0 && (a.reachEnd = !0) : (a.emit("local::beforeClear vlBeforeClear", a, a.fragment), a.itemsWrapEl.innerHTML = "", a.emit("local::itemsBeforeInsert vlItemsBeforeInsert", a, a.fragment), r && r.length === 0 ? (a.reachEnd = !0, a.params.emptyTemplate && (a.itemsWrapEl.innerHTML = a.params.emptyTemplate)) : a.itemsWrapEl.appendChild(a.fragment), a.emit("local::itemsAfterInsert vlItemsAfterInsert", a, a.fragment)), typeof t < "u" && e && a.$scrollableParentEl.scrollTop(t, 0), a.params.renderExternal && a.params.renderExternal(a, { fromIndex: i, toIndex: o, listHeight: a.listHeight, topPosition: d, items: u }), a.autoHeight && requestAnimationFrame(() => { a.setListSize(!0) }) } filterItems(e, t) { t === void 0 && (t = !0); const a = this; a.filteredItems = []; for (let s = 0; s < e.length; s += 1)a.filteredItems.push(a.items[e[s]]); t && (a.$scrollableParentEl[0].scrollTop = 0), a.update() } resetFilter() { const e = this; e.params.showFilteredItemsOnly ? e.filteredItems = [] : (e.filteredItems = null, delete e.filteredItems), e.update() } scrollToItem(e) { const t = this; if (e > t.items.length) return !1; let a = 0; if (t.dynamicHeight || t.autoHeight) for (let r = 0; r < e; r += 1)a += t.heights[r]; else a = e * t.params.height; const s = t.$el[0].offsetTop; return t.render(!0, s + a - parseInt(t.$scrollableParentEl.css("padding-top"), 10)), !0 } handleScroll() { this.render() } isVisible() { const e = this; return !!(e.el.offsetWidth || e.el.offsetHeight || e.el.getClientRects().length) } handleResize() { const e = this; e.isVisible() && (e.heightsCalculated = [], e.setListSize(), e.render(!0)) } appendItems(e) { const t = this; for (let a = 0; a < e.length; a += 1)t.items.push(e[a]); t.update() } appendItem(e) { this.appendItems([e]) } replaceAllItems(e) { const t = this; t.items = e, delete t.filteredItems, t.domCache = {}, t.update() } replaceItem(e, t) { const a = this; a.items[e] = t, a.params.cache && delete a.domCache[e], a.update() } prependItems(e) { const t = this; for (let a = e.length - 1; a >= 0; a -= 1)t.items.unshift(e[a]); if (t.params.cache) { const a = {}; Object.keys(t.domCache).forEach(s => { a[parseInt(s, 10) + e.length] = t.domCache[s] }), t.domCache = a } t.update() } prependItem(e) { this.prependItems([e]) } moveItem(e, t) { const a = this, s = e; let r = t; if (s === r) return; const i = a.items.splice(s, 1)[0]; if (r >= a.items.length ? (a.items.push(i), r = a.items.length - 1) : a.items.splice(r, 0, i), a.params.cache) { const o = {}; Object.keys(a.domCache).forEach(l => { const c = parseInt(l, 10), d = s < r ? s : r, u = s < r ? r : s, p = s < r ? -1 : 1; (c < d || c > u) && (o[c] = a.domCache[c]), c === d && (o[u] = a.domCache[c]), c > d && c <= u && (o[c + p] = a.domCache[c]) }), a.domCache = o } a.update() } insertItemBefore(e, t) { const a = this; if (e === 0) { a.prependItem(t); return } if (e >= a.items.length) { a.appendItem(t); return } if (a.items.splice(e, 0, t), a.params.cache) { const s = {}; Object.keys(a.domCache).forEach(r => { const i = parseInt(r, 10); i >= e && (s[i + 1] = a.domCache[i]) }), a.domCache = s } a.update() } deleteItems(e) { const t = this; let a, s = 0; for (let r = 0; r < e.length; r += 1) { let i = e[r]; typeof a < "u" && i > a && (s = -r), i += s, a = e[r]; const o = t.items.splice(i, 1)[0]; if (t.filteredItems && t.filteredItems.indexOf(o) >= 0 && t.filteredItems.splice(t.filteredItems.indexOf(o), 1), t.params.cache) { const l = {}; Object.keys(t.domCache).forEach(c => { const d = parseInt(c, 10); d === i ? delete t.domCache[i] : parseInt(c, 10) > i ? l[d - 1] = t.domCache[c] : l[d] = t.domCache[c] }), t.domCache = l } } t.update() } deleteAllItems() { const e = this; e.items = [], delete e.filteredItems, e.params.cache && (e.domCache = {}), e.update() } deleteItem(e) { this.deleteItems([e]) } clearCache() { const e = this; e.domCache = {} } update(e) { const t = this; e && t.params.cache && (t.domCache = {}), t.heightsCalculated = [], t.setListSize(), t.render(!0) } init() { const e = this; e.attachEvents(), e.setListSize(), e.render() } destroy() { let e = this; e.detachEvents(), e.$el[0].f7VirtualList = null, delete e.$el[0].f7VirtualList, ve(e), e = null }
}; const Dl = { name: "virtualList", static: { VirtualList: Sn }, create() { const n = this; n.virtualList = we({ defaultSelector: ".virtual-list", constructor: Sn, app: n, domProp: "f7VirtualList" }) } }; let Mn = class extends me {
  constructor(e, t) {
    t === void 0 && (t = {}), super(t, [e]); const a = this, s = {
      el: null, listEl: null, indexes: "auto", iosItemHeight: 14, mdItemHeight: 14, scrollList: !0, label: !1, renderItem(C, k) {
        return `
          <li>${C}</li>
        `.trim()
      }, renderSkipPlaceholder() { return '<li class="list-index-skip-placeholder"></li>' }, on: {}
    }; a.useModulesParams(s), a.params = R(s, t); let r, i, o, l; if (a.params.el) r = y(a.params.el); else return a; if (r[0].f7ListIndex) return r[0].f7ListIndex; if (l = r.find("ul"), l.length === 0 && (l = y("<ul></ul>"), r.append(l)), a.params.listEl && (i = y(a.params.listEl)), a.params.indexes === "auto" && !i) return a; i ? o = i.parents(".page-content").eq(0) : (o = r.siblings(".page-content").eq(0), o.length === 0 && (o = r.parents(".page").eq(0).find(".page-content").eq(0))), r[0].f7ListIndex = a, R(a, { app: e, $el: r, el: r && r[0], $ul: l, ul: l && l[0], $listEl: i, listEl: i && i[0], $pageContentEl: o, pageContentEl: o && o[0], indexes: t.indexes, height: 0, skipRate: 0 }), a.useModules(); function c() { const C = { index: a }; a.calcSize(), C !== a.height && a.render() } function d(C) { const k = y(C.target).closest("li"); if (!k.length) return; let M = k.index(); if (a.skipRate > 0) { const O = M / (k.siblings("li").length - 1); M = Math.round((a.indexes.length - 1) * O) } const A = a.indexes[M]; a.$el.trigger("listindex:click", { content: A, index: M }), a.emit("local::click listIndexClick", a, A, M), a.$el.trigger("listindex:select", { content: A, index: M }), a.emit("local::select listIndexSelect", a, A, M), a.$listEl && a.params.scrollList && a.scrollListToIndex(A, M) } const u = {}; let p, m, f, h, b, g = null; function v(C) { const k = l.children(); k.length && (f = k[0].getBoundingClientRect().top, h = k[k.length - 1].getBoundingClientRect().top + k[0].offsetHeight, u.x = C.type === "touchstart" ? C.targetTouches[0].pageX : C.pageX, u.y = C.type === "touchstart" ? C.targetTouches[0].pageY : C.pageY, p = !0, m = !1, g = null) } function E(C) { if (!p) return; !m && a.params.label && (b = y('<span class="list-index-label"></span>'), r.append(b)), m = !0; const k = C.type === "touchmove" ? C.targetTouches[0].pageY : C.pageY; C.preventDefault(); let M = (k - f) / (h - f); M = Math.min(Math.max(M, 0), 1); const A = Math.round((a.indexes.length - 1) * M), O = a.indexes[A], S = h - f, P = (a.height - S) / 2 + (1 - M) * S; A !== g && (a.params.label && b.html(O).transform(`translateY(-${P}px)`), a.$listEl && a.params.scrollList && a.scrollListToIndex(O, A)), g = A, a.$el.trigger("listindex:select"), a.emit("local::select listIndexSelect", a, O, A) } function $() { p && (p = !1, m = !1, a.params.label && (b && b.remove(), b = void 0)) } const w = Ee().passiveListener ? { passive: !0 } : !1; return a.attachEvents = function () { r.parents(".tab").on("tab:show", c), r.parents(".page").on("page:reinit", c), r.parents(".panel").on("panel:open", c), r.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").on("modal:open", c), e.on("resize", c), r.on("click", d), r.on(e.touchEvents.start, v, w), e.on("touchmove:active", E), e.on("touchend:passive", $) }, a.detachEvents = function () { r.parents(".tab").off("tab:show", c), r.parents(".page").off("page:reinit", c), r.parents(".panel").off("panel:open", c), r.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").off("modal:open", c), e.off("resize", c), r.off("click", d), r.off(e.touchEvents.start, v, w), e.off("touchmove:active", E), e.off("touchend:passive", $) }, a.init(), a
  } scrollListToIndex(e, t) { const a = this, { $listEl: s, $pageContentEl: r, app: i } = a; if (!s || !r || r.length === 0) return a; let o; if (s.find(".list-group-title").each(p => { if (o) return; const m = y(p); m.text() === e && (o = m) }), !o || o.length === 0) return a; const l = o.parent().offset().top; let c = parseInt(r.css("padding-top"), 10); const d = r[0].scrollTop, u = o.offset().top; if (r.parents(".page-with-navbar-large").length) { const p = i.navbar.getElByPage(r.parents(".page-with-navbar-large").eq(0)), m = y(p).find(".title-large"); m.length && (c -= m[0].offsetHeight || 0) } return l <= c ? r.scrollTop(l + d - c) : r.scrollTop(u + d - c), a } renderSkipPlaceholder() { const e = this; return e.params.renderSkipPlaceholder.call(e) } renderItem(e, t) { const a = this; return a.params.renderItem.call(a, e, t) } render() { const e = this, { $ul: t, indexes: a, skipRate: s } = e; let r; const i = a.map((o, l) => { if (l % s !== 0 && s > 0) return r = !0, ""; let c = e.renderItem(o, l); return r && (c = e.renderSkipPlaceholder() + c), r = !1, c }).join(""); return t.html(i), e } calcSize() { const e = this, { app: t, params: a, el: s, indexes: r } = e, i = s.offsetHeight, o = a[`${t.theme}ItemHeight`], l = Math.floor(i / o), c = r.length; let d = 0; return c > l && (d = Math.ceil((c * 2 - 1) / l)), e.height = i, e.skipRate = d, e } calcIndexes() { const e = this; return e.params.indexes === "auto" ? (e.indexes = [], e.$listEl.find(".list-group-title").each(t => { const a = y(t).text(); e.indexes.indexOf(a) < 0 && e.indexes.push(a) })) : e.indexes = e.params.indexes, e } update() { const e = this; return e.calcIndexes(), e.calcSize(), e.render(), e } init() { const e = this; e.calcIndexes(), e.calcSize(), e.render(), e.attachEvents() } destroy() { let e = this; e.$el.trigger("listindex:beforedestroy", e), e.emit("local::beforeDestroy listIndexBeforeDestroy"), e.detachEvents(), e.$el[0] && (e.$el[0].f7ListIndex = null, delete e.$el[0].f7ListIndex), ve(e), e = null }
}; const Ll = { name: "listIndex", static: { ListIndex: Mn }, create() { const n = this; n.listIndex = we({ defaultSelector: ".list-index", constructor: Mn, app: n, domProp: "f7ListIndex" }) }, on: { tabMounted(n) { const e = this; y(n).find(".list-index-init").each(t => { const a = R(y(t).dataset(), { el: t }); e.listIndex.create(a) }) }, tabBeforeRemove(n) { y(n).find(".list-index-init").each(e => { e.f7ListIndex && e.f7ListIndex.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".list-index-init").each(t => { const a = R(y(t).dataset(), { el: t }); e.listIndex.create(a) }) }, pageBeforeRemove(n) { n.$el.find(".list-index-init").each(e => { e.f7ListIndex && e.f7ListIndex.destroy() }) } }, vnode: { "list-index-init": { insert(n) { const e = this, t = n.elm, a = R(y(t).dataset(), { el: t }); e.listIndex.create(a) }, destroy(n) { const e = n.elm; e.f7ListIndex && e.f7ListIndex.destroy() } } } }, Rl = { name: "timeline" }, Hl = { show() { const n = this; let e, t, a, s, r; for (var i = arguments.length, o = new Array(i), l = 0; l < i; l++)o[l] = arguments[l]; o.length === 1 && o[0] && o[0].constructor === Object ? (e = o[0].tabEl, t = o[0].tabLinkEl, a = o[0].animate, s = o[0].tabRoute, r = o[0].animatedInit) : ([e, t, a, s] = o, typeof o[1] == "boolean" && ([e, a, t, s] = o, o.length > 2 && t.constructor === Object && ([e, a, s, t] = o))), typeof a > "u" && (a = !0); const c = y(e); if (s && c[0] && (c[0].f7TabRoute = s), !r && (c.length === 0 || c.hasClass("tab-active"))) return { $newTabEl: c, newTabEl: c[0] }; let d; t && (d = y(t)); const u = c.parent(".tabs"); if (u.length === 0) return { $newTabEl: c, newTabEl: c[0] }; n.swipeout && (n.swipeout.allowOpen = !0); const p = []; function m(v) { p.push(v) } function f() { p.forEach(v => { v() }) } let h = !1; if (u.parent().hasClass("tabs-animated-wrap")) { u.parent()[a ? "removeClass" : "addClass"]("not-animated"); const v = parseFloat(u.css("transition-duration").replace(",", ".")); a && v && (u.transitionEnd(f), h = !0); const E = (n.rtl ? c.index() : -c.index()) * 100; u.transform(`translate3d(${E}%,0,0)`) } let b; if (u[0].nodeName.toLowerCase() === "swiper-container" && n.swiper) { b = u[0].swiper; const v = b.slides.indexOf(c[0]); b && b.activeIndex !== v ? (h = !0, b.once("slideChangeTransitionEnd", () => { f() }).slideTo(v, a ? void 0 : 0)) : b && b.animating && (h = !0, b.once("slideChangeTransitionEnd", () => { f() })) } const g = u.children(".tab-active"); if (g.removeClass("tab-active"), !r && (!b || b && !b.animating || b && s) && (g.hasClass("view") && g.children(".page").length && g.children(".page").each(v => { y(v).trigger("page:tabhide"), n.emit("pageTabHide", v) }), g.trigger("tab:hide"), n.emit("tabHide", g[0])), c.addClass("tab-active"), !r && (!b || b && !b.animating || b && s) && (c.hasClass("view") && c.children(".page").length && c.children(".page").each(v => { y(v).trigger("page:tabshow"), n.emit("pageTabShow", v) }), c.trigger("tab:show"), n.emit("tabShow", c[0])), !d && (typeof e == "string" ? d = y(`.tab-link[href="${e}"]`) : d = y(`.tab-link[href="#${c.attr("id")}"]`), (!d || d && d.length === 0) && y("[data-tab]").each(v => { c.is(y(v).attr("data-tab")) && (d = y(v)) }), s && (!d || d && d.length === 0) && (d = y(`[data-route-tab-id="${s.route.tab.id}"]`), d.length === 0 && (d = y(`.tab-link[href="${s.url}"]`))), d.length > 1 && c.parents(".page").length && (d = d.filter(v => y(v).parents(".page")[0] === c.parents(".page")[0]), n.theme === "ios" && d.length === 0 && s))) { const v = c.parents(".page"), E = y(n.navbar.getElByPage(v)); d = E.find(`[data-route-tab-id="${s.route.tab.id}"]`), d.length === 0 && (d = E.find(`.tab-link[href="${s.url}"]`)) } if (d.length > 0) { let v; if (g && g.length > 0) { const E = g.attr("id"); E && (v = y(`.tab-link[href="#${E}"]`), (!v || v && v.length === 0) && (v = y(`.tab-link[data-route-tab-id="${E}"]`))), (!v || v && v.length === 0) && y("[data-tab]").each($ => { g.is(y($).attr("data-tab")) && (v = y($)) }), (!v || v && v.length === 0) && (v = d.siblings(".tab-link-active")) } else s && (v = d.siblings(".tab-link-active")); if (v && v.length > 1 && g && g.parents(".page").length && (v = v.filter(E => y(E).parents(".page")[0] === g.parents(".page")[0])), v && v.length > 0 && v.removeClass("tab-link-active"), d && d.length > 0) { d.addClass("tab-link-active"); const E = d.parents(".tabbar, .tabbar-icons"); n.toolbar && E.length > 0 && (E.hasClass("tabbar-highlight") || n.theme !== "ios") && n.toolbar.setHighlight(E) } } return { $newTabEl: c, newTabEl: c[0], $oldTabEl: g, oldTabEl: g[0], onTabsChanged: m, animated: h } } }, zl = { name: "tabs", create() { const n = this; R(n, { tab: { show: Hl.show.bind(n) } }) }, on: { "pageInit tabMounted": function (e) { const a = y(e.el || e).find(".tabs-animated-wrap > .tabs > .tab-active")[0]; if (!a) return; this.tab.show({ tabEl: a, animatedInit: !0, animate: !1 }) } }, clicks: { ".tab-link": function (e, t) { t === void 0 && (t = {}), (e.attr("href") && e.attr("href").indexOf("#") === 0 || e.attr("data-tab")) && this.tab.show({ tabEl: t.tab || e.attr("href"), tabLinkEl: e, animate: t.animate }) } } }; function Fl(n) { const e = n.app; if (n.swipeInitialized) return; R(n, { swipeable: !0, swipeInitialized: !0 }); const t = n.params, { $el: a, $backdropEl: s, side: r, effect: i } = n; let o, l, c, d, u, p; const m = {}; let f, h, b, g, v, E, $, w = 0; function C(S) { if (!n.swipeable || c || !e.panel.allowOpen || !t.swipe && !t.swipeOnlyClose || l || y(".modal-in:not(.toast):not(.notification), .photo-browser-in").length > 0) return; o = e.panel.get(r === "left" ? "right" : "left") || {}; const P = o.opened && o.$el && !o.$el.hasClass("panel-in-breakpoint"); !n.opened && P || !t.swipeOnlyClose && P || S.target && S.target.nodeName.toLowerCase() === "input" && S.target.type === "range" || y(S.target).closest(".range-slider, swiper-container.tabs, .calendar-months, .no-swipe-panel, .card-opened").length > 0 || (m.x = S.type === "touchstart" ? S.targetTouches[0].pageX : S.pageX, m.y = S.type === "touchstart" ? S.targetTouches[0].pageY : S.pageY, !(t.swipeOnlyClose && !n.opened) && (t.swipeActiveArea && !n.opened && (r === "left" && m.x > t.swipeActiveArea || r === "right" && m.x < e.width - t.swipeActiveArea) || (w = 0, $ = y(n.getViewEl()), d = !1, l = !0, u = void 0, p = !1, f = Ie(), E = void 0))) } function k(S) { if (!l || c || p || (w += 1, w < 2)) return; if (S.f7PreventSwipePanel || e.preventSwipePanelBySwipeBack || e.preventSwipePanel) { l = !1; return } const P = S.type === "touchmove" ? S.targetTouches[0].pageX : S.pageX, T = S.type === "touchmove" ? S.targetTouches[0].pageY : S.pageY; if (typeof u > "u" && (u = !!(u || Math.abs(T - m.y) > Math.abs(P - m.x))), u) { l = !1; return } if (!E) { if (P > m.x ? E = "to-right" : E = "to-left", t.swipeActiveArea > 0 && !n.opened) { if (r === "left" && m.x > t.swipeActiveArea) { l = !1; return } if (r === "right" && m.x < e.width - t.swipeActiveArea) { l = !1; return } } if (a.hasClass("panel-in-breakpoint")) { l = !1; return } if (r === "left" && E === "to-left" && !a.hasClass("panel-in") || r === "right" && E === "to-right" && !a.hasClass("panel-in")) { l = !1; return } } let I = n.opened ? 0 : -t.swipeThreshold; r === "right" && (I = -I), d || (n.opened || (n.insertToRoot(), a.addClass("panel-in-swipe"), s && s.css("visibility", "visible"), a.trigger("panel:swipeopen"), n.emit("local::swipeOpen panelSwipeOpen", n)), v = a[0].offsetWidth, i === "reveal" && a.hasClass("panel-in-collapsed") && (v -= parseFloat($.css(`margin-${r}`))), a.transition(0)), d = !0, S.cancelable && S.preventDefault(), h = P - m.x + I; const H = i === "floating" ? 8 : 0; r === "right" ? i === "cover" || i === "push" || i === "floating" ? (b = h + (n.opened ? H : v), b < 0 - H && (b = -H), b > v && (b = v)) : (b = h - (n.opened ? v : 0), b > 0 && (b = 0), b < -v && (b = -v)) : (b = h + (n.opened ? v : H), b < 0 && (b = 0), b > v + H && (b = v + H)); const D = Math.abs(b / v); if (i === "reveal") t.swipeNoFollow || ($.transform(`translate3d(${b}px,0,0)`).transition(0), s && s.transform(`translate3d(${b}px,0,0)`).transition(0)), a.trigger("panel:swipe", Math.abs(b / v)), n.emit("local::swipe panelSwipe", n, Math.abs(b / v)); else { if (r === "left" && (b -= v), !t.swipeNoFollow && (g = 1 - Math.abs(b / v), s && (s.transition(0), s.css({ opacity: g })), a.transform(`translate3d(${b}px,0,0)`).transition(0), i === "push")) { const z = r === "left" ? b + v : b - v; $.transform(`translate3d(${z}px,0,0)`).transition(0), s && s.transform(`translate3d(${z}px,0,0)`).transition(0) } a.trigger("panel:swipe", Math.abs(b / v)), n.emit("local::swipe panelSwipe", n, Math.abs(b / v)) } t.swipeNoFollow && (n.opened && D === 0 || !n.opened && D === 1) && (p = !0, M(S)) } function M(S) { if (!l || !d) { l = !1, d = !1; return } const P = S.type === "gesturestart" || c; l = !1, d = !1; const T = new Date().getTime() - f; let I; const H = i === "floating" ? r === "left" ? 8 : -8 : 0, D = (b === H || Math.abs(b) === v) && !t.swipeNoFollow, z = t.swipeThreshold || 0; P ? I = "reset" : n.opened ? i === "cover" || i === "push" || i === "floating" ? b === 0 ? I = "reset" : T < 300 && Math.abs(b) > 0 ? I = "swap" : T >= 300 && Math.abs(b) < v / 2 ? I = "reset" : I = "swap" : b === -v ? I = "reset" : T < 300 && Math.abs(b) >= 0 || T >= 300 && Math.abs(b) <= v / 2 ? r === "left" && b === v ? I = "reset" : I = "swap" : I = "reset" : Math.abs(h) < z ? I = "reset" : i === "cover" || i === "push" || i === "floating" ? b === 0 + H || T < 300 && Math.abs(b) > 0 || T >= 300 && Math.abs(b) < v / 2 ? I = "swap" : I = "reset" : b === 0 ? I = "reset" : T < 300 && Math.abs(b) > 0 || T >= 300 && Math.abs(b) >= v / 2 ? I = "swap" : I = "reset", I === "swap" && (n.opened ? n.close(!D) : n.open(!D)); let B = !0; if (I === "reset" && !n.opened) if (D) a.removeClass("panel-in-swipe"); else { B = !1; const L = i === "reveal" ? $ : a; n.setStateClasses("before-closing"), L.transitionEnd(() => { a.hasClass("panel-in") || (a.removeClass("panel-in-swipe"), n.setStateClasses("after-closing")) }) } (i === "reveal" || i === "push") && Ae(() => { $.transition(""), $.transform("") }), B && a.removeClass("panel-in-swipe"), a.transition("").transform(""), s && s.transform("").transition("").css({ opacity: "", visibility: "" }) } function A(S) { c = !0, M(S) } function O() { c = !1 } e.on("touchstart:passive", C), e.on("touchmove:active", k), e.on("touchend:passive", M), e.on("gesturestart", A), e.on("gestureend", O), n.on("panelDestroy", () => { e.off("touchstart:passive", C), e.off("touchmove:active", k), e.off("touchend:passive", M), e.off("gesturestart", A), e.off("gestureend", O) }) } function Vl(n) { const e = n.app, t = Ee(); if (n.resizableInitialized) return; R(n, { resizable: !0, resizableWidth: null, resizableInitialized: !0 }); const a = y("html"), { $el: s, $backdropEl: r, side: i, effect: o } = n; if (!s) return; let l, c; const d = {}; let u, p, m, f, h, b; function g(M) { if (!M) return null; if (M.indexOf("%") >= 0 || M.indexOf("vw") >= 0) return parseInt(M, 10) / 100 * e.width; const A = parseInt(M, 10); return Number.isNaN(A) ? null : A } function v() { return n.resizable && s.hasClass("panel-resizable") } function E(M) { v() && (d.x = M.type === "touchstart" ? M.targetTouches[0].pageX : M.pageX, d.y = M.type === "touchstart" ? M.targetTouches[0].pageY : M.pageY, c = !1, l = !0, f = g(s.css("min-width")), h = g(s.css("max-width")), b = s.hasClass("panel-in-breakpoint")) } function $(M) { if (!l) return; const A = M.type === "touchmove" ? M.targetTouches[0].pageX : M.pageX; c || (p = s[0].offsetWidth, s.transition(0), s.addClass("panel-resizing"), a.css("cursor", "col-resize"), (o !== "cover" || b) && (m = y(n.getViewEl()), n.$containerEl && n.$containerEl.hasClass("page") && m.add(n.$containerEl.children(".page-content, .tabs, .fab"))), o !== "cover" && !b && (r.transition(0), m.transition(0))), c = !0, M.preventDefault(), u = A - d.x; let O = i === "left" ? p + u : p - u; f && !Number.isNaN(f) && (O = Math.max(O, f)), h && !Number.isNaN(h) && (O = Math.min(O, h)), O = Math.min(Math.max(O, 0), e.width), n.resizableWidth = O, s[0].style.width = `${O}px`, o !== "cover" && !b ? (m && m.transform(`translate3d(${i === "left" ? O : -O}px, 0, 0)`), r && r.transform(`translate3d(${i === "left" ? O : -O}px, 0, 0)`)) : b && m && m.css(`margin-${i}`, `${O}px`), s.trigger("panel:resize", O), n.emit("local::resize panelResize", n, O) } function w() { if (y("html").css("cursor", ""), !l || !c) { l = !1, c = !1; return } l = !1, c = !1, a[0].style.setProperty(`--f7-panel-${i}-width`, `${n.resizableWidth}px`), s[0].style.width = "", o !== "cover" && !b && (m.transform(""), r.transform("")), s.removeClass("panel-resizing"), Ae(() => { s.transition(""), o !== "cover" && (r.transition(""), m && m.transition("")) }) } function C() { !n.opened || !n.resizableWidth || (f = g(s.css("min-width")), h = g(s.css("max-width")), f && !Number.isNaN(f) && n.resizableWidth < f && (n.resizableWidth = Math.max(n.resizableWidth, f)), h && !Number.isNaN(h) && n.resizableWidth > h && (n.resizableWidth = Math.min(n.resizableWidth, h)), n.resizableWidth = Math.min(Math.max(n.resizableWidth, 0), e.width), a[0].style.setProperty(`--f7-panel-${i}-width`, `${n.resizableWidth}px`)) } n.$el.find(".panel-resize-handler").length === 0 && n.$el.append('<div class="panel-resize-handler"></div>'), n.$resizeHandlerEl = n.$el.children(".panel-resize-handler"), s.addClass("panel-resizable"); const k = t.passiveListener ? { passive: !0 } : !1; n.$el.on(e.touchEvents.start, ".panel-resize-handler", E, k), e.on("touchmove:active", $), e.on("touchend:passive", w), e.on("resize", C), n.on("beforeOpen", C), n.once("panelDestroy", () => { s.removeClass("panel-resizable"), n.$resizeHandlerEl.remove(), n.$el.off(e.touchEvents.start, ".panel-resize-handler", E, k), e.off("touchmove:active", $), e.off("touchend:passive", w), e.off("resize", C), n.off("beforeOpen", C) }) } let ba = class extends me { constructor(e, t) { t === void 0 && (t = {}); const a = R({ on: {} }, e.params.panel, t); super(a, [e]); const s = this; s.params = a, s.$containerEl = s.params.containerEl ? y(s.params.containerEl).eq(0) : e.$el, s.containerEl = s.$containerEl[0], s.containerEl || (s.$containerEl = e.$el, s.containerEl = e.$el[0]); let r; if (s.params.el ? r = y(s.params.el).eq(0) : s.params.content && (r = y(s.params.content).filter(d => d.nodeType === 1).eq(0)), r.length === 0) return s; if (r[0].f7Panel) return r[0].f7Panel; r[0].f7Panel = s; let { side: i, effect: o, resizable: l } = s.params; typeof i > "u" && (i = r.hasClass("panel-left") ? "left" : "right"), typeof o > "u" && (o = r.hasClass("panel-cover") ? "cover" : r.hasClass("panel-push") ? "push" : r.hasClass("panel-floating") ? "floating" : "reveal"), typeof l > "u" && (l = r.hasClass("panel-resizable")); let c; return s.params.backdrop && s.params.backdropEl ? c = y(s.params.backdropEl) : s.params.backdrop && (c = s.$containerEl.children(".panel-backdrop"), c.length === 0 && (c = y('<div class="panel-backdrop"></div>'), s.$containerEl.prepend(c))), R(s, { app: e, side: i, effect: o, resizable: l, $el: r, el: r[0], opened: !1, $backdropEl: c, backdropEl: c && c[0] }), s.useModules(), s.init(), s } getViewEl() { const e = this; let t; return e.$containerEl.children(".views").length > 0 ? t = e.$containerEl.children(".views")[0] : t = e.$containerEl.children(".view")[0], t } setStateClasses(e) { const t = this, { side: a, el: s, effect: r } = t, i = t.getViewEl(), o = i && i.contains(s), l = !i || o ? t.$containerEl : y("html"); e === "open" && l.addClass(`with-panel with-panel-${t.side}-${t.effect}`), e === "before-closing" && l.addClass("with-panel-closing"), e === "closing" && (l.addClass("with-panel-closing"), l.removeClass(`with-panel with-panel-${t.side}-${t.effect}`)), e === "after-closing" && l.removeClass("with-panel-closing"), e === "closed" && l.removeClass(`with-panel-${a}-${r}`) } enableVisibleBreakpoint() { const e = this; return e.visibleBreakpointDisabled = !1, e.setVisibleBreakpoint(), e } disableVisibleBreakpoint() { const e = this; return e.visibleBreakpointDisabled = !0, e.setVisibleBreakpoint(), e } toggleVisibleBreakpoint() { const e = this; return e.visibleBreakpointDisabled = !e.visibleBreakpointDisabled, e.setVisibleBreakpoint(), e } setVisibleBreakpoint(e) { e === void 0 && (e = !0); const t = this, a = t.app; t.visibleBreakpointResizeHandler || (t.visibleBreakpointResizeHandler = function () { t.setVisibleBreakpoint() }, a.on("resize", t.visibleBreakpointResizeHandler)); const { side: s, $el: r, $containerEl: i, params: o, visibleBreakpointDisabled: l } = t, c = o.visibleBreakpoint, d = y(t.getViewEl()), u = r.hasClass("panel-in-breakpoint"); i && i.hasClass("page") && d.add(i.children(".page-content, .tabs, .fab")), a.width >= c && typeof c < "u" && c !== null && !l ? u ? d.css({ [`margin-${s}`]: `${r.width()}px` }) : (t.setStateClasses("closed"), r.addClass("panel-in-breakpoint").removeClass("panel-in panel-in-collapsed"), t.onOpen(!1), t.onOpened(), d.css({ [`margin-${s}`]: `${r.width()}px` }), a.allowPanelOpen = !0, e && (t.emit("local::breakpoint panelBreakpoint", t), t.$el.trigger("panel:breakpoint"))) : u && (r.removeClass("panel-in-breakpoint panel-in"), t.onClose(), t.onClosed(), d.css({ [`margin-${s}`]: "" }), e && (t.emit("local::breakpoint panelBreakpoint", t), t.$el.trigger("panel:breakpoint"))) } enableCollapsedBreakpoint() { const e = this; return e.collapsedBreakpointDisabled = !1, e.setCollapsedBreakpoint(), e } disableCollapsedBreakpoint() { const e = this; return e.collapsedBreakpointDisabled = !0, e.setCollapsedBreakpoint(), e } toggleCollapsedBreakpoint() { const e = this; return e.collapsedBreakpointDisabled = !e.collapsedBreakpointDisabled, e.setCollapsedBreakpoint(), e } setCollapsedBreakpoint(e) { e === void 0 && (e = !0); const t = this, a = t.app; t.collapsedBreakpointResizeHandler || (t.collapsedBreakpointResizeHandler = function () { t.setCollapsedBreakpoint() }, a.on("resize", t.collapsedBreakpointResizeHandler)); const { $el: s, params: r, collapsedBreakpointDisabled: i } = t; if (s.hasClass("panel-in-breakpoint")) return; const o = r.collapsedBreakpoint, l = s.hasClass("panel-in-collapsed"); a.width >= o && typeof o < "u" && o !== null && !i ? l || (t.setStateClasses("closed"), s.addClass("panel-in-collapsed").removeClass("panel-in"), t.collapsed = !0, a.allowPanelOpen = !0, e && (t.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", t), t.$el.trigger("panel:collapsedbreakpoint"))) : l && (s.removeClass("panel-in-collapsed panel-in"), t.collapsed = !1, e && (t.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", t), t.$el.trigger("panel:collapsedbreakpoint"))) } enableResizable() { const e = this; return e.resizableInitialized ? (e.resizable = !0, e.$el.addClass("panel-resizable")) : Vl(e), e } disableResizable() { const e = this; return e.resizable = !1, e.$el.removeClass("panel-resizable"), e } enableSwipe() { const e = this; return e.swipeInitialized ? e.swipeable = !0 : Fl(e), e } disableSwipe() { const e = this; return e.swipeable = !1, e } onOpen(e) { e === void 0 && (e = !0); const t = this; t._openTransitionStarted = !1; const a = t.app; t.opened = !0, a.panel.allowOpen = !1, t.$el.trigger("panel:beforeopen"), t.emit("local::beforeOpen panelBeforeOpen", t), e && t.setStateClasses("open"), t.$el.trigger("panel:open"), t.emit("local::open panelOpen", t) } onOpened() { const e = this, t = e.app; t.panel.allowOpen = !0, e.$el.trigger("panel:opened"), e.emit("local::opened panelOpened", e) } onClose() { const e = this, t = e.app; e.opened = !1, t.panel.allowOpen = !1, e.$el.trigger("panel:beforeclose"), e.emit("local::beforeClose panelBeforeClose", e), e.setStateClasses("closing"), e.$el.trigger("panel:close"), e.emit("local::close panelClose", e) } onClosed() { const e = this, t = e.app; if (t.panel.allowOpen = !0, e.setStateClasses("after-closing"), e.$el.removeClass("panel-out"), e.$backdropEl) { const a = t.panel.get(".panel-in"); (!a || a && !a.$backdropEl) && e.$backdropEl.removeClass("panel-backdrop-in") } e.$el.trigger("panel:closed"), e.emit("local::closed panelClosed", e) } toggle(e) { e === void 0 && (e = !0); const t = this, a = t.params.visibleBreakpoint; return t.app.width >= a && typeof a < "u" && a !== null ? t.toggleVisibleBreakpoint() : (t.opened ? t.close(e) : t.open(e), t) } insertToRoot() { const e = this, t = ee(), { $el: a, $backdropEl: s, $containerEl: r } = e, i = a.parent(), o = a.parents(t).length > 0; if (!i.is(r) || a.prevAll(".views, .view").length) { const l = r.children(".panel, .views, .view").eq(0), c = r.children(".panel-backdrop").eq(0); l.length ? a.insertBefore(l) : c ? a.insertBefore(c) : r.prepend(a), s && s.length && (!s.parent().is(r) && s.nextAll(".panel").length === 0 || s.parent().is(r) && s.nextAll(".panel").length === 0) && s.insertBefore(a), e.once("panelClosed", () => { o ? i.append(a) : a.remove() }) } } open(e) { e === void 0 && (e = !0); const t = this, a = t.app; if (!a.panel.allowOpen) return !1; const { effect: s, $el: r, $backdropEl: i, opened: o, $containerEl: l } = t; if (!r || r.hasClass("panel-in")) return t; if (t.insertToRoot(), o || r.hasClass("panel-in-breakpoint") || r.hasClass("panel-in")) return !1; const c = a.panel.get(".panel-in"); c && c !== t && c.close(e), r[e ? "removeClass" : "addClass"]("not-animated"), r.addClass("panel-in"), i && (i.addClass("panel-backdrop-in"), i[e ? "removeClass" : "addClass"]("not-animated")), ["cover", "push", "floating"].includes(t.effect) && (t._clientLeft = r[0].clientLeft); const d = y(t.getViewEl()); l && l.hasClass("page") && d.add(l.children(".page-content, .tabs")); const u = s === "reveal" ? d : r; function p() { u.transitionStart(() => { t._openTransitionStarted = !0 }) } function m() { u.transitionEnd(f => { y(f.target).is(u) ? r.hasClass("panel-out") ? t.onClosed() : t.onOpened() : m() }) } return e ? (i && i.removeClass("not-animated"), p(), m(), r.removeClass("panel-out not-animated").addClass("panel-in"), t.onOpen()) : (i && i.addClass("not-animated"), r.removeClass("panel-out").addClass("panel-in not-animated"), t.onOpen(), t.onOpened()), !0 } close(e) { e === void 0 && (e = !0); const t = this, { effect: a, $el: s, $backdropEl: r, opened: i, $containerEl: o } = t; if (!i || s.hasClass("panel-in-breakpoint") || !s.hasClass("panel-in")) return t; s[e ? "removeClass" : "addClass"]("not-animated"), r && r[e ? "removeClass" : "addClass"]("not-animated"); const l = y(t.getViewEl()); o && o.hasClass("page") && l.add(o.children(".page-content, .tabs")); const c = a === "reveal" ? l : s; t._openTransitionStarted || (e = !1); function d() { s.hasClass("panel-out") ? t.onClosed() : s.hasClass("panel-in") && t.onOpened(), t.setStateClasses("after-closing") } return e ? (c.transitionEnd(() => { d() }), s.removeClass("panel-in").addClass("panel-out"), t.onClose()) : (s.addClass("not-animated").removeClass("panel-in").addClass("panel-out"), t.onClose(), t.onClosed()), t } init() { const e = this; typeof e.params.visibleBreakpoint < "u" && e.setVisibleBreakpoint(), typeof e.params.collapsedBreakpoint < "u" && e.setCollapsedBreakpoint(), e.params.swipe && e.enableSwipe(), e.resizable && e.enableResizable() } destroy() { let e = this; const t = e.app, { $containerEl: a } = e; if (e.$el) { if (e.emit("local::beforeDestroy panelBeforeDestroy", e), e.$el.trigger("panel:beforedestroy"), e.visibleBreakpointResizeHandler && t.off("resize", e.visibleBreakpointResizeHandler), e.collapsedBreakpointResizeHandler && t.off("resize", e.collapsedBreakpointResizeHandler), e.$el.hasClass("panel-in-breakpoint") || e.$el.hasClass("panel-in-collapsed")) { const s = y(e.getViewEl()); a && a.hasClass("page") && s.add(a.children(".page-content, .tabs")), e.$el.removeClass("panel-in-breakpoint panel-in-collapsed panel-in"), s.css({ [`margin-${e.side}`]: "" }), e.emit("local::breakpoint panelBreakpoint", e), e.$el.trigger("panel:breakpoint") } e.$el.trigger("panel:destroy"), e.emit("local::destroy panelDestroy", e), e.el && (e.el.f7Panel = null, delete e.el.f7Panel), ve(e), e = null } } }; const Nl = { name: "panel", params: { panel: { opened: void 0, side: void 0, effect: void 0, resizable: void 0, backdrop: !0, backdropEl: void 0, visibleBreakpoint: void 0, collapsedBreakpoint: void 0, swipe: !1, swipeNoFollow: !1, swipeOnlyClose: !1, swipeActiveArea: 0, swipeThreshold: 0, closeByBackdropClick: !0, containerEl: void 0 } }, static: { Panel: ba }, create() { const n = this; R(n, { panel: { allowOpen: !0, create(e) { return new ba(n, e) }, get(e) { if (e === void 0 && (e = ".panel"), e instanceof ba) return e; (e === "left" || e === "right") && (e = `.panel-${e}`); const t = y(e); if (!(t.length === 0 || t.length > 1)) return t[0].f7Panel }, destroy(e) { e === void 0 && (e = ".panel"); const t = n.panel.get(e); if (t && t.destroy) return t.destroy() }, open(e, t) { e === void 0 && (e = ".panel"), (e === "left" || e === "right") && (e = `.panel-${e}`); let a = n.panel.get(e); if (a && a.open) return a.open(t); if (!a) return a = n.panel.create({ el: e }), a.open(t) }, close(e, t) { e === void 0 && (e = ".panel-in"), (e === "left" || e === "right") && (e = `.panel-${e}`); let a = n.panel.get(e); if (a && a.open) return a.close(t); if (!a) return a = n.panel.create({ el: e }), a.close(t) }, toggle(e, t) { e === void 0 && (e = ".panel"), (e === "left" || e === "right") && (e = `.panel-${e}`); let a = n.panel.get(e); if (a && a.toggle) return a.toggle(t); if (!a) return a = n.panel.create({ el: e }), a.toggle(t) } } }) }, on: { init() { const n = this; y(".panel-init").each(e => { const t = Object.assign({ el: e }, y(e).dataset() || {}); n.panel.create(t) }) }, pageInit(n) { const e = this; n.$el.find(".panel-init").each(t => { const a = Object.assign({ el: t }, y(t).dataset() || {}); e.panel.create(a) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".panel-init").each(t => { const a = e.panel.get(t); a && a.destroy && a.destroy() }) } }, vnode: { "panel-init": { insert(n) { const e = this, t = n.elm, a = Object.assign({ el: t }, y(t).dataset() || {}); e.panel.create(a) }, destroy(n) { const e = this, t = n.elm, a = e.panel.get(t); a && a.destroy && a.destroy() } } }, clicks: { ".panel-open": function (e, t) { t === void 0 && (t = {}), this.panel.open(t.panel, t.animate) }, ".panel-close": function (e, t) { t === void 0 && (t = {}), this.panel.close(t.panel, t.animate) }, ".panel-toggle": function (e, t) { t === void 0 && (t = {}), this.panel.toggle(t.panel, t.animate) }, ".panel-backdrop": function () { const e = this, t = y(".panel-in:not(.panel-out)"); if (!t.length) return; const a = t[0] && t[0].f7Panel; t.trigger("panel:backdrop-click"), a && a.emit("backdropClick", a), e.emit("panelBackdropClick", a || t[0]), !(a && a.params.closeByBackdropClick === !1) && e.params.panel.closeByBackdropClick && e.panel.close() } } }, Yl = { open(n, e) { n === void 0 && (n = ".card-expandable"), e === void 0 && (e = !0); const t = this, a = ue(), s = ee(), r = Ee(), i = y(n).eq(0); if (!i || !i.length || i.hasClass("card-opened") || i.hasClass("card-opening") || i.hasClass("card-closing")) return; const o = i.parents(".page").eq(0); if (!o.length || o.find(".card-opened").length) return; let l; function c() { l = !0 } if (i.trigger("card:beforeopen", { prevent: c }), t.emit("cardBeforeOpen", i[0], c), l) return; const d = Object.assign({ animate: e }, t.params.card, i.dataset()), u = i.parents(".page-content"); let p; i.attr("data-backdrop-el") && (p = y(i.attr("data-backdrop-el"))), !p && d.backdrop && (p = u.find(".card-backdrop"), p.length || (p = y('<div class="card-backdrop"></div>'), u.append(p))); let m, f; d.hideNavbarOnOpen && (m = o.children(".navbar"), m.length || o[0].f7Page && (m = o[0].f7Page.$navbarEl)), d.hideToolbarOnOpen && (f = o.children(".toolbar"), f.length || (f = o.parents(".view").children(".toolbar")), f.length || (f = o.parents(".views").children(".toolbar"))); const h = i.css("transform"); let b; h && h.match(/[2-9]/) && (b = !0); const g = i.children(".card-content"), v = y(s.createElement("div")).addClass("card-expandable-size"); i.append(v); let E = i[0].offsetWidth, $ = i[0].offsetHeight, w = o[0].offsetWidth, C = o[0].offsetHeight, k = v[0].offsetWidth || w, M = v[0].offsetHeight || C, A; m && !d.hideStatusbarOnOpen && M === C && (A = parseInt(m.css("--f7-safe-area-top"), 10), Number.isNaN(A) && (A = 0)), A && (M -= A); let O = k / E, S = M / $, P = i.offset(), T = o.offset(); A && (T.top += A / 2), P.left -= T.left; let I, H; if (b) { const ce = h.replace(/matrix\(|\)/g, "").split(",").map(de => de.trim()); if (ce && ce.length > 1) { const de = parseFloat(ce[0]); I = P.left - E * (1 - de) / 2, H = P.top - T.top - $ * (1 - de) / 2, t.rtl && (I -= i[0].scrollLeft) } else I = i[0].offsetLeft, H = i[0].offsetTop - (u.length ? u[0].scrollTop : 0) } else I = P.left, H = P.top - T.top, t.rtl && (I -= i[0].scrollLeft); I -= (w - k) / 2, H -= (C - M) / 2; let D = k - E - I; t.rtl && ([I, D] = [D, I]); let z = M - $ - H, B = (D - I) / 2, L = (z - H) / 2; d.hideNavbarOnOpen && m && m.length && (m.closest(".navbar-hidden").length ? i[0].f7KeepNavbarOnClose = !0 : (delete i[0].f7KeepNavbarOnClose, t.navbar.hide(m, d.animate, d.hideStatusbarOnOpen, !0))), d.hideToolbarOnOpen && f && f.length && (f.closest(".toolbar-hidden").length ? i[0].f7KeepToolbarOnClose = !0 : (delete i[0].f7KeepToolbarOnClose, t.toolbar.hide(f, d.animate))), p && p.removeClass("card-backdrop-out").addClass("card-backdrop-in"), i.removeClass("card-transitioning"), d.animate && i.addClass("card-opening"), i.trigger("card:open"), t.emit("cardOpen", i[0]); function N() { o.addClass("page-with-card-opened"), a.ios && u.length && (u.css("height", `${u[0].offsetHeight + 1}px`), setTimeout(() => { u.css("height", "") })), i.addClass("card-opened"), i.removeClass("card-opening"), i.trigger("card:opened"), t.emit("cardOpened", i[0], o[0]) } g.css({ width: `${k}px`, height: `${M}px` }).transform(`translate3d(${t.rtl ? I + B : -I - B}px, 0px, 0) scale(${1 / O}, ${1 / S})`), i.transform(`translate3d(${t.rtl ? -B : B}px, ${L}px, 0) scale(${O}, ${S})`), d.animate ? i.transitionEnd(() => { N() }) : N(); function F() { i.removeClass("card-transitioning"), E = i[0].offsetWidth, $ = i[0].offsetHeight, w = o[0].offsetWidth, C = o[0].offsetHeight, k = v[0].offsetWidth || w, M = v[0].offsetHeight || C, A = 0, m && !d.hideStatusbarOnOpen && M === C && (A = parseInt(m.css("--f7-safe-area-top"), 10), Number.isNaN(A) && (A = 0)), A && (M -= A), O = k / E, S = M / $, i.transform("translate3d(0px, 0px, 0) scale(1)"), P = i.offset(), T = o.offset(), A && (T.top += A / 2), P.left -= T.left, P.top -= T.top, I = P.left - (w - k) / 2, t.rtl && (I -= i[0].scrollLeft), H = P.top - (C - M) / 2, D = k - E - I, z = M - $ - H, t.rtl && ([I, D] = [D, I]), B = (D - I) / 2, L = (z - H) / 2, i.transform(`translate3d(${t.rtl ? -B : B}px, ${L}px, 0) scale(${O}, ${S})`), g.css({ width: `${k}px`, height: `${M}px` }).transform(`translate3d(${t.rtl ? I + B : -I - B}px, 0px, 0) scale(${1 / O}, ${1 / S})`) } let V, _, J, Q, j, Y, X, K, W, G, Z, ie; function ge(ce) { !y(ce.target).closest(i).length || !ce.isTrusted || i.hasClass("card-opened") && (ie = i.find(d.scrollableEl), ie[0] && ie[0] !== g[0] && !ie[0].contains(ce.target) ? V = 0 : V = ie.scrollTop(), _ = !0, Q = ce.targetTouches[0].pageX, j = ce.targetTouches[0].pageY, K = void 0, G = !1, Z = !1) } function te(ce) { if (!(!_ || !ce.isTrusted)) { if (Y = ce.targetTouches[0].pageX, X = ce.targetTouches[0].pageY, typeof K > "u" && (K = !!(K || Math.abs(X - j) > Math.abs(Y - Q))), !Z && !G && (!K && ce.targetTouches[0].clientX <= 50 ? Z = !0 : G = !0), !(Z || G) || G && V !== 0) { _ = !0, J = !0; return } J || i.removeClass("card-transitioning"), J = !0, W = Math.max(G ? (X - j) / 150 : (Y - Q) / (E / 2), 0), (W > 0 && G || Z) && (G && a.ios && ie[0] === g[0] && (ie.css("-webkit-overflow-scrolling", "auto"), ie.scrollTop(0)), ce.preventDefault()), W > 1 && (W **= .3), W > (G ? 1.3 : 1.1) ? (_ = !1, J = !1, t.card.close(i)) : i.transform(`translate3d(${t.rtl ? -B : B}px, ${L}px, 0) scale(${O * (1 - W * .2)}, ${S * (1 - W * .2)})`) } } function le(ce) { !_ || !J || !ce.isTrusted || (_ = !1, J = !1, a.ios && ie.css("-webkit-overflow-scrolling", ""), W >= .8 ? t.card.close(i) : i.addClass("card-transitioning").transform(`translate3d(${t.rtl ? -B : B}px, ${L}px, 0) scale(${O}, ${S})`)) } i[0].detachEventHandlers = function () { t.off("resize", F), r.touch && d.swipeToClose && (t.off("touchstart:passive", ge), t.off("touchmove:active", te), t.off("touchend:passive", le)) }, t.on("resize", F), r.touch && d.swipeToClose && (t.on("touchstart:passive", ge), t.on("touchmove:active", te), t.on("touchend:passive", le)) }, close(n, e) { n === void 0 && (n = ".card-expandable.card-opened"), e === void 0 && (e = !0); const t = this, a = ue(), s = y(n).eq(0); if (!s || !s.length || !s.hasClass("card-opened") || s.hasClass("card-opening") || s.hasClass("card-closing")) return; const r = s.children(".card-content"), i = s.parents(".page-content"), o = s.parents(".page").eq(0); if (!o.length) return; const l = Object.assign({ animate: e }, t.params.card, s.dataset()), c = s.find(l.scrollableEl); let d, u, p; s.attr("data-backdrop-el") && (p = y(s.attr("data-backdrop-el"))), l.backdrop && (p = s.parents(".page-content").find(".card-backdrop")), l.hideNavbarOnOpen && (d = o.children(".navbar"), d.length || o[0].f7Page && (d = o[0].f7Page.$navbarEl), d && d.length && !s[0].f7KeepNavbarOnClose && t.navbar.show(d, l.animate, !0)), l.hideToolbarOnOpen && (u = o.children(".toolbar"), u.length || (u = o.parents(".view").children(".toolbar")), u.length || (u = o.parents(".views").children(".toolbar")), u && u.length && !s[0].f7KeepToolbarOnClose && t.toolbar.show(u, l.animate)), o.removeClass("page-with-card-opened"), a.ios && i.length && (i.css("height", `${i[0].offsetHeight + 1}px`), setTimeout(() => { i.css("height", "") })), p && p.length && p.removeClass("card-backdrop-in").addClass("card-backdrop-out"), s.removeClass("card-opened card-transitioning"), l.animate ? s.addClass("card-closing") : s.addClass("card-no-transition"), s.transform(""), s.trigger("card:close"), t.emit("cardClose", s[0], o[0]); const m = s.hasClass("card-expandable-animate-width"); function f() { m || r.css({ width: "", height: "" }), p && p.length && p.removeClass("card-backdrop-in card-backdrop-out"), s.removeClass("card-closing card-no-transition"), s.trigger("card:closed"), s.find(".card-expandable-size").remove(), t.emit("cardClosed", s[0], o[0]) } m && r.css({ width: "", height: "" }), r.transform("").scrollTop(0, e ? 300 : 0), c.length && c[0] !== r[0] && c.scrollTop(0, e ? 300 : 0), e ? r.transitionEnd(() => { f() }) : f(), s[0].detachEventHandlers && (s[0].detachEventHandlers(), delete s[0].detachEventHandlers) }, toggle(n, e) { n === void 0 && (n = ".card-expandable"); const t = this, a = y(n).eq(0); a.length && (a.hasClass("card-opened") ? t.card.close(a, e) : t.card.open(a, e)) } }, ql = { name: "card", params: { card: { hideNavbarOnOpen: !0, hideStatusbarOnOpen: !0, hideToolbarOnOpen: !0, scrollableEl: ".card-content", swipeToClose: !0, closeByBackdropClick: !0, backdrop: !0 } }, create() { Se(this, { card: Yl }) }, on: { pageBeforeIn(n) { const e = this; if (e.params.card.hideNavbarOnOpen && n.navbarEl && n.$el.find(".card-opened.card-expandable").length && e.navbar.hide(n.navbarEl, !0, e.params.card.hideStatusbarOnOpen, !0), e.params.card.hideToolbarOnOpen && n.$el.find(".card-opened.card-expandable").length) { let t = n.$el.children(".toolbar"); t.length || (t = n.$el.parents(".view").children(".toolbar")), t.length || (t = n.$el.parents(".views").children(".toolbar")), t && t.length && e.toolbar.hide(t) } } }, clicks: { ".card-close": function (e, t) { this.card.close(t.card, t.animate) }, ".card-open": function (e, t) { this.card.open(t.card, t.animate) }, ".card-expandable": function (e, t, a) { const s = this; e.hasClass("card-opened") || e.hasClass("card-opening") || e.hasClass("card-closing") || y(a.target).closest(".card-prevent-open, .card-close").length || s.card.open(e) }, ".card-backdrop-in": function () { const e = this; let t = !1; e.params.card.closeByBackdropClick && (t = !0); const a = y(".card-opened"); a.length && (a.attr("data-close-by-backdrop-click") === "true" ? t = !0 : a.attr("data-close-by-backdrop-click") === "false" && (t = !1), t && e.card.close(a)) } } }, jl = { name: "chip" }, ya = { store(n, e) { const t = this, a = U(); let s = n; const r = y(n); r.length && r.is("form") && r.attr("id") && (s = r.attr("id")), t.form.data[`form-${s}`] = e, a.localStorage[`f7form-${s}`] = JSON.stringify(e) }, get(n) { const e = this, t = U(); let a = n; const s = y(n); if (s.length && s.is("form") && s.attr("id") && (a = s.attr("id")), t.localStorage[`f7form-${a}`]) return JSON.parse(t.localStorage[`f7form-${a}`]); if (e.form.data[`form-${a}`]) return e.form.data[`form-${a}`] }, remove(n) { const e = this, t = U(); let a = n; const s = y(n); s.length && s.is("form") && s.attr("id") && (a = s.attr("id")), e.form.data[`form-${a}`] && (e.form.data[`form-${a}`] = "", delete e.form.data[`form-${a}`]), t.localStorage[`f7form-${a}`] && (t.localStorage[`f7form-${a}`] = "", t.localStorage.removeItem(`f7form-${a}`)) } }, Pn = { init(n) { const e = this, t = y(n), a = t.attr("id"); if (!a) return; const s = e.form.getFormData(a); s && e.form.fillFromData(t, s); function r() { const i = e.form.convertToData(t); i && (e.form.storeFormData(a, i), t.trigger("form:storedata", i), e.emit("formStoreData", t[0], i)) } t.on("change submit", r) }, destroy(n) { y(n).off("change submit") } }; function Wl(n) { const e = this, t = y(n).eq(0); if (t.length === 0) return; const a = {}, s = ["submit", "image", "button", "file"], r = []; return t.find("input, select, textarea").each(i => { const o = y(i); if (o.hasClass("ignore-store-data") || o.hasClass("no-store-data")) return; const l = o.attr("name"), c = o.attr("type"), d = i.nodeName.toLowerCase(); if (!(s.indexOf(c) >= 0) && !(r.indexOf(l) >= 0 || !l)) if (d === "select" && o.prop("multiple")) r.push(l), a[l] = [], t.find(`select[name="${l}"] option`).each(u => { u.selected && a[l].push(u.value) }); else switch (c) { case "checkbox": r.push(l), a[l] = [], t.find(`input[name="${l}"]`).each(u => { u.checked && a[l].push(u.value) }); break; case "radio": r.push(l), t.find(`input[name="${l}"]`).each(u => { u.checked && (a[l] = u.value) }); break; default: a[l] = o.val(); break } }), t.trigger("form:todata", a), e.emit("formToData", t[0], a), a } function Xl(n, e) { const t = this, a = y(n).eq(0); if (!a.length) return; let s = e; const r = a.attr("id"); if (!s && r && (s = t.form.getFormData(r)), !s) return; const i = ["submit", "image", "button", "file"], o = []; a.find("input, select, textarea").each(l => { const c = y(l); if (c.hasClass("ignore-store-data") || c.hasClass("no-store-data")) return; const d = c.attr("name"), u = c.attr("type"), p = l.nodeName.toLowerCase(); if (!(typeof s[d] > "u" || s[d] === null) && !(i.indexOf(u) >= 0) && !(o.indexOf(d) >= 0 || !d)) { if (p === "select" && c.prop("multiple")) o.push(d), a.find(`select[name="${d}"] option`).each(m => { const f = m; s[d].indexOf(m.value) >= 0 ? f.selected = !0 : f.selected = !1 }); else switch (u) { case "checkbox": o.push(d), a.find(`input[name="${d}"]`).each(m => { const f = m; s[d].indexOf(m.value) >= 0 ? f.checked = !0 : f.checked = !1 }); break; case "radio": o.push(d), a.find(`input[name="${d}"]`).each(m => { const f = m; s[d] === m.value ? f.checked = !0 : f.checked = !1 }); break; default: c.val(s[d]); break }(p === "select" || p === "input" || p === "textarea") && c.trigger("change", "fromdata") } }), a.trigger("form:fromdata", s), t.emit("formFromData", a[0], s) } function Gl() { const n = this, e = U(), t = ee(); function a(s, r) { const i = y(this); if (s.type === "change" && !i.hasClass("form-ajax-submit-onchange") || (s.type === "submit" && s.preventDefault(), s.type === "change" && r === "fromdata")) return; const o = (i.attr("method") || "GET").toUpperCase(), l = i.attr("enctype") || i.prop("enctype"); let c = i.attr("action"); if (!c) return; let d; o === "POST" ? l === "application/x-www-form-urlencoded" || l === "application/json" ? (d = n.form.convertToData(i[0]), l === "application/json" && (d = JSON.stringify(d))) : d = new e.FormData(i[0]) : (d = dt(n.form.convertToData(i[0])), c.includes("?") ? c += `&${d}` : c += `?${d}`), i.trigger("formajax:beforesend", { data: d }), n.emit("formAjaxBeforeSend", i[0], d), fetch(c, { method: o, headers: { "Content-Type": l || "application/x-www-form-urlencoded" }, ...o === "POST" || o === "PUT" ? { body: d } : {} }).then(u => { i.trigger("formajax:complete", { data: d, response: u }), n.emit("formAjaxComplete", i[0], d, u), i.trigger("formajax:success", { data: d, response: u }), n.emit("formAjaxSuccess", i[0], d, u) }).catch(u => { i.trigger("formajax:error", { data: d, error: u }), n.emit("formAjaxError", i[0], d, u) }) } y(t).on("submit change", "form.form-ajax-submit, form.form-ajax-submit-onchange", a) } const Ul = { name: "form", create() { const n = this; R(n, { form: { data: {}, storeFormData: ya.store.bind(n), getFormData: ya.get.bind(n), removeFormData: ya.remove.bind(n), convertToData: Wl.bind(n), fillFromData: Xl.bind(n), storage: { init: Pn.init.bind(n), destroy: Pn.destroy.bind(n) } } }) }, on: { init() { const n = this; Gl.call(n) }, tabBeforeRemove(n) { const e = this; y(n).find(".form-store-data").each(t => { e.form.storage.destroy(t) }) }, tabMounted(n) { const e = this; y(n).find(".form-store-data").each(t => { e.form.storage.init(t) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".form-store-data").each(t => { e.form.storage.destroy(t) }) }, pageInit(n) { const e = this; n.$el.find(".form-store-data").each(t => { e.form.storage.init(t) }) } } }, Be = { ignoreTypes: ["checkbox", "button", "submit", "range", "radio", "image"], createTextareaResizableShadow() { const n = ee(), e = y(n.createElement("textarea")); e.addClass("textarea-resizable-shadow"), e.prop({ disabled: !0, readonly: !0 }), Be.textareaResizableShadow = e }, textareaResizableShadow: void 0, resizeTextarea(n) { const e = this, t = U(), a = y(n); Be.textareaResizableShadow || Be.createTextareaResizableShadow(); const s = Be.textareaResizableShadow; if (!a.length || !a.hasClass("resizable")) return; Be.textareaResizableShadow.parents().length === 0 && e.$el.append(s); const r = t.getComputedStyle(a[0]); "padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display".split(" ").forEach(c => { let d = r[c]; "font-size line-height letter-spacing width".split(" ").indexOf(c) >= 0 && (d = d.replace(",", ".")), s.css(c, d) }); const i = a[0].clientHeight; s.val(""); const o = s[0].scrollHeight; s.val(a.val()), s.css("height", 0); const l = s[0].scrollHeight; i !== l && (l > o ? a.css("height", `${l}px`) : l < i && a.css("height", ""), (l > o || l < i) && (a.trigger("textarea:resize", { initialHeight: o, currentHeight: i, scrollHeight: l }), e.emit("textareaResize", { initialHeight: o, currentHeight: i, scrollHeight: l }))) }, validate(n) { const e = y(n); if (!e.length) return !0; const t = e.parents(".item-input"), a = e.parents(".input"); function s() { e[0].f7ValidateReadonly && (e[0].readOnly = !1) } function r() { e[0].f7ValidateReadonly && (e[0].readOnly = !0) } s(); const i = e[0].validity, o = e.dataset().errorMessage || e[0].validationMessage || ""; if (!i) return r(), !0; if (!i.valid) { let l = e.nextAll(".item-input-error-message, .input-error-message"); return o && (l.length === 0 && (l = y(`<div class="${a.length ? "input-error-message" : "item-input-error-message"}"></div>`), l.insertAfter(e)), l.text(o)), l.length > 0 && (t.addClass("item-input-with-error-message"), a.addClass("input-with-error-message")), t.addClass("item-input-invalid"), a.addClass("input-invalid"), e.addClass("input-invalid"), r(), !1 } return t.removeClass("item-input-invalid item-input-with-error-message"), a.removeClass("input-invalid input-with-error-message"), e.removeClass("input-invalid"), r(), !0 }, validateInputs(n) { const e = this; return y(n).find("input, textarea, select").map(a => e.input.validate(a)).indexOf(!1) < 0 }, focus(n) { const e = y(n), t = e.attr("type"); Be.ignoreTypes.indexOf(t) >= 0 || (e.parents(".item-input").addClass("item-input-focused"), e.parents(".input").addClass("input-focused"), e.addClass("input-focused")) }, blur(n) { const e = y(n); e.parents(".item-input").removeClass("item-input-focused"), e.parents(".input").removeClass("input-focused"), e.removeClass("input-focused") }, checkEmptyState(n) { const e = this; let t = y(n); if (t.is("input, select, textarea, .item-input [contenteditable]") || (t = t.find("input, select, textarea, .item-input [contenteditable]").eq(0)), !t.length) return; const a = t[0].hasAttribute("contenteditable"); let s; a ? t.find(".text-editor-placeholder").length ? s = "" : s = t.html() : s = t.val(); const r = t.parents(".item-input"), i = t.parents(".input"); s && typeof s == "string" && s.trim() !== "" || Array.isArray(s) && s.length > 0 ? (r.addClass("item-input-with-value"), i.addClass("input-with-value"), t.addClass("input-with-value"), t.trigger("input:notempty"), e.emit("inputNotEmpty", t[0])) : (r.removeClass("item-input-with-value"), i.removeClass("input-with-value"), t.removeClass("input-with-value"), t.trigger("input:empty"), e.emit("inputEmpty", t[0])) }, scrollIntoView(n, e, t, a) { e === void 0 && (e = 0); const s = y(n), r = s.parents(".page-content, .panel, .card-expandable .card-content").eq(0); if (!r.length) return !1; const i = r[0].offsetHeight, o = r[0].scrollTop, l = parseInt(r.css("padding-top"), 10), c = parseInt(r.css("padding-bottom"), 10), d = r.offset().top - o, u = s.offset().top - d, p = s[0].offsetHeight, m = u + o - l, f = u + o - i + c + p, h = m + (f - m) / 2; return o > m ? (r.scrollTop(t ? h : m, e), !0) : o < f ? (r.scrollTop(t ? h : f, e), !0) : (a && r.scrollTop(t ? h : f, e), !1) }, init() { const n = this, e = ue(), t = U(), a = ee(); Be.createTextareaResizableShadow(); function s() { const d = this; n.params.input.scrollIntoViewOnFocus && (e.android ? y(t).once("resize", () => { a && a.activeElement === d && n.input.scrollIntoView(d, n.params.input.scrollIntoViewDuration, n.params.input.scrollIntoViewCentered, n.params.input.scrollIntoViewAlways) }) : n.input.scrollIntoView(d, n.params.input.scrollIntoViewDuration, n.params.input.scrollIntoViewCentered, n.params.input.scrollIntoViewAlways)), n.input.focus(d) } function r() { const d = y(this), u = d[0].nodeName.toLowerCase(); n.input.blur(d), (d.dataset().validate || d.attr("validate") !== null || d.attr("data-validate-on-blur") !== null) && n.input.validate(d), u === "textarea" && d.hasClass("resizable") && Be.textareaResizableShadow && Be.textareaResizableShadow.remove() } function i() { const d = y(this), u = d.attr("type"), p = d[0].nodeName.toLowerCase(), m = d[0].hasAttribute("contenteditable"); Be.ignoreTypes.indexOf(u) >= 0 || (n.input.checkEmptyState(d), !m && (d.attr("data-validate-on-blur") === null && (d.dataset().validate || d.attr("validate") !== null) && n.input.validate(d), p === "textarea" && d.hasClass("resizable") && n.input.resizeTextarea(d))) } function o(d) { const u = y(this); u.attr("data-validate-on-blur") === null && (u.dataset().validate || u.attr("validate") !== null) && (d.preventDefault(), n.input.validate(u)) } function l() { const u = y(this).siblings("input, textarea").eq(0), p = u.val(); u.val("").trigger("input change").focus().trigger("input:clear", p), n.emit("inputClear", p) } function c(d) { d.preventDefault() } y(a).on("click", ".input-clear-button", l), y(a).on("mousedown", ".input-clear-button", c), y(a).on("change input", "input, textarea, select, .item-input [contenteditable]", i, !0), y(a).on("focus", "input, textarea, select, .item-input [contenteditable]", s, !0), y(a).on("blur", "input, textarea, select, .item-input [contenteditable]", r, !0), y(a).on("invalid", "input, textarea, select", o, !0) } }, _l = { name: "input", params: { input: { scrollIntoViewOnFocus: void 0, scrollIntoViewCentered: !1, scrollIntoViewDuration: 0, scrollIntoViewAlways: !1 } }, create() { const n = this; typeof n.params.input.scrollIntoViewOnFocus > "u" && (n.params.input.scrollIntoViewOnFocus = ue().android), Se(n, { input: Be }) }, on: { init() { this.input.init() }, tabMounted(n) { const e = this, t = y(n); t.find(".item-input, .input").each(a => { y(a).find("input, select, textarea, [contenteditable]").each(r => { const i = y(r); Be.ignoreTypes.indexOf(i.attr("type")) >= 0 || e.input.checkEmptyState(i) }) }), t.find("textarea.resizable").each(a => { e.input.resizeTextarea(a) }) }, pageInit(n) { const e = this, t = n.$el; t.find(".item-input, .input").each(a => { y(a).find("input, select, textarea, [contenteditable]").each(r => { const i = y(r); Be.ignoreTypes.indexOf(i.attr("type")) >= 0 || e.input.checkEmptyState(i) }) }), t.find("textarea.resizable").each(a => { e.input.resizeTextarea(a) }) }, "panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint": function (e) { const t = this; e && e.$el ? e.$el.find("textarea.resizable").each(a => { t.input.resizeTextarea(a) }) : y("textarea.resizable").each(a => { t.input.resizeTextarea(a) }) } } }, Kl = { name: "checkbox" }, Ql = { name: "radio" }; let An = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = Ee(), r = {}; a.useModulesParams(r), a.params = R(r, t); const i = a.params.el; if (!i) return a; const o = y(i); if (o.length === 0) return a; if (o[0].f7Toggle) return o[0].f7Toggle; const l = o.children('input[type="checkbox"]'); R(a, { app: e, $el: o, el: o[0], $inputEl: l, inputEl: l[0], disabled: o.hasClass("disabled") || l.hasClass("disabled") || l.attr("disabled") || l[0].disabled }), Object.defineProperty(a, "checked", { enumerable: !0, configurable: !0, set($) { !a || typeof a.$inputEl > "u" || a.checked !== $ && (l[0].checked = $, a.$inputEl.trigger("change")) }, get() { return l[0].checked } }), o[0].f7Toggle = a; let c; const d = {}; let u, p, m, f, h; function b($) { c || a.disabled || (d.x = $.type === "touchstart" ? $.targetTouches[0].pageX : $.pageX, d.y = $.type === "touchstart" ? $.targetTouches[0].pageY : $.pageY, p = 0, c = !0, u = void 0, f = Ie(), h = a.checked, m = o[0].offsetWidth, $e(() => { c && o.addClass("toggle-active-state") })) } function g($) { if (!c || a.disabled) return; const w = $.type === "touchmove" ? $.targetTouches[0].pageX : $.pageX, C = $.type === "touchmove" ? $.targetTouches[0].pageY : $.pageY, k = e.rtl ? -1 : 1; if (typeof u > "u" && (u = !!(u || Math.abs(C - d.y) > Math.abs(w - d.x))), u) { c = !1; return } $.preventDefault(), p = w - d.x; let M; p * k < 0 && Math.abs(p) > m / 3 && h && (M = !0), p * k > 0 && Math.abs(p) > m / 3 && !h && (M = !0), M && (d.x = w, a.checked = !h, h = !h) } function v() { if (!c || a.disabled) { u && o.removeClass("toggle-active-state"), c = !1; return } const $ = e.rtl ? -1 : 1; c = !1, o.removeClass("toggle-active-state"); let w; Ie() - f < 300 && (p * $ < 0 && h && (w = !0), p * $ > 0 && !h && (w = !0), w && (a.checked = !h)) } function E() { a.$el.trigger("toggle:change"), a.emit("local::change toggleChange", a) } a.attachEvents = function () { const w = s.passiveListener ? { passive: !0 } : !1; o.on(e.touchEvents.start, b, w), e.on("touchmove", g), e.on("touchend:passive", v), a.$inputEl.on("change", E) }, a.detachEvents = function () { const w = s.passiveListener ? { passive: !0 } : !1; o.off(e.touchEvents.start, b, w), e.off("touchmove", g), e.off("touchend:passive", v), a.$inputEl.off("change", E) }, a.useModules(), a.init() } toggle() { const e = this; e.checked = !e.checked } init() { this.attachEvents() } destroy() { let e = this; e.$el.trigger("toggle:beforedestroy"), e.emit("local::beforeDestroy toggleBeforeDestroy", e), delete e.$el[0].f7Toggle, e.detachEvents(), ve(e), e = null } }; const Zl = { name: "toggle", create() { const n = this; n.toggle = we({ defaultSelector: ".toggle", constructor: An, app: n, domProp: "f7Toggle" }) }, static: { Toggle: An }, on: { tabMounted(n) { const e = this; y(n).find(".toggle-init").each(t => e.toggle.create({ el: t })) }, tabBeforeRemove(n) { y(n).find(".toggle-init").each(e => { e.f7Toggle && e.f7Toggle.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".toggle-init").each(t => e.toggle.create({ el: t })) }, pageBeforeRemove(n) { n.$el.find(".toggle-init").each(e => { e.f7Toggle && e.f7Toggle.destroy() }) } }, vnode: { "toggle-init": { insert(n) { const e = this, t = n.elm; e.toggle.create({ el: t }) }, destroy(n) { const e = n.elm; e.f7Toggle && e.f7Toggle.destroy() } } } }; let Vt = class extends me {
  constructor(e, t) {
    super(t, [e]); const a = this, s = Ee(), r = { el: null, inputEl: null, dual: !1, step: 1, label: !1, min: 0, max: 100, value: 0, draggableBar: !0, vertical: !1, verticalReversed: !1, formatLabel: null, scale: !1, scaleSteps: 5, scaleSubSteps: 0, formatScaleLabel: null, limitKnobPosition: e.theme === "ios" }; a.useModulesParams(r), a.params = R(r, t); const i = a.params.el; if (!i) return a; const o = y(i); if (o.length === 0) return a; if (o[0].f7Range) return o[0].f7Range; const l = o.dataset(); "step min max value scaleSteps scaleSubSteps".split(" ").forEach(W => { typeof t[W] > "u" && typeof l[W] < "u" && (a.params[W] = parseFloat(l[W])) }), "dual label vertical verticalReversed scale".split(" ").forEach(W => { typeof t[W] > "u" && typeof l[W] < "u" && (a.params[W] = l[W]) }), a.params.value || (typeof l.value < "u" && (a.params.value = l.value), typeof l.valueLeft < "u" && typeof l.valueRight < "u" && (a.params.value = [parseFloat(l.valueLeft), parseFloat(l.valueRight)])); let c; a.params.dual || (a.params.inputEl ? c = y(a.params.inputEl) : o.find('input[type="range"]').length && (c = o.find('input[type="range"]').eq(0))); const { dual: d, step: u, label: p, min: m, max: f, value: h, vertical: b, verticalReversed: g, scale: v, scaleSteps: E, scaleSubSteps: $, limitKnobPosition: w } = a.params; R(a, { app: e, $el: o, el: o[0], $inputEl: c, inputEl: c ? c[0] : void 0, dual: d, step: u, label: p, min: m, max: f, value: h, previousValue: h, vertical: b, verticalReversed: g, scale: v, scaleSteps: E, scaleSubSteps: $, limitKnobPosition: w }), c && ("step min max".split(" ").forEach(W => { !t[W] && c.attr(W) && (a.params[W] = parseFloat(c.attr(W)), a[W] = parseFloat(c.attr(W))) }), typeof c.val() < "u" && (a.params.value = parseFloat(c.val()), a.value = parseFloat(c.val()))), a.dual && o.addClass("range-slider-dual"), a.label && o.addClass("range-slider-label"), a.vertical ? (o.addClass("range-slider-vertical"), a.verticalReversed && o.addClass("range-slider-vertical-reversed")) : o.addClass("range-slider-horizontal"); const C = y('<div class="range-bar"></div>'), k = y('<div class="range-bar-active"></div>'); C.append(k); const M = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${a.label ? '<div class="range-knob-label"></div>' : ""}
      </div>
    `, A = [y(M)]; a.dual && A.push(y(M)), o.append(C), A.forEach(W => { o.append(W) }); const O = []; a.label && (O.push(A[0].find(".range-knob-label")), a.dual && O.push(A[1].find(".range-knob-label"))); let S; a.scale && a.scaleSteps >= 1 && (S = y(`
        <div class="range-scale">
          ${a.renderScale()}
        </div>
      `), o.append(S)), R(a, { knobs: A, labels: O, $barEl: C, $barActiveEl: k, $scaleEl: S }), o[0].f7Range = a; let P; const T = {}; let I, H, D, z, B, L, N, F; function V() { N = !0 } function _(W) { if (P || !a.params.draggableBar && y(W.target).closest(".range-knob").length === 0) return; N = !1, T.x = W.type === "touchstart" ? W.targetTouches[0].pageX : W.pageX, T.y = W.type === "touchstart" ? W.targetTouches[0].pageY : W.pageY, W.type === "touchstart" && (F = W.targetTouches[0].identifier), P = !0, I = void 0, H = o.offset(), D = H.left, z = H.top; let G; a.vertical ? (G = (T.y - z) / a.rangeHeight, a.verticalReversed || (G = 1 - G)) : a.app.rtl ? G = (D + a.rangeWidth - T.x) / a.rangeWidth : G = (T.x - D) / a.rangeWidth; let Z = G * (a.max - a.min) + a.min; a.dual ? Math.abs(a.value[0] - Z) < Math.abs(a.value[1] - Z) ? (L = 0, B = a.knobs[0], Z = [Z, a.value[1]]) : (L = 1, B = a.knobs[1], Z = [a.value[0], Z]) : (B = a.knobs[0], Z = G * (a.max - a.min) + a.min), $e(() => { P && B.addClass("range-knob-active-state") }, 70), a.on("change", V), a.setValue(Z, !0) } function J(W) { if (!P) return; let G, Z; if (W.type === "touchmove") for (let te = 0; te < W.targetTouches.length; te += 1)W.targetTouches[te].identifier === F && (G = W.targetTouches[te].pageX, Z = W.targetTouches[te].pageY); else G = W.pageX, Z = W.pageY; if (typeof G > "u" && typeof Z > "u") return; if (typeof I > "u" && !a.vertical && (I = !!(I || Math.abs(Z - T.y) > Math.abs(G - T.x))), I) { P = !1; return } W.preventDefault(); let ie; a.vertical ? (ie = (Z - z) / a.rangeHeight, a.verticalReversed || (ie = 1 - ie)) : a.app.rtl ? ie = (D + a.rangeWidth - G) / a.rangeWidth : ie = (G - D) / a.rangeWidth; let ge = ie * (a.max - a.min) + a.min; if (a.dual) { let te, le; L === 0 ? (te = ge, le = a.value[1], te > le && (le = te)) : (te = a.value[0], le = ge, le < te && (te = le)), ge = [te, le] } a.setValue(ge, !0) } function Q(W) { if (W.type === "touchend") { let G; for (let Z = 0; Z < W.changedTouches.length; Z += 1)W.changedTouches[Z].identifier === F && (G = !0); if (!G) return } if (!P) { I && B.removeClass("range-knob-active-state"), P = !1; return } a.off("change", V), P = !1, B.removeClass("range-knob-active-state"), N && a.$inputEl && !a.dual && a.$inputEl.trigger("change"), N = !1, typeof a.previousValue < "u" && (a.dual && (a.previousValue[0] !== a.value[0] || a.previousValue[1] !== a.value[1]) || !a.dual && a.previousValue !== a.value) && (a.$el.trigger("range:changed", a.value), a.emit("local::changed rangeChanged", a, a.value)) } function j() { a.calcSize(), a.layout() } let Y, X, K; return a.attachEvents = function () { const G = s.passiveListener ? { passive: !0 } : !1; a.$el.on(e.touchEvents.start, _, G), e.on("touchmove", J), e.on("touchend:passive", Q), e.on("tabShow", j), e.on("resize", j), Y = a.$el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast"), Y.on("modal:open", j), X = a.$el.parents(".panel"), X.on("panel:open panel:resize", j), K = a.$el.parents(".page").eq(0), K.on("page:reinit", j) }, a.detachEvents = function () { const G = s.passiveListener ? { passive: !0 } : !1; a.$el.off(e.touchEvents.start, _, G), e.off("touchmove", J), e.off("touchend:passive", Q), e.off("tabShow", j), e.off("resize", j), Y && Y.off("modal:open", j), X && X.off("panel:open panel:resize", j), K && K.off("page:reinit", j), Y = null, X = null, K = null }, a.useModules(), a.init(), a
  } calcSize() { const e = this; if (e.vertical) { const t = e.$el.outerHeight(); if (t === 0) return; e.rangeHeight = t, e.knobHeight = e.knobs[0].outerHeight() } else { const t = e.$el.outerWidth(); if (t === 0) return; e.rangeWidth = t, e.knobWidth = e.knobs[0].outerWidth() } } layout() { const e = this, { app: t, knobWidth: a, knobHeight: s, rangeWidth: r, rangeHeight: i, min: o, max: l, knobs: c, $barActiveEl: d, value: u, label: p, labels: m, vertical: f, verticalReversed: h, limitKnobPosition: b } = e, g = f ? s : a, v = f ? i : r, E = f ? h ? "top" : "bottom" : t.rtl ? "right" : "left"; if (e.dual) { const $ = [(u[0] - o) / (l - o), (u[1] - o) / (l - o)]; d.css({ [E]: `${$[0] * 100}%`, [f ? "height" : "width"]: `${($[1] - $[0]) * 100}%` }), c.forEach((w, C) => { let k = v * $[C]; if (b) { const M = v * $[C] - g / 2; M < 0 && (k = g / 2), M + g > v && (k = v - g / 2) } w.css(E, `${k}px`), p && m[C].text(e.formatLabel(u[C], m[C][0])) }) } else { const $ = (u - o) / (l - o); d.css(f ? "height" : "width", `${$ * 100}%`); let w = v * $; if (b) { const C = v * $ - g / 2; C < 0 && (w = g / 2), C + g > v && (w = v - g / 2) } c[0].css(E, `${w}px`), p && m[0].text(e.formatLabel(u, m[0][0])) } e.dual && u.indexOf(o) >= 0 || !e.dual && u === o ? e.$el.addClass("range-slider-min") : e.$el.removeClass("range-slider-min"), e.dual && u.indexOf(l) >= 0 || !e.dual && u === l ? e.$el.addClass("range-slider-max") : e.$el.removeClass("range-slider-max") } setValue(e, t) { const a = this, { step: s, min: r, max: i } = a; let o, l; if (a.dual) { l = [a.value[0], a.value[1]]; let c = e; if (Array.isArray(c) || (c = [e, e]), e[0] > e[1] && (c = [c[0], c[0]]), c = c.map(d => Math.max(Math.min(Math.round(d / s) * s, i), r)), c[0] === a.value[0] && c[1] === a.value[1]) return a; c.forEach((d, u) => { a.value[u] = d }), o = l[0] !== c[0] || l[1] !== c[1], a.layout() } else { l = a.value; const c = Math.max(Math.min(Math.round(e / s) * s, i), r); a.value = c, a.layout(), o = l !== c } return o && (a.previousValue = l), o && (a.$el.trigger("range:change", a.value), a.$inputEl && !a.dual && (a.$inputEl.val(a.value), t ? a.$inputEl.trigger("input") : a.$inputEl.trigger("input change")), t || (a.$el.trigger("range:changed", a.value), a.emit("local::changed rangeChanged", a, a.value)), a.emit("local::change rangeChange", a, a.value)), a } getValue() { return this.value } formatLabel(e, t) { const a = this; return a.params.formatLabel ? a.params.formatLabel.call(a, e, t) : e } formatScaleLabel(e) { const t = this; return t.params.formatScaleLabel ? t.params.formatScaleLabel.call(t, e) : e } renderScale() { const e = this, { app: t, verticalReversed: a, vertical: s } = e, r = s ? a ? "top" : "bottom" : t.rtl ? "right" : "left"; let i = ""; return Array.from({ length: e.scaleSteps + 1 }).forEach((o, l) => { const c = (e.max - e.min) / e.scaleSteps, d = e.min + c * l, u = (d - e.min) / (e.max - e.min); i += `<div class="range-scale-step" style="${r}: ${u * 100}%">${e.formatScaleLabel(d)}</div>`, e.scaleSubSteps && e.scaleSubSteps > 1 && l < e.scaleSteps && Array.from({ length: e.scaleSubSteps - 1 }).forEach((p, m) => { const f = c / e.scaleSubSteps, b = (d + f * (m + 1) - e.min) / (e.max - e.min); i += `<div class="range-scale-step range-scale-substep" style="${r}: ${b * 100}%"></div>` }) }), i } updateScale() { const e = this; if (!e.scale || e.scaleSteps < 1) { e.$scaleEl && e.$scaleEl.remove(), delete e.$scaleEl; return } e.$scaleEl || (e.$scaleEl = y('<div class="range-scale"></div>'), e.$el.append(e.$scaleEl)), e.$scaleEl.html(e.renderScale()) } init() { const e = this; return e.calcSize(), e.layout(), e.attachEvents(), e } destroy() { let e = this; e.$el.trigger("range:beforedestroy"), e.emit("local::beforeDestroy rangeBeforeDestroy", e), delete e.$el[0].f7Range, e.detachEvents(), ve(e), e = null }
}; const Jl = { name: "range", create() { const n = this; n.range = R(we({ defaultSelector: ".range-slider", constructor: Vt, app: n, domProp: "f7Range" }), { getValue(e) { e === void 0 && (e = ".range-slider"); const t = n.range.get(e); if (t) return t.getValue() }, setValue(e, t) { e === void 0 && (e = ".range-slider"); const a = n.range.get(e); if (a) return a.setValue(t) } }) }, static: { Range: Vt }, on: { tabMounted(n) { const e = this; y(n).find(".range-slider-init").each(t => new Vt(e, { el: t })) }, tabBeforeRemove(n) { y(n).find(".range-slider-init").each(e => { e.f7Range && e.f7Range.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".range-slider-init").each(t => new Vt(e, { el: t })) }, pageBeforeRemove(n) { n.$el.find(".range-slider-init").each(e => { e.f7Range && e.f7Range.destroy() }) } }, vnode: { "range-slider-init": { insert(n) { const e = n.elm; this.range.create({ el: e }) }, destroy(n) { const e = n.elm; e.f7Range && e.f7Range.destroy() } } } }; let In = class extends me { constructor(e, t) { super(t, [e]); const a = this, s = { el: null, inputEl: null, valueEl: null, value: 0, formatValue: null, step: 1, min: 0, max: 100, watchInput: !0, autorepeat: !1, autorepeatDynamic: !1, wraps: !1, manualInputMode: !1, decimalPoint: 4, buttonsEndInputMode: !0 }; a.useModulesParams(s), a.params = R(s, t), a.params.value < a.params.min && (a.params.value = a.params.min), a.params.value > a.params.max && (a.params.value = a.params.max); const r = a.params.el; if (!r) return a; const i = y(r); if (i.length === 0) return a; if (i[0].f7Stepper) return i[0].f7Stepper; let o; if (a.params.inputEl ? o = y(a.params.inputEl) : i.find(".stepper-input-wrap").find("input, textarea").length && (o = i.find(".stepper-input-wrap").find("input, textarea").eq(0)), o && o.length) { "step min max".split(" ").forEach(F => { !t[F] && o.attr(F) && (a.params[F] = parseFloat(o.attr(F))) }); const L = parseInt(a.params.decimalPoint, 10); Number.isNaN(L) ? a.params.decimalPoint = 0 : a.params.decimalPoint = L; const N = parseFloat(o.val()); typeof t.value > "u" && !Number.isNaN(N) && (N || N === 0) && (a.params.value = N) } let l; a.params.valueEl ? l = y(a.params.valueEl) : i.find(".stepper-value").length && (l = i.find(".stepper-value").eq(0)); const c = i.find(".stepper-button-plus"), d = i.find(".stepper-button-minus"), { step: u, min: p, max: m, value: f, decimalPoint: h } = a.params; R(a, { app: e, $el: i, el: i[0], $buttonPlusEl: c, buttonPlusEl: c[0], $buttonMinusEl: d, buttonMinusEl: d[0], $inputEl: o, inputEl: o ? o[0] : void 0, $valueEl: l, valueEl: l ? l[0] : void 0, step: u, min: p, max: m, value: f, decimalPoint: h, typeModeChanged: !1 }), i[0].f7Stepper = a; const b = {}; let g, v, E, $, w, C = null, k = !1, M = !1; function A(L, N, F, V, _, J) { clearTimeout(w), w = setTimeout(() => { L === 1 && (E = !0, k = !0), clearInterval($), J(), $ = setInterval(() => { J() }, _), L < N && A(L + 1, N, F, V, _ / 2, J) }, L === 1 ? F : V) } function O(L) { if (g || M || (y(L.target).closest(c).length ? C = "increment" : y(L.target).closest(d).length && (C = "decrement"), !C)) return; b.x = L.type === "touchstart" ? L.targetTouches[0].pageX : L.pageX, b.y = L.type === "touchstart" ? L.targetTouches[0].pageY : L.pageY, g = !0, v = void 0; const N = a.params.autorepeatDynamic ? 4 : 1; A(1, N, 500, 1e3, 300, () => { a[C]() }) } function S(L) { if (!g || M) return; const N = L.type === "touchmove" ? L.targetTouches[0].pageX : L.pageX, F = L.type === "touchmove" ? L.targetTouches[0].pageY : L.pageY; typeof v > "u" && !k && (v = !!(v || Math.abs(F - b.y) > Math.abs(N - b.x))); const V = ((N - b.x) ** 2 + (F - b.y) ** 2) ** .5; (v || V > 20) && (g = !1, clearTimeout(w), clearInterval($)) } function P() { clearTimeout(w), clearInterval($), C = null, k = !1, g = !1 } function T() { if (M) { a.params.buttonsEndInputMode && (M = !1, a.endTypeMode(!0)); return } if (E) { E = !1; return } a.decrement(!0) } function I() { if (M) { a.params.buttonsEndInputMode && (M = !1, a.endTypeMode(!0)); return } if (E) { E = !1; return } a.increment(!0) } function H(L) { !L.target.readOnly && a.params.manualInputMode && (M = !0, typeof L.target.selectionStart == "number" && (L.target.selectionStart = L.target.value.length, L.target.selectionEnd = L.target.value.length)) } function D(L) { (L.keyCode === 13 || L.which === 13) && (L.preventDefault(), M = !1, a.endTypeMode()) } function z() { M = !1, a.endTypeMode(!0) } function B(L) { if (M) { a.typeValue(L.target.value); return } L.detail && L.detail.sentByF7Stepper || a.setValue(L.target.value, !0) } return a.attachEvents = function () { d.on("click", T), c.on("click", I), a.params.watchInput && o && o.length && (o.on("input", B), o.on("click", H), o.on("blur", z), o.on("keyup", D)), a.params.autorepeat && (e.on("touchstart:passive", O), e.on("touchmove:active", S), e.on("touchend:passive", P)) }, a.detachEvents = function () { d.off("click", T), c.off("click", I), a.params.watchInput && o && o.length && (o.off("input", B), o.off("click", H), o.off("blur", z), o.off("keyup", D)) }, a.useModules(), a.init(), a } minus() { return this.decrement() } plus() { return this.increment() } decrement() { const e = this; return e.setValue(e.value - e.step, !1, !0) } increment() { const e = this; return e.setValue(e.value + e.step, !1, !0) } setValue(e, t, a) { const s = this, { step: r, min: i, max: o } = s, l = s.value; let c = Math.round(e / r) * r; if (s.params.wraps && a ? (c > o && (c = i), c < i && (c = o)) : c = Math.max(Math.min(c, o), i), Number.isNaN(c) && (c = l), s.value = c, !(l !== c) && !t) return s; s.$el.trigger("stepper:change", s.value); const u = s.formatValue(s.value); return s.$inputEl && s.$inputEl.length && (s.$inputEl.val(u), s.$inputEl.trigger("input change", { sentByF7Stepper: !0 })), s.$valueEl && s.$valueEl.length && s.$valueEl.html(u), s.emit("local::change stepperChange", s, s.value), s } endTypeMode(e) { const t = this, { min: a, max: s } = t; let r = parseFloat(t.value); if (Number.isNaN(r) && (r = 0), r = Math.max(Math.min(r, s), a), t.value = r, !t.typeModeChanged) return t.$inputEl && t.$inputEl.length && !e && t.$inputEl.blur(), t; t.typeModeChanged = !1, t.$el.trigger("stepper:change", t.value); const i = t.formatValue(t.value); return t.$inputEl && t.$inputEl.length && (t.$inputEl.val(i), t.$inputEl.trigger("input change", { sentByF7Stepper: !0 }), e || t.$inputEl.blur()), t.$valueEl && t.$valueEl.length && t.$valueEl.html(i), t.emit("local::change stepperChange", t, t.value), t } typeValue(e) { const t = this; t.typeModeChanged = !0; let a = String(e); if (a.length === 1 && a === "-") return t; if (a.lastIndexOf(".") + 1 === a.length || a.lastIndexOf(",") + 1 === a.length) { if (a.lastIndexOf(".") !== a.indexOf(".") || a.lastIndexOf(",") !== a.indexOf(",")) return a = a.slice(0, -1), t.value = a, t.$inputEl.val(t.value), t } else { let s = parseFloat(a.replace(",", ".")); if (s === 0) return t.value = a.replace(",", "."), t.$inputEl.val(t.value), t; if (Number.isNaN(s)) return t.value = 0, t.$inputEl.val(t.value), t; const r = 10 ** t.params.decimalPoint; return s = Math.round(s * r).toFixed(t.params.decimalPoint + 1) / r, t.value = parseFloat(String(s).replace(",", ".")), t.$inputEl.val(t.value), t } return t.value = a, t.$inputEl.val(a), t } getValue() { return this.value } formatValue(e) { const t = this; return t.params.formatValue ? t.params.formatValue.call(t, e) : e } init() { const e = this; if (e.attachEvents(), e.$valueEl && e.$valueEl.length) { const t = e.formatValue(e.value); e.$valueEl.html(t) } return e } destroy() { let e = this; e.$el.trigger("stepper:beforedestroy"), e.emit("local::beforeDestroy stepperBeforeDestroy", e), delete e.$el[0].f7Stepper, e.detachEvents(), ve(e), e = null } }; const ec = { name: "stepper", create() { const n = this; n.stepper = R(we({ defaultSelector: ".stepper", constructor: In, app: n, domProp: "f7Stepper" }), { getValue(e) { e === void 0 && (e = ".stepper"); const t = n.stepper.get(e); if (t) return t.getValue() }, setValue(e, t) { e === void 0 && (e = ".stepper"); const a = n.stepper.get(e); if (a) return a.setValue(t) } }) }, static: { Stepper: In }, on: { tabMounted(n) { const e = this; y(n).find(".stepper-init").each(t => { const a = y(t).dataset(); e.stepper.create(R({ el: t }, a || {})) }) }, tabBeforeRemove(n) { y(n).find(".stepper-init").each(e => { e.f7Stepper && e.f7Stepper.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".stepper-init").each(t => { const a = y(t).dataset(); e.stepper.create(R({ el: t }, a || {})) }) }, pageBeforeRemove(n) { n.$el.find(".stepper-init").each(e => { e.f7Stepper && e.f7Stepper.destroy() }) } }, vnode: { "stepper-init": { insert(n) { const e = this, t = n.elm, a = y(t).dataset(); e.stepper.create(R({ el: t }, a || {})) }, destroy(n) { const e = n.elm; e.f7Stepper && e.f7Stepper.destroy() } } } }, Ea = [{ base: "A", letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ" }, { base: "AA", letters: "Ꜳ" }, { base: "AE", letters: "ÆǼǢ" }, { base: "AO", letters: "Ꜵ" }, { base: "AU", letters: "Ꜷ" }, { base: "AV", letters: "ꜸꜺ" }, { base: "AY", letters: "Ꜽ" }, { base: "B", letters: "BⒷＢḂḄḆɃƂƁ" }, { base: "C", letters: "CⒸＣĆĈĊČÇḈƇȻꜾ" }, { base: "D", letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ" }, { base: "DZ", letters: "ǱǄ" }, { base: "Dz", letters: "ǲǅ" }, { base: "E", letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ" }, { base: "F", letters: "FⒻＦḞƑꝻ" }, { base: "G", letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ" }, { base: "H", letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ" }, { base: "I", letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ" }, { base: "J", letters: "JⒿＪĴɈ" }, { base: "K", letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ" }, { base: "L", letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ" }, { base: "LJ", letters: "Ǉ" }, { base: "Lj", letters: "ǈ" }, { base: "M", letters: "MⓂＭḾṀṂⱮƜ" }, { base: "N", letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ" }, { base: "NJ", letters: "Ǌ" }, { base: "Nj", letters: "ǋ" }, { base: "O", letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ" }, { base: "OI", letters: "Ƣ" }, { base: "OO", letters: "Ꝏ" }, { base: "OU", letters: "Ȣ" }, { base: "OE", letters: "Œ" }, { base: "oe", letters: "œ" }, { base: "P", letters: "PⓅＰṔṖƤⱣꝐꝒꝔ" }, { base: "Q", letters: "QⓆＱꝖꝘɊ" }, { base: "R", letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ" }, { base: "S", letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ" }, { base: "T", letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ" }, { base: "TZ", letters: "Ꜩ" }, { base: "U", letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ" }, { base: "V", letters: "VⓋＶṼṾƲꝞɅ" }, { base: "VY", letters: "Ꝡ" }, { base: "W", letters: "WⓌＷẀẂŴẆẄẈⱲ" }, { base: "X", letters: "XⓍＸẊẌ" }, { base: "Y", letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ" }, { base: "Z", letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ" }, { base: "a", letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ" }, { base: "aa", letters: "ꜳ" }, { base: "ae", letters: "æǽǣ" }, { base: "ao", letters: "ꜵ" }, { base: "au", letters: "ꜷ" }, { base: "av", letters: "ꜹꜻ" }, { base: "ay", letters: "ꜽ" }, { base: "b", letters: "bⓑｂḃḅḇƀƃɓ" }, { base: "c", letters: "cⓒｃćĉċčçḉƈȼꜿↄ" }, { base: "d", letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ" }, { base: "dz", letters: "ǳǆ" }, { base: "e", letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ" }, { base: "f", letters: "fⓕｆḟƒꝼ" }, { base: "g", letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ" }, { base: "h", letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ" }, { base: "hv", letters: "ƕ" }, { base: "i", letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı" }, { base: "j", letters: "jⓙｊĵǰɉ" }, { base: "k", letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ" }, { base: "l", letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ" }, { base: "lj", letters: "ǉ" }, { base: "m", letters: "mⓜｍḿṁṃɱɯ" }, { base: "n", letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ" }, { base: "nj", letters: "ǌ" }, { base: "o", letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ" }, { base: "oi", letters: "ƣ" }, { base: "ou", letters: "ȣ" }, { base: "oo", letters: "ꝏ" }, { base: "p", letters: "pⓟｐṕṗƥᵽꝑꝓꝕ" }, { base: "q", letters: "qⓠｑɋꝗꝙ" }, { base: "r", letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ" }, { base: "s", letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ" }, { base: "t", letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ" }, { base: "tz", letters: "ꜩ" }, { base: "u", letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ" }, { base: "v", letters: "vⓥｖṽṿʋꝟʌ" }, { base: "vy", letters: "ꝡ" }, { base: "w", letters: "wⓦｗẁẃŵẇẅẘẉⱳ" }, { base: "x", letters: "xⓧｘẋẍ" }, { base: "y", letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ" }, { base: "z", letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ" }], Ds = {}; for (let n = 0; n < Ea.length; n += 1) { const e = Ea[n].letters; for (let t = 0; t < e.length; t += 1)Ds[e[t]] = Ea[n].base } function jt(n) { return n.replace(/[^\u0000-\u007E]/g, e => Ds[e] || e) } let On = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = R({ on: {} }, e.params.smartSelect); a.useModulesParams(s), a.params = R({}, s, t), a.app = e; const r = y(a.params.el).eq(0); if (r.length === 0) return a; if (r[0].f7SmartSelect) return r[0].f7SmartSelect; const i = r.find("select").eq(0); if (i.length === 0) return a; let o; a.params.setValueText && (o = y(a.params.valueEl), o.length === 0 && (o = r.find(".item-after")), o.length === 0 && (o = y('<div class="item-after"></div>'), o.insertAfter(r.find(".item-title")))); let l = t.url; l || (r.attr("href") && r.attr("href") !== "#" ? l = r.attr("href") : i.attr("name") && (l = `${i.attr("name").toLowerCase()}-select/`)), l || (l = a.params.url); const c = i[0].multiple, d = c ? "checkbox" : "radio", u = wt(); R(a, { $el: r, el: r[0], $selectEl: i, selectEl: i[0], $valueEl: o, valueEl: o && o[0], url: l, multiple: c, inputType: d, id: u, inputName: `${d}-${u}`, selectName: i.attr("name"), maxLength: i.attr("maxlength") || t.maxLength }), r[0].f7SmartSelect = a; function p() { a.open() } function m() { const h = a.$selectEl.val(); a.$el.trigger("smartselect:change", h), a.emit("local::change smartSelectChange", a, h), a.vl && a.vl.clearCache(), a.setValueText() } a.attachEvents = function () { r.on("click", p), r.on("change", "select", m) }, a.detachEvents = function () { r.off("click", p), r.off("change", "select", m) }; function f() { let h, b; const g = this, v = g.value; let E = [], $; if (g.type === "checkbox") { for (let w = 0; w < a.selectEl.options.length; w += 1)h = a.selectEl.options[w], h.value === v && (h.selected = g.checked), h.selected && ($ = h.dataset ? h.dataset.displayAs : y(h).data("display-value-as"), b = $ && typeof $ < "u" ? $ : h.textContent, E.push(b.trim())); a.maxLength && a.checkMaxLength() } else h = a.$selectEl.find(`option[value="${v}"]`)[0], h || (h = a.$selectEl.find("option").filter(w => w.value === v)[0]), $ = h.dataset ? h.dataset.displayAs : y(h).data("display-as"), b = $ && typeof $ < "u" ? $ : h.textContent, E = [b], a.selectEl.value = v; a.$selectEl.trigger("change"), a.params.setValueText && a.formatValueTextContent(E), a.params.closeOnSelect && a.inputType === "radio" && a.close() } return a.attachInputsEvents = function () { a.$containerEl.on("change", 'input[type="checkbox"], input[type="radio"]', f) }, a.detachInputsEvents = function () { a.$containerEl.off("change", 'input[type="checkbox"], input[type="radio"]', f) }, a.useModules(), a.init(), a } setValue(e) { const t = this; let a = e, s = [], r, i, o; if (t.multiple) { Array.isArray(a) || (a = [a]); for (let l = 0; l < t.selectEl.options.length; l += 1)r = t.selectEl.options[l], a.indexOf(r.value) >= 0 ? r.selected = !0 : r.selected = !1, r.selected && (i = r.dataset ? r.dataset.displayAs : y(r).data("display-value-as"), o = i && typeof i < "u" ? i : r.textContent, s.push(o.trim())) } else r = t.$selectEl.find(`option[value="${a}"]`)[0], r && (i = r.dataset ? r.dataset.displayAs : y(r).data("display-as"), o = i && typeof i < "u" ? i : r.textContent, s = [o]), t.selectEl.value = a; return t.params.setValueText && t.formatValueTextContent(s), t.$selectEl.trigger("change"), t } unsetValue() { const e = this; e.params.setValueText && e.formatValueTextContent([]), e.$selectEl.find("option").each(t => { t.selected = !1, t.checked = !1 }), e.$selectEl[0].value = null, e.$containerEl && e.$containerEl.find(`input[name="${e.inputName}"][type="checkbox"], input[name="${e.inputName}"][type="radio"]`).prop("checked", !1), e.$selectEl.trigger("change") } getValue() { return this.$selectEl.val() } get view() { const { params: e, $el: t } = this; let a; if (e.view && (a = e.view), a || (a = t.parents(".view").length && t.parents(".view")[0].f7View), !a && e.openIn === "page") throw Error("Smart Select requires initialized View"); return a } checkMaxLength() { const e = this, t = e.$containerEl; e.selectEl.selectedOptions.length >= e.maxLength ? t.find('input[type="checkbox"]').each(a => { a.checked ? y(a).parents("li").removeClass("disabled") : y(a).parents("li").addClass("disabled") }) : t.find(".disabled").removeClass("disabled") } formatValueTextContent(e) { const t = this, a = t.formatValueText(e); a.includes("<") && a.includes(">") ? t.$valueEl.html(a) : t.$valueEl.text(a) } formatValueText(e) { const t = this; let a; return t.params.formatValueText ? a = t.params.formatValueText.call(t, e, t) : a = e.join(", "), a } setValueText(e) { const t = this; let a = []; typeof e < "u" ? Array.isArray(e) ? a = e : a = [e] : t.$selectEl.find("option").each(s => { const r = y(s); if (s.selected) { const i = s.dataset ? s.dataset.displayAs : r.data("display-value-as"); i && typeof i < "u" ? a.push(i) : a.push(s.textContent.trim()) } }), t.params.setValueText && t.formatValueTextContent(a) } getItemsData() { const e = this, t = e.app.theme, a = []; let s; return e.$selectEl.find("option").each(r => { const i = y(r), o = i.dataset(), l = o.optionImage || e.params.optionImage, c = o.optionIcon || e.params.optionIcon, d = t === "ios" && (o.optionIconIos || e.params.optionIconIos), u = t === "md" && (o.optionIconMd || e.params.optionIconMd), p = o.inputIconPosition || e.params.inputIconPosition || "", m = l || c || d || u, f = o.optionColor; let h = o.optionClass || ""; i[0].disabled && (h += " disabled"); const b = i.parent("optgroup")[0], g = b && b.label; let v = !1; b && b !== s && (v = !0, s = b, a.push({ groupLabel: g, isLabel: v })), a.push({ value: i[0].value, text: i[0].textContent.trim(), selected: i[0].selected, groupEl: b, groupLabel: g, image: l, icon: c, iconIos: d, iconMd: u, inputIconPosition: p, color: f, className: h, disabled: i[0].disabled, id: e.id, hasMedia: m, checkbox: e.inputType === "checkbox", radio: e.inputType === "radio", inputName: e.inputName, inputType: e.inputType }) }), e.items = a, a } renderSearchbar() { const e = this; return e.params.renderSearchbar ? e.params.renderSearchbar.call(e) : x("form", { class: "searchbar" }, x("div", { class: "searchbar-inner" }, x("div", { class: "searchbar-input-wrap" }, x("input", { type: "search", spellcheck: e.params.searchbarSpellcheck || "false", placeholder: e.params.searchbarPlaceholder }), x("i", { class: "searchbar-icon" }), x("span", { class: "input-clear-button" })), e.params.searchbarDisableButton && x("span", { class: "searchbar-disable-button" }, e.params.searchbarDisableText))) } renderItem(e, t) { const a = this; if (a.params.renderItem) return a.params.renderItem.call(a, e, t); function s(o) { return o === void 0 && (o = ""), o.indexOf(":") >= 0 ? o.split(":")[1] : "" } function r(o) { if (o === void 0 && (o = ""), o.indexOf(":") >= 0) { let l = o.split(":")[0]; return l === "f7" && (l = "f7-icons"), l === "material" && (l = "material-icons"), l } return o } let i; if (e.isLabel) i = `<li class="list-group-title">${e.groupLabel}</li>`; else { let o = e.selected, l; if (a.params.virtualList) { const h = a.getValue(); o = a.multiple ? h.indexOf(e.value) >= 0 : h === e.value, a.multiple && (l = a.multiple && !o && h.length === parseInt(a.maxLength, 10)) } const { icon: c, iconIos: d, iconMd: u } = e, p = c || d || u, m = s(c || d || u || ""), f = r(c || d || u || ""); i = x("li", { class: `${e.className || ""}${l ? " disabled" : ""}` }, x("label", { class: `item-${e.inputType} ${e.inputIconPosition ? `item-${e.inputType}-icon-${e.inputIconPosition}` : ""} item-content` }, x("input", { type: e.inputType, name: e.inputName, value: e.value, _checked: o }), x("i", { class: `icon icon-${e.inputType}` }), e.hasMedia && x("div", { class: "item-media" }, p && x("i", { class: `icon ${f}` }, m), e.image && x("img", { src: e.image })), x("div", { class: "item-inner" }, x("div", { class: `item-title${e.color ? ` text-color-${e.color}` : ""}` }, e.text)))) } return i } renderItems() {
    const e = this; return e.params.renderItems ? e.params.renderItems.call(e, e.items) : `
      ${e.items.map((a, s) => `${e.renderItem(a, s)}`).join("")}
    `} renderPage() { const e = this; if (e.params.renderPage) return e.params.renderPage.call(e, e.items); let t = e.params.pageTitle; if (typeof t > "u") { const s = e.$el.find(".item-title"); t = s.length ? s.text().trim() : "" } const a = e.params.cssClass; return x("div", { class: `page smart-select-page ${a}`, "data-name": "smart-select-page", "data-select-name": e.selectName }, x("div", { class: `navbar ${e.params.navbarColorTheme ? `color-${e.params.navbarColorTheme}` : ""}` }, x("div", { class: "navbar-bg" }), x("div", { class: `navbar-inner sliding ${e.params.navbarColorTheme ? `color-${e.params.navbarColorTheme}` : ""}` }, x("div", { class: "left" }, x("a", { class: "link back" }, x("i", { class: "icon icon-back" }), x("span", { class: "if-not-md" }, e.params.pageBackLinkText))), t && x("div", { class: "title" }, t), e.params.searchbar && x("div", { class: "subnavbar" }, e.renderSearchbar()))), e.params.searchbar && x("div", { class: "searchbar-backdrop" }), x("div", { class: "page-content" }, x("div", { class: `list list-outline-ios list-strong-ios list-dividers-ios smart-select-list-${e.id} ${e.params.virtualList ? " virtual-list" : ""} ${e.params.formColorTheme ? `color-${e.params.formColorTheme}` : ""}` }, x("ul", null, !e.params.virtualList && e.renderItems(e.items))))) } renderPopup() { const e = this; if (e.params.renderPopup) return e.params.renderPopup.call(e, e.items); let t = e.params.pageTitle; if (typeof t > "u") { const s = e.$el.find(".item-title"); t = s.length ? s.text().trim() : "" } const a = e.params.cssClass || ""; return x("div", { class: `popup smart-select-popup ${a} ${e.params.popupTabletFullscreen ? "popup-tablet-fullscreen" : ""}`, "data-select-name": e.selectName }, x("div", { class: "view" }, x("div", { class: `page smart-select-page ${e.params.searchbar ? "page-with-subnavbar" : ""}`, "data-name": "smart-select-page" }, x("div", { class: `navbar ${e.params.navbarColorTheme ? `color-${e.params.navbarColorTheme}` : ""}` }, x("div", { class: "navbar-bg" }), x("div", { class: "navbar-inner sliding" }, t && x("div", { class: "title" }, t), x("div", { class: "right" }, x("a", { class: "link popup-close", "data-popup": `.smart-select-popup[data-select-name='${e.selectName}']` }, e.params.popupCloseLinkText)), e.params.searchbar && x("div", { class: "subnavbar" }, e.renderSearchbar()))), e.params.searchbar && x("div", { class: "searchbar-backdrop" }), x("div", { class: "page-content" }, x("div", { class: `list list-outline-ios list-strong-ios list-dividers-ios smart-select-list-${e.id} ${e.params.virtualList ? " virtual-list" : ""} ${e.params.formColorTheme ? `color-${e.params.formColorTheme}` : ""}` }, x("ul", null, !e.params.virtualList && e.renderItems(e.items))))))) } renderSheet() { const e = this; if (e.params.renderSheet) return e.params.renderSheet.call(e, e.items); const t = e.params.cssClass; return x("div", { class: `sheet-modal smart-select-sheet ${t}`, "data-select-name": e.selectName }, x("div", { class: `toolbar toolbar-top ${e.params.toolbarColorTheme ? `color-${e.params.toolbarColorTheme}` : ""}` }, x("div", { class: "toolbar-inner" }, x("div", { class: "left" }), x("div", { class: "right" }, x("a", { class: "link sheet-close" }, e.params.sheetCloseLinkText)))), x("div", { class: "sheet-modal-inner" }, x("div", { class: "page-content" }, x("div", { class: `list list-strong-ios list-dividers-ios smart-select-list-${e.id} ${e.params.virtualList ? " virtual-list" : ""} ${e.params.formColorTheme ? `color-${e.params.formColorTheme}` : ""}` }, x("ul", null, !e.params.virtualList && e.renderItems(e.items)))))) } renderPopover() { const e = this; if (e.params.renderPopover) return e.params.renderPopover.call(e, e.items); const t = e.params.cssClass; return x("div", { class: `popover smart-select-popover ${t}`, "data-select-name": e.selectName }, x("div", { class: "popover-inner" }, x("div", { class: `list list-strong-ios list-dividers-ios smart-select-list-${e.id} ${e.params.virtualList ? " virtual-list" : ""} ${e.params.formColorTheme ? `color-${e.params.formColorTheme}` : ""}` }, x("ul", null, !e.params.virtualList && e.renderItems(e.items))))) } scrollToSelectedItem() { const e = this, { params: t, $containerEl: a } = e; if (!e.opened) return e; if (t.virtualList) { let s; e.vl.items.forEach((r, i) => { typeof s > "u" && r.selected && (s = i) }), typeof s < "u" && e.vl.scrollToItem(s) } else { const s = a.find("input:checked").parents("li"); if (!s.length) return e; const r = a.find(".page-content, .popover-inner"); if (!r.length) return e; r.scrollTop(s.offset().top - r.offset().top - parseInt(r.css("padding-top"), 10)) } return e } onOpen(e, t) { const a = this, s = a.app, r = y(t); if (a.$containerEl = r, a.openedIn = e, a.opened = !0, a.params.virtualList && (a.vl = s.virtualList.create({ el: r.find(".virtual-list"), items: a.items, renderItem: a.renderItem.bind(a), height: a.params.virtualListHeight, searchByItem(i, o) { return !!(o.text && jt(o.text).toLowerCase().indexOf(i.trim().toLowerCase()) >= 0) } })), a.params.scrollToSelectedItem && a.scrollToSelectedItem(), a.params.searchbar) { let i = r.find(".searchbar"); if (e === "page" && s.theme === "ios" && (i = y(s.navbar.getElByPage(r)).find(".searchbar")), a.params.appendSearchbarNotFound && (e === "page" || e === "popup")) { let l = null; typeof a.params.appendSearchbarNotFound == "string" ? l = y(`<div class="block searchbar-not-found">${a.params.appendSearchbarNotFound}</div>`) : typeof a.params.appendSearchbarNotFound == "boolean" ? l = y('<div class="block searchbar-not-found">Nothing found</div>') : l = a.params.appendSearchbarNotFound, l && r.find(".page-content").append(l[0]) } const o = R({ el: i, backdropEl: r.find(".searchbar-backdrop"), searchContainer: `.smart-select-list-${a.id}`, searchIn: ".item-title" }, typeof a.params.searchbar == "object" ? a.params.searchbar : {}); a.searchbar = s.searchbar.create(o) } a.maxLength && a.checkMaxLength(), a.params.closeOnSelect && a.$containerEl.find(`input[type="radio"][name="${a.inputName}"]:checked`).parents("label").once("click", () => { a.close() }), a.attachInputsEvents(), a.$el.trigger("smartselect:open"), a.emit("local::open smartSelectOpen", a) } onOpened() { const e = this; e.$el.trigger("smartselect:opened"), e.emit("local::opened smartSelectOpened", e) } onClose() { const e = this; e.destroyed || (e.vl && e.vl.destroy && (e.vl.destroy(), e.vl = null, delete e.vl), e.searchbar && e.searchbar.destroy && (e.searchbar.destroy(), e.searchbar = null, delete e.searchbar), e.detachInputsEvents(), e.$el.trigger("smartselect:close"), e.emit("local::close smartSelectClose", e)) } onClosed() { const e = this; e.destroyed || (e.opened = !1, e.$containerEl = null, delete e.$containerEl, e.$el.trigger("smartselect:closed"), e.emit("local::closed smartSelectClosed", e)) } openPage() { const e = this; if (e.opened) return e; e.getItemsData(); const t = e.renderPage(e.items); return e.view.router.navigate({ url: e.url, route: { content: t, path: e.url, on: { pageBeforeIn(a, s) { e.onOpen("page", s.el) }, pageAfterIn(a, s) { e.onOpened("page", s.el) }, pageBeforeOut(a, s) { e.onClose("page", s.el) }, pageAfterOut(a, s) { e.onClosed("page", s.el) } } } }), e } openPopup() { const e = this; if (e.opened) return e; e.getItemsData(); const a = { content: e.renderPopup(e.items), push: e.params.popupPush, swipeToClose: e.params.popupSwipeToClose, closeByBackdropClick: e.params.closeByBackdropClick, on: { popupOpen(s) { e.onOpen("popup", s.el) }, popupOpened(s) { e.onOpened("popup", s.el) }, popupClose(s) { e.onClose("popup", s.el) }, popupClosed(s) { e.onClosed("popup", s.el) } } }; return e.params.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, popup: a } }) : e.modal = e.app.popup.create(a).open(), e } openSheet() { const e = this; if (e.opened) return e; e.getItemsData(); const a = { content: e.renderSheet(e.items), backdrop: e.params.sheetBackdrop, scrollToEl: e.$el, closeByOutsideClick: !0, push: e.params.sheetPush, swipeToClose: e.params.sheetSwipeToClose, closeByBackdropClick: e.params.closeByBackdropClick, on: { sheetOpen(s) { e.onOpen("sheet", s.el) }, sheetOpened(s) { e.onOpened("sheet", s.el) }, sheetClose(s) { e.onClose("sheet", s.el) }, sheetClosed(s) { e.onClosed("sheet", s.el) } } }; return e.params.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, sheet: a } }) : e.modal = e.app.sheet.create(a).open(), e } openPopover() { const e = this; if (e.opened) return e; e.getItemsData(); const a = { content: e.renderPopover(e.items), targetEl: e.$el, closeByBackdropClick: e.params.closeByBackdropClick, on: { popoverOpen(s) { e.onOpen("popover", s.el) }, popoverOpened(s) { e.onOpened("popover", s.el) }, popoverClose(s) { e.onClose("popover", s.el) }, popoverClosed(s) { e.onClosed("popover", s.el) } } }; return e.params.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, popover: a } }) : e.modal = e.app.popover.create(a).open(), e } open(e) { const t = this; if (t.opened) return t; let a = !1; function s() { a = !0 } if (t.$el && t.$el.trigger("smartselect:beforeopen", { prevent: s }), t.emit("local::beforeOpen smartSelectBeforeOpen", t, s), a) return t; const r = e || t.params.openIn; return t[`open${r.split("").map((i, o) => o === 0 ? i.toUpperCase() : i).join("")}`](), t } close() { const e = this; return e.opened && (e.params.routableModals && e.view || e.openedIn === "page" ? e.view.router.back() : (e.modal.once("modalClosed", () => { $e(() => { e.destroyed || (e.modal.destroy(), delete e.modal) }) }), e.modal.close())), e } init() { const e = this; e.attachEvents(), e.setValueText() } destroy() { const e = this; e.emit("local::beforeDestroy smartSelectBeforeDestroy", e), e.$el.trigger("smartselect:beforedestroy"), e.detachEvents(), delete e.$el[0].f7SmartSelect, ve(e), e.destroyed = !0 }
}; const tc = { name: "smartSelect", params: { smartSelect: { el: void 0, valueEl: void 0, setValueText: !0, formatValueText: null, openIn: "page", popupPush: !1, popupSwipeToClose: void 0, sheetPush: !1, sheetSwipeToClose: void 0, sheetBackdrop: !1, pageTitle: void 0, pageBackLinkText: "Back", popupCloseLinkText: "Close", popupTabletFullscreen: !1, closeByBackdropClick: !0, sheetCloseLinkText: "Done", searchbar: !1, searchbarPlaceholder: "Search", searchbarDisableText: "Cancel", searchbarDisableButton: !0, searchbarSpellcheck: !1, closeOnSelect: !1, virtualList: !1, virtualListHeight: void 0, scrollToSelectedItem: !1, formColorTheme: void 0, navbarColorTheme: void 0, routableModals: !1, url: "select/", inputIconPosition: "start", cssClass: "", renderPage: void 0, renderPopup: void 0, renderSheet: void 0, renderPopover: void 0, renderItems: void 0, renderItem: void 0, renderSearchbar: void 0 } }, static: { SmartSelect: On }, create() { const n = this; n.smartSelect = R(we({ defaultSelector: ".smart-select", constructor: On, app: n, domProp: "f7SmartSelect" }), { open(e) { const t = n.smartSelect.get(e); if (t && t.open) return t.open() }, close(e) { const t = n.smartSelect.get(e); if (t && t.close) return t.close() } }) }, on: { tabMounted(n) { const e = this; y(n).find(".smart-select-init").each(t => { e.smartSelect.create(R({ el: t }, y(t).dataset())) }) }, tabBeforeRemove(n) { y(n).find(".smart-select-init").each(e => { e.f7SmartSelect && e.f7SmartSelect.destroy && e.f7SmartSelect.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".smart-select-init").each(t => { e.smartSelect.create(R({ el: t }, y(t).dataset())) }) }, pageBeforeRemove(n) { n.$el.find(".smart-select-init").each(e => { e.f7SmartSelect && e.f7SmartSelect.destroy && e.f7SmartSelect.destroy() }) } }, clicks: { ".smart-select": function (e, t) { const a = this; e[0].f7SmartSelect || a.smartSelect.create(R({ el: e }, t)).open() } }, vnode: { "smart-select-init": { insert(n) { const e = this, t = n.elm; e.smartSelect.create(R({ el: t }, y(t).dataset())) }, destroy(n) { const e = n.elm; e.f7SmartSelect && e.f7SmartSelect.destroy && e.f7SmartSelect.destroy() } } } }, ac = { name: "grid" }; let Bn = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this; a.params = R({}, e.params.calendar, t); let s; if (a.params.containerEl && (s = y(a.params.containerEl), s.length === 0)) return a; let r; a.params.inputEl && (r = y(a.params.inputEl)); const i = a.params.direction === "horizontal"; let o = 1; i && (o = e.rtl ? -1 : 1), R(a, { app: e, $containerEl: s, containerEl: s && s[0], inline: s && s.length > 0, $inputEl: r, inputEl: r && r[0], initialized: !1, opened: !1, url: a.params.url, isHorizontal: i, inverter: o, animating: !1, allowTouchMove: !0, hasTimePicker: a.params.timePicker && !a.params.rangePicker && !a.params.multiple }), a.dayFormatter = w => new Intl.DateTimeFormat(a.params.locale, { day: "numeric" }).format(w).replace(/日/, ""), a.monthFormatter = w => new Intl.DateTimeFormat(a.params.locale, { month: "long" }).format(w), a.yearFormatter = w => new Intl.DateTimeFormat(a.params.locale, { year: "numeric" }).format(w), a.timeSelectorFormatter = w => new Intl.DateTimeFormat(a.params.locale, a.params.timePickerFormat).format(w); const l = a.timeSelectorFormatter(new Date).toLowerCase(); a.is12HoursFormat = l.indexOf("pm") >= 0 || l.indexOf("am") >= 0; let { monthNames: c, monthNamesShort: d, dayNames: u, dayNamesShort: p } = a.params; const { monthNamesIntl: m, monthNamesShortIntl: f, dayNamesIntl: h, dayNamesShortIntl: b } = a.getIntlNames(); c === "auto" && (c = m), d === "auto" && (d = f), u === "auto" && (u = h), p === "auto" && (p = b), R(a, { monthNames: c, monthNamesShort: d, dayNames: u, dayNamesShort: p }); function g() { a.open() } function v(w) { w.preventDefault() } function E() { a.setValue([]), a.opened && a.update() } function $(w) { const C = y(w.target); a.destroyed || !a.params || a.isPopover() || !a.opened || a.closing || C.closest('[class*="backdrop"]').length || a.monthPickerPopover || a.yearPickerPopover || a.timePickerPopover || (r && r.length > 0 ? C[0] !== r[0] && C.closest(".sheet-modal, .calendar-modal").length === 0 && a.close() : y(w.target).closest(".sheet-modal, .calendar-modal").length === 0 && a.close()) } return R(a, { attachInputEvents() { a.$inputEl.on("click", g), a.$inputEl.on("input:clear", E), a.params.inputReadOnly && (a.$inputEl.on("focus mousedown", v), a.$inputEl[0] && (a.$inputEl[0].f7ValidateReadonly = !0)) }, detachInputEvents() { a.$inputEl.off("click", g), a.$inputEl.off("input:clear", E), a.params.inputReadOnly && (a.$inputEl.off("focus mousedown", v), a.$inputEl[0] && delete a.$inputEl[0].f7ValidateReadonly) }, attachHtmlEvents() { e.on("click", $) }, detachHtmlEvents() { e.off("click", $) } }), a.attachCalendarEvents = function () { let C = !0, k, M, A, O, S, P, T, I, H, D, z, B, L, N; const { $el: F, $wrapperEl: V } = a; function _(te) { M || k || !te.isTrusted || (k = !0, A = te.type === "touchstart" ? te.targetTouches[0].pageX : te.pageX, S = A, O = te.type === "touchstart" ? te.targetTouches[0].pageY : te.pageY, P = O, T = new Date().getTime(), B = 0, C = !0, N = void 0, H = a.monthsTranslate) } function J(te) { if (!k || !te.isTrusted) return; const { isHorizontal: le } = a; if (S = te.type === "touchmove" ? te.targetTouches[0].pageX : te.pageX, P = te.type === "touchmove" ? te.targetTouches[0].pageY : te.pageY, typeof N > "u" && (N = !!(N || Math.abs(P - O) > Math.abs(S - A))), le && N || !a.allowTouchMove) { k = !1; return } if (te.preventDefault(), a.animating) { k = !1; return } C = !1, M || (M = !0, D = V[0].offsetWidth, z = V[0].offsetHeight, V.transition(0)), L = le ? S - A : P - O, B = L / (le ? D : z), H = (a.monthsTranslate * a.inverter + B) * 100, V.transform(`translate3d(${le ? H : 0}%, ${le ? 0 : H}%, 0)`) } function Q(te) { if (!k || !M || !te.isTrusted) { k = !1, M = !1; return } k = !1, M = !1, I = new Date().getTime(), I - T < 300 ? Math.abs(L) < 10 ? a.resetMonth() : L >= 10 ? e.rtl ? a.nextMonth() : a.prevMonth() : e.rtl ? a.prevMonth() : a.nextMonth() : B <= -.5 ? e.rtl ? a.prevMonth() : a.nextMonth() : B >= .5 ? e.rtl ? a.nextMonth() : a.prevMonth() : a.resetMonth(), setTimeout(() => { C = !0 }, 100) } function j(te) { if (!C) return; let le = y(te.target).parents(".calendar-day"); if (le.length === 0 && y(te.target).hasClass("calendar-day") && (le = y(te.target)), le.length === 0 || le.hasClass("calendar-day-disabled")) return; a.params.rangePicker || (le.hasClass("calendar-day-next") && a.nextMonth(), le.hasClass("calendar-day-prev") && a.prevMonth()); const ce = parseInt(le.attr("data-year"), 10), de = parseInt(le.attr("data-month"), 10), q = parseInt(le.attr("data-day"), 10); if (a.emit("local::dayClick calendarDayClick", a, le[0], ce, de, q), !le.hasClass("calendar-day-selected") || a.params.multiple || a.params.rangePicker) { const pe = new Date(ce, de, q, 0, 0, 0); a.hasTimePicker && (a.value && a.value[0] ? pe.setHours(a.value[0].getHours(), a.value[0].getMinutes()) : pe.setHours(new Date().getHours(), new Date().getMinutes())), a.addValue(pe) } a.params.closeOnSelect && (a.params.rangePicker && a.value.length === 2 || !a.params.rangePicker) && a.close() } function Y() { a.nextMonth() } function X() { a.prevMonth() } function K() { a.nextYear() } function W() { a.prevYear() } function G() { a.openMonthPicker() } function Z() { a.openYearPicker() } function ie() { a.openTimePicker() } const ge = e.touchEvents.start === "touchstart" && Ee().passiveListener ? { passive: !0, capture: !1 } : !1; F.find(".calendar-prev-month-button").on("click", X), F.find(".calendar-next-month-button").on("click", Y), F.find(".calendar-prev-year-button").on("click", W), F.find(".calendar-next-year-button").on("click", K), a.params.monthPicker && F.find(".current-month-value").on("click", G), a.params.yearPicker && F.find(".current-year-value").on("click", Z), a.hasTimePicker && F.find(".calendar-time-selector a").on("click", ie), V.on("click", j), a.params.touchMove && (V.on(e.touchEvents.start, _, ge), e.on("touchmove:active", J), e.on("touchend:passive", Q)), a.detachCalendarEvents = function () { F.find(".calendar-prev-month-button").off("click", X), F.find(".calendar-next-month-button").off("click", Y), F.find(".calendar-prev-year-button").off("click", W), F.find(".calendar-next-year-button").off("click", K), a.params.monthPicker && F.find(".current-month-value").off("click", G), a.params.yearPicker && F.find(".current-year-value").off("click", Z), a.hasTimePicker && F.find(".calendar-time-selector a").off("click", ie), V.off("click", j), a.params.touchMove && (V.off(e.touchEvents.start, _, ge), e.off("touchmove:active", J), e.off("touchend:passive", Q)) } }, a.init(), a } get view() { const { $inputEl: e, app: t, params: a } = this; let s; return a.view ? s = a.view : e && (s = e.parents(".view").length && e.parents(".view")[0].f7View), s || (s = t.views.main), s } getIntlNames() { const e = this, t = e.params.locale, a = [], s = [], r = [], i = [], o = new Intl.DateTimeFormat(t, { month: "long" }), l = new Intl.DateTimeFormat(t, { month: "short" }), c = new Intl.DateTimeFormat(t, { weekday: "long" }), d = new Intl.DateTimeFormat(t, { weekday: "short" }); let u, p, m; for (let h = 0; h < 24; h += 1) { const b = new Date().setMonth(h, 1), g = e.yearFormatter(b); u && g !== u && (p && (m = !0), p = !0, u = g), u || (u = g), p && u === g && !m && (a.push(o.format(b)), s.push(l.format(b))) } const f = new Date().getDay(); for (let h = 0; h < 7; h += 1) { const b = new Date().getTime() + (h - f) * 24 * 60 * 60 * 1e3; r.push(c.format(b)), i.push(d.format(b)) } return { monthNamesIntl: a, monthNamesShortIntl: s, dayNamesIntl: r, dayNamesShortIntl: i } } normalizeDate(e) { const t = this, a = new Date(e); return t.hasTimePicker ? new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes()) : new Date(a.getFullYear(), a.getMonth(), a.getDate()) } normalizeValues(e) { const t = this; let a = []; return e && Array.isArray(e) && (a = e.map(s => t.normalizeDate(s))), a } initInput() { const e = this; e.$inputEl && e.params.inputReadOnly && e.$inputEl.prop("readOnly", !0) } isPopover() { const e = this, { app: t, modal: a, params: s } = e, r = ue(); if (s.openIn === "sheet" || a && a.type !== "popover") return !1; if (!e.inline && e.inputEl) { if (s.openIn === "popover") return !0; if (r.ios) return !!r.ipad; if (t.width >= 768) return !0 } return !1 } formatDate(e) { const t = this, a = new Date(e), s = a.getFullYear(), r = a.getMonth(), i = r + 1, o = a.getDate(), l = a.getDay(), { monthNames: c, monthNamesShort: d, dayNames: u, dayNamesShort: p } = t, { dateFormat: m, locale: f } = t.params; function h(g) { return g < 10 ? `0${g}` : g } if (typeof m == "string") { const g = { yyyy: s, yy: String(s).substring(2), mm: h(i), m: i, MM: c[r], M: d[r], dd: h(o), d: o, DD: u[l], D: p[l] }; if (t.params.timePicker) { const E = a.getHours(), $ = a.getMinutes(), w = a.getSeconds(); let C = E; E > 12 && (C = E - 12), E === 0 && (C = 12); const k = E >= 12 && E !== 0 ? "pm" : "am"; Object.assign(g, { HH: h(E), H: E, hh: h(C), h: C, ss: h(w), s: w, ":mm": h($), ":m": $, a: k, A: k.toUpperCase() }) } const v = new RegExp(Object.keys(g).map(E => `(${E})`).join("|"), "g"); return m.replace(v, E => E in g ? g[E] : E) } return typeof m == "function" ? m(a) : new Intl.DateTimeFormat(f, m).format(a) } formatValue() { const e = this, { value: t } = e; return e.params.formatValue ? e.params.formatValue.call(e, t) : t.map(a => e.formatDate(a)).join(e.params.rangePicker ? " - " : ", ") } addValue(e) { const t = this, { multiple: a, rangePicker: s, rangePickerMinDays: r, rangePickerMaxDays: i } = t.params; if (a) { t.value || (t.value = []); let o; for (let l = 0; l < t.value.length; l += 1)new Date(e).getTime() === new Date(t.value[l]).getTime() && (o = l); typeof o > "u" ? t.value.push(e) : t.value.splice(o, 1), t.updateValue() } else s ? (t.value || (t.value = []), (t.value.length === 2 || t.value.length === 0) && (t.value = []), t.value.length === 0 || Math.abs(t.value[0].getTime() - e.getTime()) >= (r - 1) * 60 * 60 * 24 * 1e3 && (i === 0 || Math.abs(t.value[0].getTime() - e.getTime()) <= (i - 1) * 60 * 60 * 24 * 1e3) ? t.value.push(e) : t.value = [], t.value.sort((o, l) => o - l), t.updateValue()) : (t.value = [e], t.updateValue()) } setValue(e) { const t = this, a = t.value; if (Array.isArray(a) && Array.isArray(e) && a.length === e.length) { let s = !0; if (a.forEach((r, i) => { r !== e[i] && (s = !1) }), s) return } t.value = e, t.updateValue() } getValue() { return this.value } updateValue(e) { const t = this, { $el: a, $wrapperEl: s, $inputEl: r, value: i, params: o } = t; let l; if (a && a.length > 0) { s.find(".calendar-day-selected").removeClass("calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right"); let c; if (o.rangePicker && i.length === 2) { const d = new Date(i[0]).getTime(), u = new Date(i[1]).getTime(); for (l = d; l <= u; l += 24 * 60 * 60 * 1e3) { c = new Date(l); let p = "calendar-day-selected"; d !== u && (l !== d && l !== u && (p += " calendar-day-selected-range"), l === d && (p += " calendar-day-selected-left"), l === u && (p += " calendar-day-selected-right")), s.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).addClass(p) } c = new Date(d), s.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-left"), c = new Date(u), s.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-right") } else for (l = 0; l < t.value.length; l += 1)c = new Date(i[l]), s.find(`.calendar-day[data-date="${c.getFullYear()}-${c.getMonth()}-${c.getDate()}"]`).addClass("calendar-day-selected") } if (e || t.emit("local::change calendarChange", t, i), a && a.length > 0 && t.hasTimePicker && a.find(".calendar-time-selector a").text(i && i.length ? t.timeSelectorFormatter(i[0]) : t.params.timePickerPlaceholder), r && r.length || o.header) { const c = t.formatValue(i); o.header && a && a.length && a.find(".calendar-selected-date").text(c), r && r.length && !e && (r.val(c), r.trigger("change")) } } updateCurrentMonthYear(e) { const t = this, { $months: a, $el: s, monthNames: r } = t; let i, o; typeof e > "u" ? (t.currentMonth = parseInt(a.eq(1).attr("data-month"), 10), t.currentYear = parseInt(a.eq(1).attr("data-year"), 10), i = a.eq(1).attr("data-locale-month"), o = a.eq(1).attr("data-locale-year")) : (t.currentMonth = parseInt(a.eq(e === "next" ? a.length - 1 : 0).attr("data-month"), 10), t.currentYear = parseInt(a.eq(e === "next" ? a.length - 1 : 0).attr("data-year"), 10), i = a.eq(e === "next" ? a.length - 1 : 0).attr("data-locale-month"), o = a.eq(e === "next" ? a.length - 1 : 0).attr("data-locale-year")), s.find(".current-month-value").text(r[i]), s.find(".current-year-value").text(o) } update() { const e = this, { currentYear: t, currentMonth: a, $wrapperEl: s } = e, r = new Date(t, a), i = e.renderMonth(r, "prev"), o = e.renderMonth(r), l = e.renderMonth(r, "next"); s.transition(0).html(`${i}${o}${l}`).transform("translate3d(0,0,0)"), e.$months = s.find(".calendar-month"), e.monthsTranslate = 0, e.setMonthsTranslate(), e.$months.each(c => { e.emit("local::monthAdd calendarMonthAdd", c) }) } onMonthChangeStart(e) { const t = this, { $months: a, currentYear: s, currentMonth: r } = t; t.updateCurrentMonthYear(e), a.removeClass("calendar-month-current calendar-month-prev calendar-month-next"); const i = e === "next" ? a.length - 1 : 0; a.eq(i).addClass("calendar-month-current"), a.eq(e === "next" ? i - 1 : i + 1).addClass(e === "next" ? "calendar-month-prev" : "calendar-month-next"), t.emit("local::monthYearChangeStart calendarMonthYearChangeStart", t, s, r) } onMonthChangeEnd(e, t) { const a = this, { currentYear: s, currentMonth: r, $wrapperEl: i, monthsTranslate: o } = a; a.animating = !1; let l, c, d; i.find(".calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)").remove(), typeof e > "u" && (e = "next", t = !0), t ? (i.find(".calendar-month-next, .calendar-month-prev").remove(), c = a.renderMonth(new Date(s, r), "prev"), l = a.renderMonth(new Date(s, r), "next")) : d = a.renderMonth(new Date(s, r), e), (e === "next" || t) && i.append(d || l), (e === "prev" || t) && i.prepend(d || c); const u = i.find(".calendar-month"); a.$months = u, a.setMonthsTranslate(o), a.emit("local::monthAdd calendarMonthAdd", a, e === "next" ? u.eq(u.length - 1)[0] : u.eq(0)[0]), a.emit("local::monthYearChangeEnd calendarMonthYearChangeEnd", a, s, r) } setMonthsTranslate(e) { const t = this, { $months: a, isHorizontal: s, inverter: r } = t; e = e || t.monthsTranslate || 0, typeof t.monthsTranslate > "u" && (t.monthsTranslate = e), a.removeClass("calendar-month-current calendar-month-prev calendar-month-next"); const i = -(e + 1) * 100 * r, o = -e * 100 * r, l = -(e - 1) * 100 * r; a.eq(0).transform(`translate3d(${s ? i : 0}%, ${s ? 0 : i}%, 0)`).addClass("calendar-month-prev"), a.eq(1).transform(`translate3d(${s ? o : 0}%, ${s ? 0 : o}%, 0)`).addClass("calendar-month-current"), a.eq(2).transform(`translate3d(${s ? l : 0}%, ${s ? 0 : l}%, 0)`).addClass("calendar-month-next") } nextMonth(e) { const t = this, { params: a, $wrapperEl: s, inverter: r, isHorizontal: i } = t; (typeof e > "u" || typeof e == "object") && (e = "", a.animate || (e = 0)); const o = parseInt(t.$months.eq(t.$months.length - 1).attr("data-month"), 10), l = parseInt(t.$months.eq(t.$months.length - 1).attr("data-year"), 10), d = new Date(l, o).getTime(), u = !t.animating; if (a.maxDate && d > new Date(a.maxDate).getTime()) { t.resetMonth(); return } if (t.monthsTranslate -= 1, o === t.currentMonth) { const m = -t.monthsTranslate * 100 * r, f = y(t.renderMonth(d, "next")).transform(`translate3d(${i ? m : 0}%, ${i ? 0 : m}%, 0)`).addClass("calendar-month-next"); s.append(f[0]), t.$months = s.find(".calendar-month"), t.emit("local::monthAdd calendarMonthAdd", t.$months.eq(t.$months.length - 1)[0]) } t.animating = !0, t.onMonthChangeStart("next"); const p = t.monthsTranslate * 100 * r; s.transition(e).transform(`translate3d(${i ? p : 0}%, ${i ? 0 : p}%, 0)`), u && s.transitionEnd(() => { t.onMonthChangeEnd("next") }), a.animate || t.onMonthChangeEnd("next") } prevMonth(e) { const t = this, { params: a, $wrapperEl: s, inverter: r, isHorizontal: i } = t; (typeof e > "u" || typeof e == "object") && (e = "", a.animate || (e = 0)); const o = parseInt(t.$months.eq(0).attr("data-month"), 10), l = parseInt(t.$months.eq(0).attr("data-year"), 10), d = new Date(l, o + 1, -1).getTime(), u = !t.animating; if (a.minDate) { let m = new Date(a.minDate); if (m = new Date(m.getFullYear(), m.getMonth(), 1), d < m.getTime()) { t.resetMonth(); return } } if (t.monthsTranslate += 1, o === t.currentMonth) { const m = -t.monthsTranslate * 100 * r, f = y(t.renderMonth(d, "prev")).transform(`translate3d(${i ? m : 0}%, ${i ? 0 : m}%, 0)`).addClass("calendar-month-prev"); s.prepend(f[0]), t.$months = s.find(".calendar-month"), t.emit("local::monthAdd calendarMonthAdd", t.$months.eq(0)[0]) } t.animating = !0, t.onMonthChangeStart("prev"); const p = t.monthsTranslate * 100 * r; s.transition(e).transform(`translate3d(${i ? p : 0}%, ${i ? 0 : p}%, 0)`), u && s.transitionEnd(() => { t.onMonthChangeEnd("prev") }), a.animate || t.onMonthChangeEnd("prev") } resetMonth(e) { e === void 0 && (e = ""); const t = this, { $wrapperEl: a, inverter: s, isHorizontal: r, monthsTranslate: i } = t, o = i * 100 * s; a.transition(e).transform(`translate3d(${r ? o : 0}%, ${r ? 0 : o}%, 0)`) } setYearMonth(e, t, a) { const s = this, { params: r, isHorizontal: i, $wrapperEl: o, inverter: l } = s; typeof e > "u" && (e = s.currentYear), typeof t > "u" && (t = s.currentMonth), (typeof a > "u" || typeof a == "object") && (a = "", r.animate || (a = 0)); let c; if (e < s.currentYear ? c = new Date(e, t + 1, -1).getTime() : c = new Date(e, t).getTime(), r.maxDate && c > new Date(r.maxDate).getTime()) return !1; if (r.minDate) { let g = new Date(r.minDate); if (g = new Date(g.getFullYear(), g.getMonth(), 1), c < g.getTime()) return !1 } const d = new Date(s.currentYear, s.currentMonth).getTime(), u = c > d ? "next" : "prev", p = s.renderMonth(new Date(e, t)); s.monthsTranslate = s.monthsTranslate || 0; const m = s.monthsTranslate; let f; const h = !s.animating && a !== 0; c > d ? (s.monthsTranslate -= 1, s.animating || s.$months.eq(s.$months.length - 1).remove(), o.append(p), s.$months = o.find(".calendar-month"), f = -(m - 1) * 100 * l, s.$months.eq(s.$months.length - 1).transform(`translate3d(${i ? f : 0}%, ${i ? 0 : f}%, 0)`).addClass("calendar-month-next")) : (s.monthsTranslate += 1, s.animating || s.$months.eq(0).remove(), o.prepend(p), s.$months = o.find(".calendar-month"), f = -(m + 1) * 100 * l, s.$months.eq(0).transform(`translate3d(${i ? f : 0}%, ${i ? 0 : f}%, 0)`).addClass("calendar-month-prev")), s.emit("local::monthAdd calendarMonthAdd", u === "next" ? s.$months.eq(s.$months.length - 1)[0] : s.$months.eq(0)[0]), s.animating = !0, s.onMonthChangeStart(u); const b = s.monthsTranslate * 100 * l; o.transition(a).transform(`translate3d(${i ? b : 0}%, ${i ? 0 : b}%, 0)`), h && o.transitionEnd(() => { s.onMonthChangeEnd(u, !0) }), (!r.animate || a === 0) && s.onMonthChangeEnd(u, !0) } nextYear() { const e = this; e.setYearMonth(e.currentYear + 1) } prevYear() { const e = this; e.setYearMonth(e.currentYear - 1) } dateInRange(e, t) { let a = !1, s; if (!t) return !1; if (Array.isArray(t)) for (s = 0; s < t.length; s += 1)t[s].from || t[s].to ? t[s].from && t[s].to ? e <= new Date(t[s].to).getTime() && e >= new Date(t[s].from).getTime() && (a = !0) : t[s].from ? e >= new Date(t[s].from).getTime() && (a = !0) : t[s].to && e <= new Date(t[s].to).getTime() && (a = !0) : t[s].date ? e === new Date(t[s].date).getTime() && (a = !0) : e === new Date(t[s]).getTime() && (a = !0); else t.from || t.to ? t.from && t.to ? e <= new Date(t.to).getTime() && e >= new Date(t.from).getTime() && (a = !0) : t.from ? e >= new Date(t.from).getTime() && (a = !0) : t.to && e <= new Date(t.to).getTime() && (a = !0) : t.date ? a = e === new Date(t.date).getTime() : typeof t == "function" && (a = t(new Date(e))); return a } daysInMonth(e) { const t = new Date(e); return new Date(t.getFullYear(), t.getMonth() + 1, 0).getDate() } renderMonths(e) { const t = this; return t.params.renderMonths ? t.params.renderMonths.call(t, e) : x("div", { class: "calendar-months-wrapper" }, t.renderMonth(e, "prev"), t.renderMonth(e), t.renderMonth(e, "next")) } renderMonth(e, t) {
    const a = this, { params: s, value: r } = a; if (s.renderMonth) return s.renderMonth.call(a, e, t); let i = new Date(e), o = i.getFullYear(), l = i.getMonth(), c = a.monthNames.indexOf(a.monthFormatter(i)); c < 0 && (c = l); let d = a.yearFormatter(i); t === "next" && (l === 11 ? i = new Date(o + 1, 0) : i = new Date(o, l + 1, 1)), t === "prev" && (l === 0 ? i = new Date(o - 1, 11) : i = new Date(o, l - 1, 1)), (t === "next" || t === "prev") && (l = i.getMonth(), o = i.getFullYear(), c = a.monthNames.indexOf(a.monthFormatter(i)), c < 0 && (c = l), d = a.yearFormatter(i)); const u = [], p = new Date().setHours(0, 0, 0, 0), m = s.minDate ? new Date(s.minDate).getTime() : null, f = s.maxDate ? new Date(s.maxDate).getTime() : null, h = 6, b = 7, g = a.daysInMonth(new Date(i.getFullYear(), i.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1e3), v = a.daysInMonth(i), E = s.firstDay === 6 ? 0 : 1; let $ = "", w = 0 + (s.firstDay - 1), C, k, M = new Date(i.getFullYear(), i.getMonth()).getDay(); if (M === 0 && (M = 7), r && r.length) for (let A = 0; A < r.length; A += 1)u.push(new Date(r[A]).setHours(0, 0, 0, 0)); for (let A = 1; A <= h; A += 1) {
      let O = ""; for (let S = 1; S <= b; S += 1) {
        w += 1; let P, T = w - M, I = ""; A === 1 && S === 1 && T > E && s.firstDay !== 1 && (w -= 7, T = w - M); const H = S - 1 + s.firstDay > 6 ? S - 1 - 7 + s.firstDay : S - 1 + s.firstDay; T < 0 ? (T = g + T + 1, I += " calendar-day-prev", P = new Date(l - 1 < 0 ? o - 1 : o, l - 1 < 0 ? 11 : l - 1, T).getTime()) : (T += 1, T > v ? (T -= v, I += " calendar-day-next", P = new Date(l + 1 > 11 ? o + 1 : o, l + 1 > 11 ? 0 : l + 1, T).getTime()) : P = new Date(o, l, T).getTime()), P === p && (I += " calendar-day-today"), s.rangePicker && u.length === 2 ? (P >= u[0] && P <= u[1] && (I += " calendar-day-selected"), u[0] !== u[1] && (P > u[0] && P < u[1] && (I += " calendar-day-selected-range"), P === u[0] && (I += " calendar-day-selected-left"), P === u[1] && (I += " calendar-day-selected-right"))) : u.indexOf(P) >= 0 && (I += " calendar-day-selected"), s.weekendDays.indexOf(H) >= 0 && (I += " calendar-day-weekend"); let D = ""; if (k = !1, s.events && a.dateInRange(P, s.events) && (k = !0), k && (I += " calendar-day-has-events", D = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `, Array.isArray(s.events))) {
          const N = []; s.events.forEach(F => { const V = F.color || ""; N.indexOf(V) < 0 && a.dateInRange(P, F) && N.push(V) }), D = `
              <span class="calendar-day-events">
                ${N.map(F => `
                  <span class="calendar-day-event" style="${F ? `background-color: ${F}` : ""}"></span>
                `.trim()).join("")}
              </span>
            `} if (s.rangesClasses) for (let N = 0; N < s.rangesClasses.length; N += 1)a.dateInRange(P, s.rangesClasses[N].range) && (I += ` ${s.rangesClasses[N].cssClass}`); C = !1, (m && P < m || f && P > f) && (C = !0), s.disabled && a.dateInRange(P, s.disabled) && (C = !0), C && (I += " calendar-day-disabled"), P = new Date(P); const z = P.getFullYear(), B = P.getMonth(), L = a.dayFormatter(P); O += `
          <div data-year="${z}" data-month="${B}" data-day="${T}" class="calendar-day${I}" data-date="${z}-${B}-${T}">
            <span class="calendar-day-number">${L}${D}</span>
          </div>`.trim()
      } $ += `<div class="calendar-row">${O}</div>`
    } return $ = `<div class="calendar-month" data-year="${o}" data-month="${l}" data-locale-year="${d}" data-locale-month="${c}">${$}</div>`, $
  } renderWeekHeader() { const e = this; if (e.params.renderWeekHeader) return e.params.renderWeekHeader.call(e); const { params: t } = e; let a = ""; for (let s = 0; s < 7; s += 1) { const r = s + t.firstDay > 6 ? s - 7 + t.firstDay : s + t.firstDay, i = e.dayNamesShort[r]; a += `<div class="calendar-week-day">${i}</div>` } return x("div", { class: "calendar-week-header" }, a) } renderMonthSelector() { const e = this; return e.params.renderMonthSelector ? e.params.renderMonthSelector.call(e) : x("div", { class: "calendar-month-selector" }, x("a", { class: "link icon-only calendar-prev-month-button" }, x("i", { class: "icon icon-prev" })), e.params.monthPicker ? x("a", { class: "current-month-value link" }) : x("span", { class: "current-month-value" }), x("a", { class: "link icon-only calendar-next-month-button" }, x("i", { class: "icon icon-next" }))) } renderYearSelector() { const e = this; return e.params.renderYearSelector ? e.params.renderYearSelector.call(e) : x("div", { class: "calendar-year-selector" }, x("a", { class: "link icon-only calendar-prev-year-button" }, x("i", { class: "icon icon-prev" })), e.params.yearPicker ? x("a", { class: "current-year-value link" }) : x("span", { class: "current-year-value" }), x("a", { class: "link icon-only calendar-next-year-button" }, x("i", { class: "icon icon-next" }))) } renderTimeSelector() { const e = this, t = e.value && e.value[0]; let a; return t && (a = e.timeSelectorFormatter(t)), x("div", { class: "calendar-time-selector" }, x("span", null, e.params.timePickerLabel), x("a", { class: "link" }, a || e.params.timePickerPlaceholder)) } renderHeader() { const e = this; return e.params.renderHeader ? e.params.renderHeader.call(e) : x("div", { class: "calendar-header" }, x("div", { class: "calendar-selected-date" }, e.params.headerPlaceholder)) } renderFooter() { const e = this, t = e.app; return e.params.renderFooter ? e.params.renderFooter.call(e) : x("div", { class: "calendar-footer" }, x("a", { class: `${t.theme === "md" ? "button button-round" : "link"} calendar-close sheet-close popover-close` }, e.params.toolbarCloseText)) } renderToolbar() { const e = this; return e.params.renderToolbar ? e.params.renderToolbar.call(e, e) : x("div", { class: "toolbar toolbar-top" }, x("div", { class: "toolbar-inner" }, e.params.monthSelector ? e.renderMonthSelector() : "", e.params.yearSelector ? e.renderYearSelector() : "")) } renderInline() { const e = this, { cssClass: t, toolbar: a, header: s, footer: r, rangePicker: i, weekHeader: o } = e.params, { value: l, hasTimePicker: c } = e, d = l && l.length ? l[0] : new Date().setHours(0, 0, 0); return x("div", { class: `calendar calendar-inline ${i ? "calendar-range" : ""} ${t || ""}` }, s && e.renderHeader(), a && e.renderToolbar(), o && e.renderWeekHeader(), x("div", { class: "calendar-months" }, e.renderMonths(d)), c && e.renderTimeSelector(), r && e.renderFooter()) } renderCustomModal() { const e = this, { cssClass: t, toolbar: a, header: s, footer: r, rangePicker: i, weekHeader: o } = e.params, { value: l, hasTimePicker: c } = e, d = l && l.length ? l[0] : new Date().setHours(0, 0, 0); return x("div", { class: `calendar calendar-modal ${i ? "calendar-range" : ""} ${t || ""}` }, s && e.renderHeader(), a && e.renderToolbar(), o && e.renderWeekHeader(), x("div", { class: "calendar-months" }, e.renderMonths(d)), c && e.renderTimeSelector(), r && e.renderFooter()) } renderSheet() { const e = this, { cssClass: t, toolbar: a, header: s, footer: r, rangePicker: i, weekHeader: o } = e.params, { value: l, hasTimePicker: c } = e, d = l && l.length ? l[0] : new Date().setHours(0, 0, 0); return x("div", { class: `sheet-modal calendar calendar-sheet ${i ? "calendar-range" : ""} ${t || ""}` }, s && e.renderHeader(), a && e.renderToolbar(), o && e.renderWeekHeader(), x("div", { class: "sheet-modal-inner calendar-months" }, e.renderMonths(d)), c && e.renderTimeSelector(), r && e.renderFooter()) } renderPopover() { const e = this, { cssClass: t, toolbar: a, header: s, footer: r, rangePicker: i, weekHeader: o } = e.params, { value: l, hasTimePicker: c } = e, d = l && l.length ? l[0] : new Date().setHours(0, 0, 0); return x("div", { class: "popover calendar-popover" }, x("div", { class: "popover-inner" }, x("div", { class: `calendar ${i ? "calendar-range" : ""} ${t || ""}` }, s && e.renderHeader(), a && e.renderToolbar(), o && e.renderWeekHeader(), x("div", { class: "calendar-months" }, e.renderMonths(d)), c && e.renderTimeSelector(), r && e.renderFooter()))) } render() { const e = this, { params: t } = e; if (t.render) return t.render.call(e); if (!e.inline) { let a = t.openIn; return a === "auto" && (a = e.isPopover() ? "popover" : "sheet"), a === "popover" ? e.renderPopover() : a === "sheet" ? e.renderSheet() : e.renderCustomModal() } return e.renderInline() } openMonthPicker() { const e = this, { $el: t, app: a } = e; if (!t || !t.length) return; t.append('<div class="popover calendar-popover calendar-month-picker-popover"><div class="popover-inner"><div class="calendar-month-picker"></div></div></div>'), e.monthPickerPopover = a.popover.create({ el: t.find(".calendar-month-picker-popover"), targetEl: t.find(".calendar-month-selector"), backdrop: !0, backdropUnique: !0, on: { close() { e.closeMonthPicker() }, closed() { e.monthPickerPopover.$el && e.monthPickerPopover.$el.remove(), e.monthPickerPopover.destroy(), e.monthPickerInstance && (e.monthPickerInstance.close(), e.monthPickerInstance.destroy()), delete e.monthPickerInstance, delete e.monthPickerPopover } } }), e.monthPickerPopover.open(); const s = parseInt(e.$el.find(".calendar-month-current").attr("data-locale-month"), 10), r = [], i = []; e.monthNames.forEach((o, l) => { r.push(l), i.push(o) }), e.monthPickerInstance = a.picker.create({ containerEl: e.monthPickerPopover.$el.find(".calendar-month-picker"), value: [s], toolbar: e.params.monthPickerToolbar, rotateEffect: !1, toolbarCloseText: e.params.monthPickerCloseText, cols: [{ values: r, displayValues: i }] }) } closeMonthPicker() { const e = this; e.monthPickerPopover && e.monthPickerPopover.opened && e.monthPickerPopover.close(); const t = e.monthPickerInstance.value[0], a = parseInt(e.$el.find(".calendar-month-current").attr("data-locale-month"), 10), s = e.currentMonth, r = a - s, i = t - r; e.setYearMonth(e.currentYear, i, 0) } openYearPicker() { const e = this, { $el: t, app: a } = e; if (!t || !t.length) return; t.append('<div class="popover calendar-popover calendar-year-picker-popover"><div class="popover-inner"><div class="calendar-year-picker"></div></div></div>'), e.yearPickerPopover = a.popover.create({ el: t.find(".calendar-year-picker-popover"), targetEl: t.find(".calendar-year-selector"), backdrop: !0, backdropUnique: !0, on: { close() { e.closeYearPicker() }, closed() { e.yearPickerPopover.$el && e.yearPickerPopover.$el.remove(), e.yearPickerPopover.destroy(), e.yearPickerInstance && (e.yearPickerInstance.close(), e.yearPickerInstance.destroy()), delete e.yearPickerInstance, delete e.yearPickerPopover } } }), e.yearPickerPopover.open(); const s = e.currentYear; let r = e.params.yearPickerMin || new Date().getFullYear() - 100; e.params.minDate && (r = Math.max(r, new Date(e.params.minDate).getFullYear())); let i = e.params.yearPickerMax || new Date().getFullYear() + 100; e.params.maxDate && (i = Math.min(i, new Date(e.params.maxDate).getFullYear())); const o = []; for (let l = r; l <= i; l += 1)o.push(l); e.yearPickerInstance = a.picker.create({ containerEl: e.yearPickerPopover.$el.find(".calendar-year-picker"), value: [s], toolbar: e.params.yearPickerToolbar, rotateEffect: !1, toolbarCloseText: e.params.yearPickerCloseText, cols: [{ values: o }] }) } closeYearPicker() { const e = this; e.yearPickerPopover && e.yearPickerPopover.opened && e.yearPickerPopover.close(), e.setYearMonth(e.yearPickerInstance.value[0], void 0, 0) } openTimePicker() { const e = this, { $el: t, app: a, is12HoursFormat: s } = e; if (!t || !t.length) return; t.append('<div class="popover calendar-popover calendar-time-picker-popover"><div class="popover-inner"><div class="calendar-time-picker"></div></div></div>'); const r = [], i = [], o = s ? 1 : 0, l = s ? 12 : 23; for (let d = o; d <= l; d += 1)r.push(d); for (let d = 0; d <= 59; d += 1)i.push(d); let c; e.value && e.value.length ? c = [e.value[0].getHours(), e.value[0].getMinutes()] : c = [new Date().getHours(), new Date().getMinutes()], s && (c.push(c[0] < 12 ? "AM" : "PM"), c[0] > 12 && (c[0] -= 12), c[0] === 0 && (c[0] = 12)), e.timePickerPopover = a.popover.create({ el: t.find(".calendar-time-picker-popover"), targetEl: t.find(".calendar-time-selector .link"), backdrop: !0, backdropUnique: !0, on: { close() { e.closeTimePicker() }, closed() { e.timePickerPopover.$el && e.timePickerPopover.$el.remove(), e.timePickerPopover.destroy(), e.timePickerInstance && (e.timePickerInstance.close(), e.timePickerInstance.destroy()), delete e.timePickerInstance, delete e.timePickerPopover } } }), e.timePickerPopover.open(), e.timePickerInstance = a.picker.create({ containerEl: e.timePickerPopover.$el.find(".calendar-time-picker"), value: c, toolbar: e.params.timePickerToolbar, rotateEffect: !1, toolbarCloseText: e.params.timePickerCloseText, cols: [{ values: r }, { divider: !0, content: ":" }, { values: i, displayValues: i.map(d => d < 10 ? `0${d}` : d) }, ...s ? [{ values: ["AM", "PM"] }] : []] }) } closeTimePicker() { const e = this, { is12HoursFormat: t } = e; if (e.timePickerInstance) { const a = e.timePickerInstance.value; let s = parseInt(a[0], 10); const r = parseInt(a[1], 10), i = e.timePickerInstance.value[2]; t && (i === "AM" && s === 12 ? s = 0 : i === "PM" && s !== 12 && (s += 12)); let o = e.value && e.value.length && e.value[0]; o ? (o = new Date(o), o.setHours(s, r)) : (o = new Date, o.setHours(s, r, 0, 0)), e.setValue([o]), e.timePickerPopover && e.timePickerPopover.opened && e.timePickerPopover.close() } } onOpen() { const e = this, { initialized: t, $el: a, app: s, $inputEl: r, inline: i, value: o, params: l } = e; e.closing = !1, e.opened = !0, e.opening = !0, e.attachCalendarEvents(); const c = !o && l.value; t ? o && e.setValue(o, 0) : o ? e.setValue(o, 0) : l.value && e.setValue(e.normalizeValues(l.value), 0), e.updateCurrentMonthYear(), e.monthsTranslate = 0, e.setMonthsTranslate(), c ? e.updateValue() : l.header && o && e.updateValue(!0), !i && r && r.length && s.theme === "md" && r.trigger("focus"), e.initialized = !0, e.$months.each(d => { e.emit("local::monthAdd calendarMonthAdd", d) }), a && a.trigger("calendar:open"), r && r.trigger("calendar:open"), e.emit("local::open calendarOpen", e) } onOpened() { const e = this; e.opening = !1, e.$el && e.$el.trigger("calendar:opened"), e.$inputEl && e.$inputEl.trigger("calendar:opened"), e.emit("local::opened calendarOpened", e) } onClose() { const e = this, t = e.app; if (e.opening = !1, e.closing = !0, e.$inputEl) if (t.theme === "md") e.$inputEl.trigger("blur"); else { const a = e.$inputEl.attr("validate"), s = e.$inputEl.attr("required"); a && s && t.input.validate(e.$inputEl) } e.detachCalendarEvents && e.detachCalendarEvents(), e.$el && e.$el.trigger("calendar:close"), e.$inputEl && e.$inputEl.trigger("calendar:close"), e.emit("local::close calendarClose", e) } onClosed() { const e = this; e.opened = !1, e.closing = !1, e.inline || $e(() => { e.modal && e.modal.el && e.modal.destroy && (e.params.routableModals || e.modal.destroy()), delete e.modal }), e.timePickerInstance && (e.timePickerInstance.destroy && e.timePickerInstance.destroy(), delete e.timePickerInstance), e.$el && e.$el.trigger("calendar:closed"), e.$inputEl && e.$inputEl.trigger("calendar:closed"), e.emit("local::closed calendarClosed", e) } open() { const e = this, { app: t, opened: a, inline: s, $inputEl: r, params: i } = e; if (a) return; if (s) { e.$el = y(e.render()), e.$el[0].f7Calendar = e, e.$wrapperEl = e.$el.find(".calendar-months-wrapper"), e.$months = e.$wrapperEl.find(".calendar-month"), e.$containerEl.append(e.$el), e.onOpen(), e.onOpened(); return } let o = i.openIn; o === "auto" && (o = e.isPopover() ? "popover" : "sheet"); const l = e.render(), c = { targetEl: r, scrollToEl: i.scrollToInput ? r : void 0, content: l, backdrop: i.backdrop === !0 || (o === "popover" || o === "customModal") && t.params.popover.backdrop !== !1 && i.backdrop !== !1, closeByBackdropClick: i.closeByBackdropClick, on: { open() { const d = this; e.modal = d, e.$el = o === "popover" ? d.$el.find(".calendar") : d.$el, e.$wrapperEl = e.$el.find(".calendar-months-wrapper"), e.$months = e.$wrapperEl.find(".calendar-month"), e.$el[0].f7Calendar = e, o === "customModal" && y(e.$el).find(".calendar-close").once("click", () => { e.close() }), e.onOpen() }, opened() { e.onOpened() }, close() { e.onClose() }, closed() { e.onClosed() } } }; o === "sheet" && (c.push = i.sheetPush, c.swipeToClose = i.sheetSwipeToClose), i.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, [o]: c } }) : (e.modal = t[o].create(c), e.modal.open()) } close() { const e = this, { opened: t, inline: a } = e; if (t) { if (a) { e.onClose(), e.onClosed(); return } e.params.routableModals && e.view ? e.view.router.back() : e.modal.close() } } init() { const e = this; if (e.initInput(), e.inline) { e.open(), e.emit("local::init calendarInit", e); return } !e.initialized && e.params.value && e.setValue(e.normalizeValues(e.params.value)), e.$inputEl && e.attachInputEvents(), e.params.closeByOutsideClick && e.attachHtmlEvents(), e.emit("local::init calendarInit", e) } destroy() { const e = this; if (e.destroyed) return; const { $el: t } = e; e.emit("local::beforeDestroy calendarBeforeDestroy", e), t && t.trigger("calendar:beforedestroy"), e.close(), e.$inputEl && e.detachInputEvents(), e.params.closeByOutsideClick && e.detachHtmlEvents(), e.timePickerInstance && (e.timePickerInstance.destroy && e.timePickerInstance.destroy(), delete e.timePickerInstance), t && t.length && delete e.$el[0].f7Calendar, ve(e), e.destroyed = !0 }
}; const nc = { name: "calendar", static: { Calendar: Bn }, create() { const n = this; n.calendar = we({ defaultSelector: ".calendar", constructor: Bn, app: n, domProp: "f7Calendar" }), n.calendar.close = function (t) { t === void 0 && (t = ".calendar"); const a = y(t); if (a.length === 0) return; const s = a[0].f7Calendar; !s || s && !s.opened || s.close() } }, params: { calendar: { dateFormat: void 0, monthNames: "auto", monthNamesShort: "auto", dayNames: "auto", dayNamesShort: "auto", locale: void 0, firstDay: 1, weekendDays: [0, 6], multiple: !1, rangePicker: !1, rangePickerMinDays: 1, rangePickerMaxDays: 0, direction: "horizontal", minDate: null, maxDate: null, disabled: null, events: null, rangesClasses: null, touchMove: !0, animate: !0, closeOnSelect: !1, monthSelector: !0, monthPicker: !0, monthPickerToolbar: !0, monthPickerCloseText: "Done", yearSelector: !0, yearPicker: !0, yearPickerToolbar: !0, yearPickerMin: void 0, yearPickerMax: void 0, yearPickerCloseText: "Done", timePicker: !1, timePickerToolbar: !0, timePickerLabel: "Time", timePickerFormat: { hour: "numeric", minute: "numeric" }, timePickerPlaceholder: "Select time", timePickerCloseText: "Done", weekHeader: !0, value: null, containerEl: null, openIn: "auto", sheetPush: !1, sheetSwipeToClose: void 0, formatValue: null, inputEl: null, inputReadOnly: !0, closeByOutsideClick: !0, scrollToInput: !0, header: !1, headerPlaceholder: "Select date", toolbar: !0, toolbarCloseText: "Done", footer: !1, cssClass: null, routableModals: !1, view: null, url: "date/", backdrop: null, closeByBackdropClick: !0, renderWeekHeader: null, renderMonths: null, renderMonth: null, renderMonthSelector: null, renderYearSelector: null, renderHeader: null, renderFooter: null, renderToolbar: null, renderInline: null, renderPopover: null, renderSheet: null, render: null } } }; function sc(n, e) { const t = this, a = y(n), s = a.index(), r = t.cols[s]; if (r.divider) return; r.$el = a, r.el = a[0], r.$itemsEl = r.$el.find(".picker-items"), r.items = r.$itemsEl.find(".picker-item"); let i, o; r.replaceValues = function (u, p) { r.detachEvents(), r.values = u, r.displayValues = p, r.$itemsEl.html(t.renderColumn(r, !0)), r.items = r.$itemsEl.find(".picker-item"), r.calcSize(), r.setValue(r.values[0], !0), r.attachEvents() }, r.calcSize = function () { o = r.$el[0].offsetHeight, i = r.items[0].offsetHeight; const u = r.el.style.getPropertyValue("--f7-picker-scroll-padding"); r.el.style.setProperty("--f7-picker-scroll-padding", `${(o - i) / 2}px`), u || (r.$itemsEl[0].scrollTop = 0) }, r.setValue = function (u, p) { const m = r.$itemsEl.find(`.picker-item[data-picker-value="${u}"]`).index(); if (typeof m > "u" || m === -1) return; const f = m * i; r.$itemsEl[0].scrollTop = f, r.updateItems(m, f, p) }, r.updateItems = function (u, p, m) { typeof p > "u" && (p = r.$itemsEl[0].scrollTop), typeof u > "u" && (u = Math.round(p / i)), u < 0 && (u = 0), u >= r.items.length && (u = r.items.length - 1); const f = r.activeIndex; r.activeIndex = u, r.$itemsEl.find(".picker-item-selected").removeClass("picker-item-selected"); const h = r.items.eq(u); h.addClass("picker-item-selected").children().transform(""), t.params.rotateEffect && r.items.each(b => { const g = y(b), E = (b.offsetTop - (o - i) / 2 - p) / i, $ = Math.ceil(r.height / i / 2) + 1; let w = -24 * E; w > 180 && (w = 180), w < -180 && (w = -180), Math.abs(E) > $ ? g.addClass("picker-item-far") : g.removeClass("picker-item-far"), g.children("span").transform(`translate3d(0, ${-E * i}px, -100px) rotateX(${w}deg)`) }), (m || typeof m > "u") && (r.value = h.attr("data-picker-value"), r.displayValue = r.displayValues ? r.displayValues[u] : r.value, f !== u && (r.onChange && r.onChange(t, r.value, r.displayValue), t.updateValue())) }; function l() { r.updateItems() } function c() { const d = y(this).attr("data-picker-value"); r.setValue(d) } r.attachEvents = function () { r.$itemsEl.on("scroll", l), r.items.on("click", c) }, r.detachEvents = function () { r.items.off("click", c) }, r.init = function () { r.calcSize(), s === 0 && r.$el.addClass("picker-column-first"), s === t.cols.length - 1 && r.$el.addClass("picker-column-last"), t.params.freeMode && r.$el.addClass("picker-column-free-mode"), e && r.updateItems(0), r.attachEvents() }, r.destroy = function () { r.detachEvents() }, r.init() } let Dn = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = ue(), r = U(); a.params = R({}, e.params.picker, t); let i; if (a.params.containerEl && (i = y(a.params.containerEl), i.length === 0)) return a; let o; a.params.inputEl && (o = y(a.params.inputEl)); let l = a.params.scrollToInput ? o : void 0; if (a.params.scrollToEl) { const h = y(a.params.scrollToEl); h.length > 0 && (l = h) } R(a, { app: e, $containerEl: i, containerEl: i && i[0], inline: i && i.length > 0, needsOriginFix: s.ios || r.navigator.userAgent.toLowerCase().indexOf("safari") >= 0 && r.navigator.userAgent.toLowerCase().indexOf("chrome") < 0 && !s.android, cols: [], $inputEl: o, inputEl: o && o[0], $scrollToEl: l, initialized: !1, opened: !1, url: a.params.url }); function c() { a.resizeCols() } function d() { a.open() } function u(h) { h.preventDefault() } let p = null; function m(h) { p = h.target } function f(h) { if (a.destroyed || !a.params) return; const b = y(h.target); a.isPopover() || !a.opened || a.closing || b.closest('[class*="backdrop"]').length || (o && o.length > 0 ? p === h.target && b[0] !== o[0] && b.closest(".sheet-modal").length === 0 && a.close() : y(h.target).closest(".sheet-modal").length === 0 && a.close()) } return R(a, { attachResizeEvent() { e.on("resize", c) }, detachResizeEvent() { e.off("resize", c) }, attachInputEvents() { a.$inputEl.on("click", d), a.params.inputReadOnly && (a.$inputEl.on("focus mousedown", u), a.$inputEl[0] && (a.$inputEl[0].f7ValidateReadonly = !0)) }, detachInputEvents() { a.$inputEl.off("click", d), a.params.inputReadOnly && (a.$inputEl.off("focus mousedown", u), a.$inputEl[0] && delete a.$inputEl[0].f7ValidateReadonly) }, attachHtmlEvents() { e.on("click", f), e.on("touchstart", m) }, detachHtmlEvents() { e.off("click", f), e.off("touchstart", m) } }), a.init(), a } get view() { const { app: e, params: t, $inputEl: a } = this; let s; return t.view ? s = t.view : a && (s = a.parents(".view").length && a.parents(".view")[0].f7View), s || (s = e.views.main), s } initInput() { const e = this; e.$inputEl && e.params.inputReadOnly && e.$inputEl.prop("readOnly", !0) } resizeCols() { const e = this; if (e.opened) for (let t = 0; t < e.cols.length; t += 1)e.cols[t].divider || (e.cols[t].calcSize(), e.cols[t].setValue(e.cols[t].value, !1)) } isPopover() { const e = this, { app: t, modal: a, params: s } = e, r = ue(); if (s.openIn === "sheet" || a && a.type !== "popover") return !1; if (!e.inline && e.inputEl) { if (s.openIn === "popover") return !0; if (r.ios) return !!r.ipad; if (t.width >= 768) return !0 } return !1 } formatValue() { const e = this, { value: t, displayValue: a } = e; return e.params.formatValue ? e.params.formatValue.call(e, t, a) : t.join(" ") } setValue(e) { const t = this; let a = 0; if (t.cols.length === 0) { t.value = e, t.updateValue(e); return } for (let s = 0; s < t.cols.length; s += 1)t.cols[s] && !t.cols[s].divider && (t.cols[s].setValue(e[a]), a += 1) } getValue() { return this.value } updateValue(e) { const t = this, a = e || [], s = []; let r; if (t.cols.length === 0) { const i = t.params.cols.filter(o => !o.divider); for (let o = 0; o < i.length; o += 1)r = i[o], r.displayValues !== void 0 && r.values !== void 0 && r.values.indexOf(a[o]) !== -1 ? s.push(r.displayValues[r.values.indexOf(a[o])]) : s.push(a[o]) } else for (let i = 0; i < t.cols.length; i += 1)t.cols[i].divider || (a.push(t.cols[i].value), s.push(t.cols[i].displayValue)); a.indexOf(void 0) >= 0 || (t.value = a, t.displayValue = s, t.emit("local::change pickerChange", t, t.value, t.displayValue), t.inputEl && (t.$inputEl.val(t.formatValue()), t.$inputEl.trigger("change"))) } initColumn(e, t) { const a = this; sc.call(a, e, t) } destroyColumn(e) { const t = this, s = y(e).index(); t.cols[s] && t.cols[s].destroy && t.cols[s].destroy() } renderToolbar() { const e = this; return e.params.renderToolbar ? e.params.renderToolbar.call(e, e) : x("div", { class: "toolbar toolbar-top" }, x("div", { class: "toolbar-inner" }, x("div", { class: "left" }), x("div", { class: "right" }, x("a", { class: "link sheet-close popover-close" }, e.params.toolbarCloseText)))) } renderColumn(e, t) {
    const a = `picker-column ${e.textAlign ? `picker-column-${e.textAlign}` : ""} ${e.cssClass || ""}`; let s, r; return e.divider ? s = `
        <div class="${a} picker-column-divider">${e.content}</div>
      `: (r = e.values.map((i, o) => `
        <div class="picker-item" data-picker-value="${i}">
          <span>${e.displayValues ? e.displayValues[o] : i}</span>
        </div>
      `).join(""), s = `
        <div class="${a}">
          <div class="picker-items">${r}</div>
        </div>
      `), t ? r.trim() : s.trim()
  } renderInline() { const e = this, { rotateEffect: t, cssClass: a, toolbar: s } = e.params; return x("div", { class: `picker picker-inline ${t ? "picker-3d" : ""} ${a || ""}` }, s && e.renderToolbar(), x("div", { class: "picker-columns" }, e.cols.map(i => e.renderColumn(i)), x("div", { class: "picker-center-highlight" }))) } renderSheet() { const e = this, { rotateEffect: t, cssClass: a, toolbar: s } = e.params; return x("div", { class: `sheet-modal picker picker-sheet ${t ? "picker-3d" : ""} ${a || ""}` }, s && e.renderToolbar(), x("div", { class: "sheet-modal-inner picker-columns" }, e.cols.map(i => e.renderColumn(i)), x("div", { class: "picker-center-highlight" }))) } renderPopover() { const e = this, { rotateEffect: t, cssClass: a, toolbar: s } = e.params; return x("div", { class: "popover picker-popover" }, x("div", { class: "popover-inner" }, x("div", { class: `picker ${t ? "picker-3d" : ""} ${a || ""}` }, s && e.renderToolbar(), x("div", { class: "picker-columns" }, e.cols.map(i => e.renderColumn(i)), x("div", { class: "picker-center-highlight" }))))) } render() { const e = this; return e.params.render ? e.params.render.call(e) : e.inline ? e.renderInline() : e.isPopover() ? e.renderPopover() : e.renderSheet() } onOpen() { const e = this, { initialized: t, $el: a, app: s, $inputEl: r, inline: i, value: o, params: l } = e; e.opened = !0, e.closing = !1, e.opening = !0, e.attachResizeEvent(), a.find(".picker-column").each(c => { let d = !0; (!t && l.value || t && o) && (d = !1), e.initColumn(c, d) }), t ? o && e.setValue(o) : o ? e.setValue(o) : l.value && e.setValue(l.value), !i && r && r.length && s.theme === "md" && r.trigger("focus"), e.initialized = !0, a && a.trigger("picker:open"), r && r.trigger("picker:open"), e.emit("local::open pickerOpen", e) } onOpened() { const e = this; e.opening = !1, e.$el && e.$el.trigger("picker:opened"), e.$inputEl && e.$inputEl.trigger("picker:opened"), e.emit("local::opened pickerOpened", e) } onClose() { const e = this, t = e.app; if (e.opening = !1, e.closing = !0, e.detachResizeEvent(), e.cols.forEach(a => { a.destroy && a.destroy() }), e.$inputEl) if (t.theme === "md") e.$inputEl.trigger("blur"); else { const a = e.$inputEl.attr("validate"), s = e.$inputEl.attr("required"); a && s && t.input.validate(e.$inputEl) } e.$el && e.$el.trigger("picker:close"), e.$inputEl && e.$inputEl.trigger("picker:close"), e.emit("local::close pickerClose", e) } onClosed() { const e = this; e.opened = !1, e.closing = !1, e.inline || $e(() => { e.modal && e.modal.el && e.modal.destroy && (e.params.routableModals || e.modal.destroy()), delete e.modal }), e.$el && e.$el.trigger("picker:closed"), e.$inputEl && e.$inputEl.trigger("picker:closed"), e.emit("local::closed pickerClosed", e) } open() { const e = this, { app: t, opened: a, inline: s, $inputEl: r, $scrollToEl: i, params: o } = e; if (a) return; if (e.cols.length === 0 && o.cols.length && o.cols.forEach(u => { e.cols.push(u) }), s) { e.$el = y(e.render()), e.$el[0].f7Picker = e, e.$containerEl.append(e.$el), e.onOpen(), e.onOpened(); return } const l = e.isPopover(), c = l ? "popover" : "sheet", d = { targetEl: r, scrollToEl: i, content: e.render(), backdrop: typeof o.backdrop < "u" ? o.backdrop : l, on: { open() { const u = this; e.modal = u, e.$el = l ? u.$el.find(".picker") : u.$el, e.$el[0].f7Picker = e, e.onOpen() }, opened() { e.onOpened() }, close() { e.onClose() }, closed() { e.onClosed() } } }; c === "sheet" && (d.push = o.sheetPush, d.swipeToClose = o.sheetSwipeToClose), o.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, [c]: d } }) : (e.modal = t[c].create(d), e.modal.open()) } close() { const e = this, { opened: t, inline: a } = e; if (t) { if (a) { e.onClose(), e.onClosed(); return } e.params.routableModals && e.view ? e.view.router.back() : e.modal.close() } } init() { const e = this; if (e.initInput(), e.inline) { e.open(), e.emit("local::init pickerInit", e); return } !e.initialized && e.params.value && e.setValue(e.params.value), e.$inputEl && e.attachInputEvents(), e.params.closeByOutsideClick && e.attachHtmlEvents(), e.emit("local::init pickerInit", e) } destroy() { const e = this; if (e.destroyed) return; const { $el: t } = e; e.emit("local::beforeDestroy pickerBeforeDestroy", e), t && t.trigger("picker:beforedestroy"), e.close(), e.$inputEl && e.detachInputEvents(), e.params.closeByOutsideClick && e.detachHtmlEvents(), t && t.length && delete e.$el[0].f7Picker, ve(e), e.destroyed = !0 }
}; const rc = { name: "picker", static: { Picker: Dn }, create() { const n = this; n.picker = we({ defaultSelector: ".picker", constructor: Dn, app: n, domProp: "f7Picker" }), n.picker.close = function (t) { t === void 0 && (t = ".picker"); const a = y(t); if (a.length === 0) return; const s = a[0].f7Picker; !s || s && !s.opened || s.close() } }, params: { picker: { rotateEffect: !1, freeMode: !1, cols: [], containerEl: null, openIn: "auto", sheetPush: !1, sheetSwipeToClose: void 0, backdrop: void 0, formatValue: null, inputEl: null, inputReadOnly: !0, closeByOutsideClick: !0, scrollToInput: !0, scrollToEl: void 0, toolbar: !0, toolbarCloseText: "Done", cssClass: null, routableModals: !1, view: null, url: "select/", renderToolbar: null, render: null } } }, ic = { handle(n, e) { const t = this, a = y(n), s = a[0].scrollTop, r = a[0].scrollHeight, i = a[0].offsetHeight; let o = a[0].getAttribute("data-infinite-distance"); const l = a.find(".virtual-list"); let c; const d = a.hasClass("infinite-scroll-top"); if (o || (o = 50), typeof o == "string" && o.indexOf("%") >= 0 && (o = parseInt(o, 10) / 100 * i), o > i && (o = i), d) s < o && (a.trigger("infinite", e), t.emit("infinite", a[0], e)); else if (s + i >= r - o) { if (l.length > 0 && (c = l.eq(-1)[0].f7VirtualList, c && !c.reachEnd && !c.params.updatableScroll)) return; a.trigger("infinite", e), t.emit("infinite", a[0], e) } }, create(n) { const e = y(n), t = this; function a(s) { t.infiniteScroll.handle(this, s) } e.each(s => { s.f7InfiniteScrollHandler = a, s.addEventListener("scroll", s.f7InfiniteScrollHandler) }) }, destroy(n) { y(n).each(t => { t.removeEventListener("scroll", t.f7InfiniteScrollHandler), delete t.f7InfiniteScrollHandler }) } }, oc = { name: "infiniteScroll", create() { Se(this, { infiniteScroll: ic }) }, on: { tabMounted(n) { const e = this, t = y(n), a = t.find(".infinite-scroll-content"); t.is(".infinite-scroll-content") && a.add(t), a.each(s => { e.infiniteScroll.create(s) }) }, tabBeforeRemove(n) { const e = y(n), t = this, a = e.find(".infinite-scroll-content"); e.is(".infinite-scroll-content") && a.add(e), a.each(s => { t.infiniteScroll.destroy(s) }) }, pageInit(n) { const e = this; n.$el.find(".infinite-scroll-content").each(t => { e.infiniteScroll.create(t) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".infinite-scroll-content").each(t => { e.infiniteScroll.destroy(t) }) } } }; let Ln = class extends me { constructor(e, t) { super({}, [e]); const a = this, s = ue(), r = Ee(), i = y(t), o = i.find(".ptr-preloader"); a.$el = i, a.el = i[0], a.app = e, a.bottom = a.$el.hasClass("ptr-bottom"), a.useModulesParams({}); const l = e.theme === "md", c = e.theme === "ios"; a.done = function () { const Y = l ? o : i, X = K => { y(K.target).closest(o).length || (i.removeClass("ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing"), i.trigger("ptr:done"), a.emit("local::done ptrDone", i[0]), Y.off("transitionend", X)) }; return Y.on("transitionend", X), i.removeClass("ptr-refreshing").addClass("ptr-transitioning ptr-closing"), a }, a.refresh = function () { return i.hasClass("ptr-refreshing") || (i.addClass("ptr-transitioning ptr-refreshing"), i.trigger("ptr:refresh", a.done), a.emit("local::refresh ptrRefresh", i[0], a.done)), a }, a.mousewheel = i.attr("data-ptr-mousewheel") === "true"; let d, u, p; const m = {}; let f, h, b = !1, g = !1, v = !1, E = 0, $, w, C, k, M, A, O = !1, S, P, T; const I = i.parents(".page"); if ((I.find(".navbar").length > 0 || I.parents(".view").children(".navbars").length > 0) && (O = !0), I.hasClass("no-navbar") && (O = !1), !a.bottom) { const j = e.navbar.getElByPage(I[0]); if (j) { const Y = y(j), X = Y.hasClass("navbar-large-transparent") || Y.hasClass("navbar-large") && Y.hasClass("navbar-transparent"), K = Y.hasClass("navbar-transparent") && !Y.hasClass("navbar-large"); X ? i.addClass("ptr-with-navbar-large-transparent") : K && i.addClass("ptr-with-navbar-transparent") } } !O && !a.bottom && i.addClass("ptr-no-navbar"), i.attr("data-ptr-distance") ? M = !0 : l ? k = 66 : c && (k = 44); function H(j) { j === void 0 && (j = 0); const Y = o.find(".preloader-inner-line"), X = 1 / Y.length; Y.forEach((K, W) => { const G = (j - W * X) / X; K.style.opacity = Math.max(Math.min(G, 1), 0) * .27 }) } function D() { o.find(".preloader-inner-line").css("opacity", "") } function z(j) { if (j.isTrusted) { if (u) if (s.os === "android") { if ("targetTouches" in j && j.targetTouches.length > 1) return } else return; i.hasClass("ptr-refreshing") || y(j.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length || (p = !1, A = !1, u = !0, f = void 0, C = void 0, j.type === "touchstart" && (d = j.targetTouches[0].identifier), m.x = j.type === "touchstart" ? j.targetTouches[0].pageX : j.pageX, m.y = j.type === "touchstart" ? j.targetTouches[0].pageY : j.pageY) } } function B(j) { if (!u || !j.isTrusted) return; let Y, X, K; if (j.type === "touchmove") { if (d && j.touches) for (let G = 0; G < j.touches.length; G += 1)j.touches[G].identifier === d && (K = j.touches[G]); K || (K = j.targetTouches[0]), Y = K.pageX, X = K.pageY } else Y = j.pageX, X = j.pageY; if (!Y || !X) return; if (typeof f > "u" && (f = !!(f || Math.abs(X - m.y) > Math.abs(Y - m.x))), !f) { u = !1; return } if (w = i[0].scrollTop, !p) { i.removeClass("ptr-transitioning"), c && H(0); let G; if (S = i[0].scrollHeight, P = i[0].offsetHeight, a.bottom && (T = S - P), w > S) { u = !1; return } const Z = y(j.target).closest(".ptr-watch-scroll"); if (Z.length && Z.each(ie => { ie !== t && ie.scrollHeight > ie.offsetHeight && y(ie).css("overflow") === "auto" && (!a.bottom && ie.scrollTop > 0 || a.bottom && ie.scrollTop < ie.scrollHeight - ie.offsetHeight) && (G = !0) }), G) { u = !1; return } M && (k = i.attr("data-ptr-distance"), k.indexOf("%") >= 0 && (k = S * parseInt(k, 10) / 100)), E = i.hasClass("ptr-refreshing") ? k : 0, S === P || s.os !== "ios" || l ? g = !0 : g = !1, v = !1 } if (p = !0, h = X - m.y, typeof C > "u" && (a.bottom ? w !== T : w !== 0) && (C = !0), a.bottom ? h < 0 && w >= T || w > T : h > 0 && w <= 0 || w < 0) { s.os === "ios" && parseInt(s.osVersion.split(".")[0], 10) > 7 && (!a.bottom && w === 0 && !C && (g = !0), a.bottom && w === T && !C && (g = !0)), !g && a.bottom && !l && (i.css("-webkit-overflow-scrolling", "auto"), i.scrollTop(T), v = !0), g || v ? (j.cancelable && j.preventDefault(), $ = (a.bottom ? -1 * Math.abs(h) ** .85 : h ** .85) + E, l ? o.transform(`translate3d(0,${$}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(h) / 66) + 100}deg)`) : (a.bottom || c ? i.children().transform(`translate3d(0,${$}px,0)`) : i.transform(`translate3d(0,${$}px,0)`), c && o.transform("translate3d(0,0px,0)"))) : c && !a.bottom && o.transform(`translate3d(0,${w}px,0)`); let G; c && !b && (G = g || v ? Math.abs(h) ** .85 / k : Math.abs(h) / (k * 2), H(G)), (g || v) && Math.abs(h) ** .85 > k || !g && Math.abs(h) >= k * 2 ? (b = !0, i.addClass("ptr-pull-up").removeClass("ptr-pull-down"), D()) : (b = !1, i.removeClass("ptr-pull-up").addClass("ptr-pull-down")), A || (i.trigger("ptr:pullstart"), a.emit("local::pullStart ptrPullStart", i[0]), A = !0), i.trigger("ptr:pullmove", { event: j, scrollTop: w, translate: $, touchesDiff: h }), a.emit("local::pullMove ptrPullMove", i[0], { event: j, scrollTop: w, translate: $, touchesDiff: h }) } else A = !1, i.removeClass("ptr-pull-up ptr-pull-down"), b = !1 } function L(j) { if (j.isTrusted) { if (j.type === "touchend" && j.changedTouches && j.changedTouches.length > 0 && d && j.changedTouches[0].identifier !== d) { u = !1, f = !1, p = !1, d = null; return } if (!u || !p) { u = !1, p = !1; return } $ && (i.addClass("ptr-transitioning"), $ = 0), l ? o.transform("").find(".ptr-arrow").transform("") : (o.transform(""), a.bottom || c ? i.children().transform("") : i.transform("")), !g && a.bottom && !l && i.css("-webkit-overflow-scrolling", ""), b ? (i.addClass("ptr-refreshing"), i.trigger("ptr:refresh", a.done), a.emit("local::refresh ptrRefresh", i[0], a.done)) : i.removeClass("ptr-pull-down"), u = !1, p = !1, A && (i.trigger("ptr:pullend"), a.emit("local::pullEnd ptrPullEnd", i[0])) } } let N, F, V = !0, _ = 0; function J() { V = !0, F = !1, _ = 0, $ && (i.addClass("ptr-transitioning"), $ = 0), l ? o.transform("").find(".ptr-arrow").transform("") : (o.transform(""), a.bottom ? i.children().transform("") : i.transform("")), b ? (i.addClass("ptr-refreshing"), i.trigger("ptr:refresh", a.done), a.emit("local::refresh ptrRefresh", i[0], a.done)) : i.removeClass("ptr-pull-down"), A && (i.trigger("ptr:pullend"), a.emit("local::pullEnd ptrPullEnd", i[0])) } function Q(j) { if (!V) return; const { deltaX: Y, deltaY: X } = j; if (Math.abs(Y) > Math.abs(X) || i.hasClass("ptr-refreshing") || y(j.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length) return; if (clearTimeout(N), w = i[0].scrollTop, !F) { i.removeClass("ptr-transitioning"), c && H(0); let W; if (S = i[0].scrollHeight, P = i[0].offsetHeight, a.bottom && (T = S - P), w > S) { V = !1; return } const G = y(j.target).closest(".ptr-watch-scroll"); if (G.length && G.each(Z => { Z !== t && Z.scrollHeight > Z.offsetHeight && y(Z).css("overflow") === "auto" && (!a.bottom && Z.scrollTop > 0 || a.bottom && Z.scrollTop < Z.scrollHeight - Z.offsetHeight) && (W = !0) }), W) { V = !1; return } M && (k = i.attr("data-ptr-distance"), k.indexOf("%") >= 0 && (k = S * parseInt(k, 10) / 100)) } if (p = !0, _ -= X, h = _, typeof C > "u" && (a.bottom ? w !== T : w !== 0) && (C = !0), a.bottom ? h < 0 && w >= T || w > T : h > 0 && w <= 0 || w < 0) { j.cancelable && j.preventDefault(), $ = h, Math.abs($) > k && ($ = k + (Math.abs($) - k) ** .7, a.bottom && ($ = -$)), l ? o.transform(`translate3d(0,${$}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(h) / 66) + 100}deg)`) : a.bottom ? i.children().transform(`translate3d(0,${$}px,0)`) : (i.transform(`translate3d(0,${$}px,0)`), c && o.transform(`translate3d(0,${-$}px,0)`)); let W; c && !b && (W = Math.abs($) / k, H(W)), Math.abs($) > k ? (b = !0, i.addClass("ptr-pull-up").removeClass("ptr-pull-down"), D()) : (b = !1, i.removeClass("ptr-pull-up").addClass("ptr-pull-down")), A || (i.trigger("ptr:pullstart"), a.emit("local::pullStart ptrPullStart", i[0]), A = !0), i.trigger("ptr:pullmove", { event: j, scrollTop: w, translate: $, touchesDiff: h }), a.emit("local::pullMove ptrPullMove", i[0], { event: j, scrollTop: w, translate: $, touchesDiff: h }) } else A = !1, i.removeClass("ptr-pull-up ptr-pull-down"), b = !1; N = setTimeout(J, 300) } return !I.length || !i.length || (i[0].f7PullToRefresh = a, a.attachEvents = function () { const Y = r.passiveListener ? { passive: !0 } : !1; i.on(e.touchEvents.start, z, Y), e.on("touchmove:active", B), e.on("touchend:passive", L), a.mousewheel && !a.bottom && i.on("wheel", Q) }, a.detachEvents = function () { const Y = r.passiveListener ? { passive: !0 } : !1; i.off(e.touchEvents.start, z, Y), e.off("touchmove:active", B), e.off("touchend:passive", L), a.mousewheel && !a.bottom && i.off("wheel", Q) }, a.useModules(), a.init()), a } init() { this.attachEvents() } destroy() { let e = this; e.emit("local::beforeDestroy ptrBeforeDestroy", e), e.$el.trigger("ptr:beforedestroy"), delete e.el.f7PullToRefresh, e.detachEvents(), ve(e), e = null } }; const lc = { name: "pullToRefresh", create() { const n = this; n.ptr = R(we({ defaultSelector: ".ptr-content", constructor: Ln, app: n, domProp: "f7PullToRefresh" }), { done(e) { const t = n.ptr.get(e); if (t) return t.done() }, refresh(e) { const t = n.ptr.get(e); if (t) return t.refresh() } }) }, static: { PullToRefresh: Ln }, on: { tabMounted(n) { const e = this, t = y(n), a = t.find(".ptr-content"); t.is(".ptr-content") && a.add(t), a.each(s => { e.ptr.create(s) }) }, tabBeforeRemove(n) { const e = y(n), t = this, a = e.find(".ptr-content"); e.is(".ptr-content") && a.add(e), a.each(s => { t.ptr.destroy(s) }) }, pageInit(n) { const e = this; n.$el.find(".ptr-content").each(t => { e.ptr.create(t) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".ptr-content").each(t => { e.ptr.destroy(t) }) } } }; let Rn = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = {}; a.useModulesParams(s), a.params = R(s, t); const r = y(a.params.el); if (r.length === 0) return; if (a.$el = r, a.el = r[0], a.$el[0].f7DataTable) { const l = a.$el[0].f7DataTable; return a.destroy(), l } a.$el[0].f7DataTable = a, R(a, { collapsible: r.hasClass("data-table-collapsible"), $headerEl: r.find(".data-table-header"), $headerSelectedEl: r.find(".data-table-header-selected") }); function i(l) { if (l.detail && l.detail.sentByF7DataTable) return; const c = y(this), d = c[0].checked, u = c.parents("td,th").index(); if (c.parents("thead").length > 0) u === 0 && r.find("tbody tr")[d ? "addClass" : "removeClass"]("data-table-row-selected"), r.find(`tbody tr td:nth-child(${u + 1}) input`).prop("checked", d).trigger("change", { sentByF7DataTable: !0 }), c.prop("indeterminate", !1); else { u === 0 && c.parents("tr")[d ? "addClass" : "removeClass"]("data-table-row-selected"); const p = r.find(`tbody .checkbox-cell:nth-child(${u + 1}) input[type="checkbox"]:checked`).length, m = r.find("tbody tr").length, f = r.find(`thead .checkbox-cell:nth-child(${u + 1}) input[type="checkbox"]`); d ? p === m && f.prop("checked", !0).trigger("change", { sentByF7DataTable: !0 }) : f.prop("checked", !1), f.prop("indeterminate", p > 0 && p < m) } a.checkSelectedHeader() } function o() { const l = y(this), c = l.hasClass("sortable-cell-active"), d = l.hasClass("sortable-desc") ? "desc" : "asc"; let u; c ? (u = d === "desc" ? "asc" : "desc", l.removeClass("sortable-desc sortable-asc").addClass(`sortable-${u}`)) : (r.find("thead .sortable-cell-active").removeClass("sortable-cell-active"), l.addClass("sortable-cell-active"), u = d), l.trigger("datatable:sort", u), a.emit("local::sort dataTableSort", a, u) } return a.attachEvents = function () { a.$el.on("change", '.checkbox-cell input[type="checkbox"]', i), a.$el.find("thead .sortable-cell").on("click", o) }, a.detachEvents = function () { a.$el.off("change", '.checkbox-cell input[type="checkbox"]', i), a.$el.find("thead .sortable-cell").off("click", o) }, a.useModules(), a.init(), a } setCollapsibleLabels() { const e = this; e.collapsible && e.$el.find("tbody td:not(.checkbox-cell)").each(t => { const a = y(t), s = a.index(), r = a.attr("data-collapsible-title"); !r && r !== "" && a.attr("data-collapsible-title", e.$el.find("thead th").eq(s).text()) }) } checkSelectedHeader() { const e = this; if (e.$headerEl.length > 0 && e.$headerSelectedEl.length > 0) { const t = e.$el.find("tbody .checkbox-cell input:checked").length; e.$el[t > 0 ? "addClass" : "removeClass"]("data-table-has-checked"), e.$headerSelectedEl.find(".data-table-selected-count").text(t) } } init() { const e = this; e.attachEvents(), e.setCollapsibleLabels(), e.checkSelectedHeader() } destroy() { let e = this; e.$el.trigger("datatable:beforedestroy"), e.emit("local::beforeDestroy dataTableBeforeDestroy", e), e.detachEvents(), e.$el[0] && (e.$el[0].f7DataTable = null, delete e.$el[0].f7DataTable), ve(e), e = null } }; const cc = { name: "dataTable", static: { DataTable: Rn }, create() { const n = this; n.dataTable = we({ defaultSelector: ".data-table", constructor: Rn, app: n, domProp: "f7DataTable" }) }, on: { tabBeforeRemove(n) { const e = this; y(n).find(".data-table-init").each(t => { e.dataTable.destroy(t) }) }, tabMounted(n) { const e = this; y(n).find(".data-table-init").each(t => { e.dataTable.create({ el: t }) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".data-table-init").each(t => { e.dataTable.destroy(t) }) }, pageInit(n) { const e = this; n.$el.find(".data-table-init").each(t => { e.dataTable.create({ el: t }) }) } }, vnode: { "data-table-init": { insert(n) { const e = this, t = n.elm; e.dataTable.create({ el: t }) }, destroy(n) { const e = this, t = n.elm; e.dataTable.destroy(t) } } } }, dc = { morphOpen(n, e) { const t = this, a = y(n), s = y(e); if (s.length === 0) return; s.transition(0).addClass("fab-morph-target-visible"); const r = { width: s[0].offsetWidth, height: s[0].offsetHeight, offset: s.offset(), borderRadius: s.css("border-radius"), zIndex: s.css("z-index") }, i = { width: a[0].offsetWidth, height: a[0].offsetHeight, offset: a.offset(), translateX: Ut(a[0], "x"), translateY: Ut(a[0], "y") }; a[0].f7FabMorphData = { $targetEl: s, target: r, fab: i }; const o = i.offset.left + i.width / 2 - (r.offset.left + r.width / 2) - i.translateX, l = i.offset.top + i.height / 2 - (r.offset.top + r.height / 2) - i.translateY, c = r.width / i.width, d = r.height / i.height; let u = Math.ceil(parseInt(r.borderRadius, 10) / Math.max(c, d)); u > 0 && (u += 2), a[0].f7FabMorphResizeHandler = function () { a.transition(0).transform(""), s.transition(0), r.width = s[0].offsetWidth, r.height = s[0].offsetHeight, r.offset = s.offset(), i.offset = a.offset(); const m = i.offset.left + i.width / 2 - (r.offset.left + r.width / 2) - i.translateX, f = i.offset.top + i.height / 2 - (r.offset.top + r.height / 2) - i.translateY, h = r.width / i.width, b = r.height / i.height; a.transform(`translate3d(${-m}px, ${-f}px, 0) scale(${h}, ${b})`) }, s.css("opacity", 0).transform(`scale(${1 / c}, ${1 / d})`), a.addClass("fab-opened").css("z-index", r.zIndex - 1).transform(`translate3d(${-o}px, ${-l}px, 0)`), a.transitionEnd(() => { s.transition(""), Ae(() => { s.css("opacity", 1).transform("scale(1,1)"), a.transform(`translate3d(${-o}px, ${-l}px, 0) scale(${c}, ${d})`).css("border-radius", `${u}px`).css("box-shadow", "none").css("opacity", "0") }), t.on("resize", a[0].f7FabMorphResizeHandler), s.parents(".page-content").length > 0 && s.parents(".page-content").on("scroll", a[0].f7FabMorphResizeHandler) }) }, morphClose(n) { const e = this, t = y(n), a = t[0].f7FabMorphData; if (!a) return; const { $targetEl: s, target: r, fab: i } = a; if (s.length === 0) return; const o = i.offset.left + i.width / 2 - (r.offset.left + r.width / 2) - i.translateX, l = i.offset.top + i.height / 2 - (r.offset.top + r.height / 2) - i.translateY, c = r.width / i.width, d = r.height / i.height; e.off("resize", t[0].f7FabMorphResizeHandler), s.parents(".page-content").length > 0 && s.parents(".page-content").off("scroll", t[0].f7FabMorphResizeHandler), s.css("opacity", 0).transform(`scale(${1 / c}, ${1 / d})`), t.transition("").css("box-shadow", "").css("border-radius", "").css("opacity", "1").transform(`translate3d(${-o}px, ${-l}px, 0)`), t.transitionEnd(() => { t.css("z-index", "").removeClass("fab-opened").transform(""), Ae(() => { t.transitionEnd(() => { s.removeClass("fab-morph-target-visible").css("opacity", "").transform("").transition("") }) }) }) }, open(n, e) { const t = this, a = y(n).eq(0), s = a.find(".fab-buttons"); if (a.length && !a.hasClass("fab-opened") && !(!s.length && !a.hasClass("fab-morph"))) { if (t.fab.openedEl) { if (t.fab.openedEl === a[0]) return; t.fab.close(t.fab.openedEl) } t.fab.openedEl = a[0], a.hasClass("fab-morph") ? t.fab.morphOpen(a, e || a.attr("data-morph-to")) : a.addClass("fab-opened"), a.siblings(".fab-backdrop").addClass("backdrop-in"), a.trigger("fab:open") } }, close(n) { n === void 0 && (n = ".fab-opened"); const e = this, t = y(n).eq(0), a = t.find(".fab-buttons"); t.length && t.hasClass("fab-opened") && (!a.length && !t.hasClass("fab-morph") || (e.fab.openedEl = null, t.hasClass("fab-morph") ? e.fab.morphClose(t) : t.removeClass("fab-opened"), t.siblings(".fab-backdrop").removeClass("backdrop-in"), t.trigger("fab:close"))) }, toggle(n) { const e = this; y(n).hasClass("fab-opened") ? e.fab.close(n) : e.fab.open(n) } }, uc = { name: "fab", create() { Se(this, { fab: { openedEl: null, ...dc } }) }, clicks: { ".fab > a": function (e) { this.fab.toggle(e.parents(".fab")) }, ".fab-open": function (e, t) { t === void 0 && (t = {}), this.fab.open(t.fab) }, ".fab-close": function (e, t) { t === void 0 && (t = {}), this.fab.close(t.fab) }, ".fab-backdrop": function () { this.fab.close() } } }; let Hn = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = { el: void 0, inputEl: void 0, inputEvents: "change input compositionend", disableButton: !0, disableButtonEl: void 0, backdropEl: void 0, searchContainer: void 0, searchItem: "li", searchIn: void 0, searchGroup: ".list-group", searchGroupTitle: ".list-group-title", ignore: ".searchbar-ignore", foundEl: ".searchbar-found", notFoundEl: ".searchbar-not-found", hideOnEnableEl: ".searchbar-hide-on-enable", hideOnSearchEl: ".searchbar-hide-on-search", backdrop: !0, removeDiacritics: !0, customSearch: !1, hideGroupTitles: !0, hideGroups: !0, disableOnBackdropClick: !0, expandable: !1, inline: !1 }; a.useModulesParams(s), a.params = R(s, t); const r = y(a.params.el); if (r.length === 0) return a; if (r[0].f7Searchbar) return r[0].f7Searchbar; r[0].f7Searchbar = a; let i; const o = r.parents(".navbar"); if (r.parents(".page").length > 0) i = r.parents(".page"); else if (o.length > 0 && (i = y(e.navbar.getPageByEl(o[0])), !i.length)) { const O = r.parents(".view").find(".page-current"); O[0] && O[0].f7Page && O[0].f7Page.navbarEl === o[0] && (i = O) } let l; t.foundEl ? l = y(t.foundEl) : typeof a.params.foundEl == "string" && i && (l = i.find(a.params.foundEl)); let c; t.notFoundEl ? c = y(t.notFoundEl) : typeof a.params.notFoundEl == "string" && i && (c = i.find(a.params.notFoundEl)); let d; t.hideOnEnableEl ? d = y(t.hideOnEnableEl) : typeof a.params.hideOnEnableEl == "string" && i && (d = i.find(a.params.hideOnEnableEl)); let u; t.hideOnSearchEl ? u = y(t.hideOnSearchEl) : typeof a.params.hideOnSearchEl == "string" && i && (u = i.find(a.params.hideOnSearchEl)); const p = a.params.expandable || r.hasClass("searchbar-expandable"), m = a.params.inline || r.hasClass("searchbar-inline"); typeof a.params.backdrop > "u" && (a.params.backdrop = !m); let f; a.params.backdrop && (a.params.backdropEl ? f = y(a.params.backdropEl) : i && i.length > 0 ? f = i.find(".searchbar-backdrop") : f = r.siblings(".searchbar-backdrop"), f.length === 0 && (f = y('<div class="searchbar-backdrop"></div>'), i && i.length ? r.parents(i).length > 0 && o && r.parents(o).length === 0 ? f.insertBefore(r) : f.insertBefore(i.find(".page-content").eq(0)) : f.insertBefore(r))); let h; a.params.searchContainer && (h = y(a.params.searchContainer)); let b; a.params.inputEl ? b = y(a.params.inputEl) : b = r.find('input[type="search"]').eq(0); let g; a.params.disableButton && (a.params.disableButtonEl ? g = y(a.params.disableButtonEl) : g = r.find(".searchbar-disable-button")), R(a, { app: e, view: e.views.get(r.parents(".view")), $el: r, el: r[0], $backdropEl: f, backdropEl: f && f[0], $searchContainer: h, searchContainer: h && h[0], $inputEl: b, inputEl: b[0], $disableButtonEl: g, disableButtonEl: g && g[0], disableButtonHasMargin: !1, $pageEl: i, pageEl: i && i[0], $navbarEl: o, navbarEl: o && o[0], $foundEl: l, foundEl: l && l[0], $notFoundEl: c, notFoundEl: c && c[0], $hideOnEnableEl: d, hideOnEnableEl: d && d[0], $hideOnSearchEl: u, hideOnSearchEl: u && u[0], previousQuery: "", query: "", isVirtualList: h && h.hasClass("virtual-list"), virtualList: void 0, enabled: !1, expandable: p, inline: m }); function v(O) { O.preventDefault() } function E(O) { a.enable(O), a.$el.addClass("searchbar-focused") } function $() { a.$el.removeClass("searchbar-focused") } function w() { const O = a.$inputEl.val().trim(); (a.$searchContainer && a.$searchContainer.length > 0 && (a.params.searchIn || a.isVirtualList || a.params.searchIn === a.params.searchItem) || a.params.customSearch) && a.search(O, !0) } function C(O, S) { a.$el.trigger("searchbar:clear", S), a.emit("local::clear searchbarClear", a, S) } function k(O) { a.disable(O) } function M() { !a || a && !a.$el || a.enabled && (a.$el.removeClass("searchbar-enabled"), a.expandable && a.$el.parents(".navbar").removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition")) } function A() { !a || a && !a.$el || a.enabled && (a.$el.addClass("searchbar-enabled"), a.expandable && a.$el.parents(".navbar").addClass("with-searchbar-expandable-enabled-no-transition")) } return a.attachEvents = function () { r.on("submit", v), a.params.disableButton && a.$disableButtonEl.on("click", k), a.params.disableOnBackdropClick && a.$backdropEl && a.$backdropEl.on("click", k), a.expandable && e.theme === "ios" && a.view && o.length && a.$pageEl && (a.$pageEl.on("page:beforeout", M), a.$pageEl.on("page:beforein", A)), a.$inputEl.on("focus", E), a.$inputEl.on("blur", $), a.$inputEl.on(a.params.inputEvents, w), a.$inputEl.on("input:clear", C) }, a.detachEvents = function () { r.off("submit", v), a.params.disableButton && a.$disableButtonEl.off("click", k), a.params.disableOnBackdropClick && a.$backdropEl && a.$backdropEl.off("click", k), a.expandable && e.theme === "ios" && a.view && o.length && a.$pageEl && (a.$pageEl.off("page:beforeout", M), a.$pageEl.off("page:beforein", A)), a.$inputEl.off("focus", E), a.$inputEl.off("blur", $), a.$inputEl.off(a.params.inputEvents, w), a.$inputEl.off("input:clear", C) }, a.useModules(), a.init(), a } clear(e) { const t = this; if (!t.query && e && y(e.target).hasClass("searchbar-clear")) return t.disable(), t; const a = t.value; return t.$inputEl.val("").trigger("change").focus(), t.$el.trigger("searchbar:clear", a), t.emit("local::clear searchbarClear", t, a), t } setDisableButtonMargin() { const e = this; if (e.expandable) return; const t = e.app; e.$disableButtonEl.transition(0).show(), e.$disableButtonEl.css(`margin-${t.rtl ? "left" : "right"}`, `${-e.disableButtonEl.offsetWidth}px`), e._clientLeft = e.$disableButtonEl[0].clientLeft, e.$disableButtonEl.transition(""), e.disableButtonHasMargin = !0 } enable(e) { const t = this; if (t.enabled) return t; const a = t.app, s = ee(), r = ue(); t.enabled = !0; function i() { if (t.$backdropEl && (t.$searchContainer && t.$searchContainer.length || t.params.customSearch) && !t.$el.hasClass("searchbar-enabled") && !t.query && t.backdropShow(), t.$el.addClass("searchbar-enabled"), (!t.$disableButtonEl || t.$disableButtonEl && t.$disableButtonEl.length === 0) && t.$el.addClass("searchbar-enabled-no-disable-button"), !t.expandable && t.$disableButtonEl && t.$disableButtonEl.length > 0 && a.theme !== "md" && (t.disableButtonHasMargin || t.setDisableButtonMargin(), t.$disableButtonEl.css(`margin-${a.rtl ? "left" : "right"}`, "0px")), t.expandable) { const c = t.$el.parents(".navbar"); if (c.hasClass("navbar-large") && t.$pageEl) { const d = t.$pageEl.find(".page-content"), u = c.find(".title-large"); d.addClass("with-searchbar-expandable-enabled"), c.hasClass("navbar-large") && c.hasClass("navbar-large-collapsed") && u.length && d.length && (d.transition(0), d[0].scrollTop -= u[0].offsetHeight, setTimeout(() => { d.transition("") }, 200)) } a.theme === "md" && c.length ? c.addClass("with-searchbar-expandable-enabled") : (c.addClass("with-searchbar-expandable-enabled"), c.hasClass("navbar-large") && c.addClass("navbar-large-collapsed")) } t.$hideOnEnableEl && t.$hideOnEnableEl.addClass("hidden-by-searchbar"), t.$el.trigger("searchbar:enable"), t.emit("local::enable searchbarEnable", t) } let o = !1; return e === !0 && s.activeElement !== t.inputEl && (o = !0), r.ios && a.theme === "ios" ? t.expandable ? (o && t.$inputEl.focus(), i()) : (o && t.$inputEl.focus(), e && (e.type === "focus" || e === !0) ? $e(() => { i() }, 400) : i()) : (o && t.$inputEl.focus(), a.theme === "md" && t.expandable && t.$el.parents(".page, .view, .navbar-inner, .navbar").scrollLeft(a.rtl ? 100 : 0), i()), t } disable() { const e = this; if (!e.enabled) return e; const t = e.app; if (e.$inputEl.val("").trigger("change"), e.$el.removeClass("searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button"), e.expandable) { const a = e.$el.parents(".navbar"), s = e.$pageEl && e.$pageEl.find(".page-content"); if (a.hasClass("navbar-large") && s.length) { const r = a.find(".title-large"); if (e.$el.transitionEnd(() => { s.removeClass("with-searchbar-expandable-closing") }), a.hasClass("navbar-large") && a.hasClass("navbar-large-collapsed") && r.length) { const i = s[0].scrollTop, o = r[0].offsetHeight; i > o && (s.transition(0), s[0].scrollTop = i + o, setTimeout(() => { s.transition("") }, 200)) } s.removeClass("with-searchbar-expandable-enabled").addClass("with-searchbar-expandable-closing") } t.theme === "md" && a.length ? (a.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing"), e.$el.transitionEnd(() => { a.removeClass("with-searchbar-expandable-closing") })) : (a.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing"), e.$el.transitionEnd(() => { a.removeClass("with-searchbar-expandable-closing") }), e.$pageEl && e.$pageEl.find(".page-content").trigger("scroll")) } return !e.expandable && e.$disableButtonEl && e.$disableButtonEl.length > 0 && t.theme !== "md" && e.$disableButtonEl.css(`margin-${t.rtl ? "left" : "right"}`, `${-e.disableButtonEl.offsetWidth}px`), e.$backdropEl && (e.$searchContainer && e.$searchContainer.length || e.params.customSearch) && e.backdropHide(), e.enabled = !1, e.$inputEl.blur(), e.$hideOnEnableEl && e.$hideOnEnableEl.removeClass("hidden-by-searchbar"), e.$el.trigger("searchbar:disable"), e.emit("local::disable searchbarDisable", e), e } toggle() { const e = this; return e.enabled ? e.disable() : e.enable(!0), e } backdropShow() { const e = this; return e.$backdropEl && e.$backdropEl.addClass("searchbar-backdrop-in"), e } backdropHide() { const e = this; return e.$backdropEl && e.$backdropEl.removeClass("searchbar-backdrop-in"), e } search(e, t) { const a = this; if (a.previousQuery = a.query || "", e === a.previousQuery) return a; t || (a.enabled || a.enable(), a.$inputEl.val(e), a.$inputEl.trigger("input")), a.query = e, a.value = e; const { $searchContainer: s, $el: r, $foundEl: i, $notFoundEl: o, $hideOnSearchEl: l, isVirtualList: c } = a; if (e.length > 0 && l ? l.addClass("hidden-by-searchbar") : l && l.removeClass("hidden-by-searchbar"), (s && s.length && r.hasClass("searchbar-enabled") || a.params.customSearch && r.hasClass("searchbar-enabled")) && (e.length === 0 ? a.backdropShow() : a.backdropHide()), a.params.customSearch) return r.trigger("searchbar:search", { query: e, previousQuery: a.previousQuery }), a.emit("local::search searchbarSearch", a, e, a.previousQuery), a; let d = [], u; if (c) { if (a.virtualList = s[0].f7VirtualList, e.trim() === "") return a.virtualList.resetFilter(), o && o.hide(), i && i.show(), r.trigger("searchbar:search", { query: e, previousQuery: a.previousQuery }), a.emit("local::search searchbarSearch", a, e, a.previousQuery), a; if (u = a.params.removeDiacritics ? jt(e) : e, a.virtualList.params.searchAll) d = a.virtualList.params.searchAll(u, a.virtualList.items) || []; else if (a.virtualList.params.searchByItem) for (let p = 0; p < a.virtualList.items.length; p += 1)a.virtualList.params.searchByItem(u, a.virtualList.items[p], p) && d.push(p) } else { let p; a.params.removeDiacritics ? p = jt(e.trim().toLowerCase()).split(" ") : p = e.trim().toLowerCase().split(" "), s.find(a.params.searchItem).removeClass("hidden-by-searchbar").each(m => { const f = y(m); let h = [], b = a.params.searchIn ? f.find(a.params.searchIn) : f; a.params.searchIn === a.params.searchItem && (b = f), b.each(v => { let E = y(v).text().trim().toLowerCase(); a.params.removeDiacritics && (E = jt(E)), h.push(E) }), h = h.join(" "); let g = 0; for (let v = 0; v < p.length; v += 1)h.indexOf(p[v]) >= 0 && (g += 1); g !== p.length && !(a.params.ignore && f.is(a.params.ignore)) ? f.addClass("hidden-by-searchbar") : d.push(f[0]) }), a.params.hideGroupTitles && s.find(a.params.searchGroupTitle).each(m => { const f = y(m), h = f.nextAll(a.params.searchItem); let b = !0; for (let v = 0; v < h.length; v += 1) { const E = h.eq(v); if (E.is(a.params.searchGroupTitle)) break; E.hasClass("hidden-by-searchbar") || (b = !1) } const g = a.params.ignore && f.is(a.params.ignore); b && !g ? f.addClass("hidden-by-searchbar") : f.removeClass("hidden-by-searchbar") }), a.params.hideGroups && s.find(a.params.searchGroup).each(m => { const f = y(m), h = a.params.ignore && f.is(a.params.ignore); f.find(a.params.searchItem).filter(g => !y(g).hasClass("hidden-by-searchbar")).length === 0 && !h ? f.addClass("hidden-by-searchbar") : f.removeClass("hidden-by-searchbar") }) } return d.length === 0 ? (o && o.show(), i && i.hide()) : (o && o.hide(), i && i.show()), c && a.virtualList && a.virtualList.filterItems(d), r.trigger("searchbar:search", { query: e, previousQuery: a.previousQuery, foundItems: d }), a.emit("local::search searchbarSearch", a, e, a.previousQuery, d), a } init() { const e = this; e.expandable && e.$el && e.$el.addClass("searchbar-expandable"), e.inline && e.$el && e.$el.addClass("searchbar-inline"), e.attachEvents() } destroy() { const e = this; e.emit("local::beforeDestroy searchbarBeforeDestroy", e), e.$el.trigger("searchbar:beforedestroy"), e.detachEvents(), e.$el[0] && (e.$el[0].f7Searchbar = null, delete e.$el[0].f7Searchbar), ve(e) } }; const pc = { name: "searchbar", static: { Searchbar: Hn }, create() { const n = this; n.searchbar = we({ defaultSelector: ".searchbar", constructor: Hn, app: n, domProp: "f7Searchbar", addMethods: "clear enable disable toggle search".split(" ") }) }, on: { tabMounted(n) { const e = this; y(n).find(".searchbar-init").each(t => { const a = y(t); e.searchbar.create(R(a.dataset(), { el: t })) }) }, tabBeforeRemove(n) { y(n).find(".searchbar-init").each(e => { e.f7Searchbar && e.f7Searchbar.destroy && e.f7Searchbar.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".searchbar-init").each(t => { const a = y(t); e.searchbar.create(R(a.dataset(), { el: t })) }), e.theme === "ios" && n.view && n.view.router.dynamicNavbar && n.$navbarEl && n.$navbarEl.length > 0 && n.$navbarEl.find(".searchbar-init").each(t => { const a = y(t); e.searchbar.create(R(a.dataset(), { el: t })) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".searchbar-init").each(t => { t.f7Searchbar && t.f7Searchbar.destroy && t.f7Searchbar.destroy() }), e.theme === "ios" && n.view && n.view.router.dynamicNavbar && n.$navbarEl && n.$navbarEl.length > 0 && n.$navbarEl.find(".searchbar-init").each(t => { t.f7Searchbar && t.f7Searchbar.destroy && t.f7Searchbar.destroy() }) } }, clicks: { ".searchbar-clear": function (e, t) { t === void 0 && (t = {}); const s = this.searchbar.get(t.searchbar); s && s.clear() }, ".searchbar-enable": function (e, t) { t === void 0 && (t = {}); const s = this.searchbar.get(t.searchbar); s && s.enable(!0) }, ".searchbar-disable": function (e, t) { t === void 0 && (t = {}); const s = this.searchbar.get(t.searchbar); s && s.disable() }, ".searchbar-toggle": function (e, t) { t === void 0 && (t = {}); const s = this.searchbar.get(t.searchbar); s && s.toggle() } }, vnode: { "searchbar-init": { insert(n) { const e = this, t = n.elm, a = y(t); e.searchbar.create(R(a.dataset(), { el: t })) }, destroy(n) { const e = n.elm; e.f7Searchbar && e.f7Searchbar.destroy && e.f7Searchbar.destroy() } } } }; function La() { return La = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && (n[a] = t[a]) } return n }, La.apply(this, arguments) } let zn = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = { autoLayout: !0, messages: [], newMessagesFirst: !1, scrollMessages: !0, scrollMessagesOnEdge: !0, firstMessageRule: void 0, lastMessageRule: void 0, tailMessageRule: void 0, sameNameMessageRule: void 0, sameHeaderMessageRule: void 0, sameFooterMessageRule: void 0, sameAvatarMessageRule: void 0, customClassMessageRule: void 0, renderMessage: void 0 }; a.useModulesParams(s), a.params = R(s, t); const r = y(t.el).eq(0); if (r.length === 0) return a; if (r[0].f7Messages) return r[0].f7Messages; r[0].f7Messages = a; const i = r.closest(".page-content").eq(0); return R(a, { messages: a.params.messages, $el: r, el: r[0], $pageContentEl: i, pageContentEl: i[0] }), a.useModules(), a.init(), a } getMessageData(e) { const t = y(e), a = { name: t.find(".message-name").html(), header: t.find(".message-header").html(), textHeader: t.find(".message-text-header").html(), textFooter: t.find(".message-text-footer").html(), footer: t.find(".message-footer").html(), isTitle: t.hasClass("messages-title"), type: t.hasClass("message-sent") ? "sent" : "received", text: t.find(".message-text").html(), image: t.find(".message-image").html(), imageSrc: t.find(".message-image img").attr("src"), typing: t.hasClass("message-typing") }; a.isTitle && (a.text = t.html()), a.text && a.textHeader && (a.text = a.text.replace(`<div class="message-text-header">${a.textHeader}</div>`, "")), a.text && a.textFooter && (a.text = a.text.replace(`<div class="message-text-footer">${a.textFooter}</div>`, "")); let s = t.find(".message-avatar").css("background-image"); return (s === "none" || s === "") && (s = void 0), s && typeof s == "string" ? s = s.replace("url(", "").replace(")", "").replace(/"/g, "").replace(/'/g, "") : s = void 0, a.avatar = s, a } getMessagesData() { const e = this, t = []; return e.$el.find(".message, .messages-title").each(a => { t.push(e.getMessageData(a)) }), t } renderMessage(e) { const t = this, a = R({ type: "sent", attrs: {} }, e); return t.params.renderMessage ? t.params.renderMessage.call(t, a) : a.isTitle ? `<div class="messages-title">${a.text}</div>` : x("div", La({ class: `message message-${a.type} ${a.isTyping ? "message-typing" : ""} ${a.cssClass || ""}` }, a.attrs), a.avatar && x("div", { class: "message-avatar", style: `background-image:url(${a.avatar})` }), x("div", { class: "message-content" }, a.name && x("div", { class: "message-name" }, a.name), a.header && x("div", { class: "message-header" }, a.header), x("div", { class: "message-bubble" }, a.textHeader && x("div", { class: "message-text-header" }, a.textHeader), a.image && x("div", { class: "message-image" }, a.image), a.imageSrc && !a.image && x("div", { class: "message-image" }, x("img", { src: a.imageSrc })), (a.text || a.isTyping) && x("div", { class: "message-text" }, a.text || "", a.isTyping && x("div", { class: "message-typing-indicator" }, x("div", null), x("div", null), x("div", null))), a.textFooter && x("div", { class: "message-text-footer" }, a.textFooter)), a.footer && x("div", { class: "message-footer" }, a.footer))) } renderMessages(e, t) { e === void 0 && (e = this.messages), t === void 0 && (t = this.params.newMessagesFirst ? "prepend" : "append"); const a = this, s = e.map(r => a.renderMessage(r)).join(""); a.$el[t](s) } isFirstMessage() { const e = this; return e.params.firstMessageRule ? e.params.firstMessageRule(...arguments) : !1 } isLastMessage() { const e = this; return e.params.lastMessageRule ? e.params.lastMessageRule(...arguments) : !1 } isTailMessage() { const e = this; return e.params.tailMessageRule ? e.params.tailMessageRule(...arguments) : !1 } isSameNameMessage() { const e = this; return e.params.sameNameMessageRule ? e.params.sameNameMessageRule(...arguments) : !1 } isSameHeaderMessage() { const e = this; return e.params.sameHeaderMessageRule ? e.params.sameHeaderMessageRule(...arguments) : !1 } isSameFooterMessage() { const e = this; return e.params.sameFooterMessageRule ? e.params.sameFooterMessageRule(...arguments) : !1 } isSameAvatarMessage() { const e = this; return e.params.sameAvatarMessageRule ? e.params.sameAvatarMessageRule(...arguments) : !1 } isCustomClassMessage() { const e = this; if (e.params.customClassMessageRule) return e.params.customClassMessageRule(...arguments) } layout() { const e = this; e.$el.find(".message, .messages-title").each((t, a) => { const s = y(t); e.messages || (e.messages = e.getMessagesData()); const r = [], i = e.messages[a], o = e.messages[a - 1], l = e.messages[a + 1]; e.isFirstMessage(i, o, l) && r.push("message-first"), e.isLastMessage(i, o, l) && r.push("message-last"), e.isTailMessage(i, o, l) && r.push("message-tail"), e.isSameNameMessage(i, o, l) && r.push("message-same-name"), e.isSameHeaderMessage(i, o, l) && r.push("message-same-header"), e.isSameFooterMessage(i, o, l) && r.push("message-same-footer"), e.isSameAvatarMessage(i, o, l) && r.push("message-same-avatar"); let c = e.isCustomClassMessage(i, o, l); c && c.length && (typeof c == "string" && (c = c.split(" ")), c.forEach(d => { r.push(d) })), s.removeClass("message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar"), r.forEach(d => { s.addClass(d) }) }) } clear() { const e = this; e.messages = [], e.$el.html("") } removeMessage(e, t) { t === void 0 && (t = !0); const a = this; let s, r; return typeof e == "number" ? (s = e, r = a.$el.find(".message, .messages-title").eq(s)) : a.messages && a.messages.indexOf(e) >= 0 ? (s = a.messages.indexOf(e), r = a.$el.children().eq(s)) : (r = y(e), s = r.index()), r.length === 0 || (r.remove(), a.messages.splice(s, 1), a.params.autoLayout && t && a.layout()), a } removeMessages(e, t) { t === void 0 && (t = !0); const a = this; if (Array.isArray(e)) { const s = []; e.forEach(r => { s.push(a.$el.find(".message, .messages-title").eq(r)) }), s.forEach(r => { a.removeMessage(r, !1) }) } else y(e).each(s => { a.removeMessage(s, !1) }); return a.params.autoLayout && t && a.layout(), a } addMessage() { const e = this; let t, a, s; for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return typeof i[1] == "boolean" ? [t, a, s] = i : [t, s, a] = i, typeof a > "u" && (a = !0), typeof s > "u" && (s = e.params.newMessagesFirst ? "prepend" : "append"), e.addMessages([t], a, s) } setScrollData() { const e = this, t = e.pageContentEl.scrollHeight, a = e.pageContentEl.offsetHeight, s = e.pageContentEl.scrollTop; return e.scrollData = { scrollHeightBefore: t, heightBefore: a, scrollBefore: s }, { scrollHeightBefore: t, heightBefore: a, scrollBefore: s } } addMessages() { const e = this; let t, a, s; for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; typeof i[1] == "boolean" ? [t, a, s] = i : [t, s, a] = i, typeof a > "u" && (a = !0), typeof s > "u" && (s = e.params.newMessagesFirst ? "prepend" : "append"); const { scrollHeightBefore: l, scrollBefore: c } = e.setScrollData(); let d = ""; const u = e.messages.filter(m => m.isTyping)[0]; t.forEach(m => { u ? s === "append" ? e.messages.splice(e.messages.indexOf(u), 0, m) : e.messages.splice(e.messages.indexOf(u) + 1, 0, m) : e.messages[s === "append" ? "push" : "unshift"](m), d += e.renderMessage(m) }); const p = y(d); return a && (s === "append" && !e.params.newMessagesFirst && p.addClass("message-appear-from-bottom"), s === "prepend" && e.params.newMessagesFirst && p.addClass("message-appear-from-top")), u ? s === "append" ? p.insertBefore(e.$el.find(".message-typing")) : p.insertAfter(e.$el.find(".message-typing")) : e.$el[s](p), e.params.autoLayout && e.layout(), s === "prepend" && !u && (e.pageContentEl.scrollTop = c + (e.pageContentEl.scrollHeight - l)), e.params.scrollMessages && (s === "append" && !e.params.newMessagesFirst || s === "prepend" && e.params.newMessagesFirst && !u) && e.scrollWithEdgeCheck(a), e } showTyping(e) { e === void 0 && (e = {}); const t = this, a = t.messages.filter(s => s.isTyping)[0]; return a && t.removeMessage(t.messages.indexOf(a)), t.addMessage(R({ type: "received", isTyping: !0 }, e)), t } hideTyping() { const e = this; let t, a; if (e.messages.forEach((s, r) => { s.isTyping && (t = r) }), typeof t < "u" && e.$el.find(".message").eq(t).hasClass("message-typing") && (a = !0, e.removeMessage(t)), !a) { const s = e.$el.find(".message-typing"); s.length && e.removeMessage(s) } return e } scrollWithEdgeCheck(e) { const t = this, { scrollBefore: a, scrollHeightBefore: s, heightBefore: r } = t.scrollData; if (t.params.scrollMessagesOnEdge) { let i = !1; t.params.newMessagesFirst && a === 0 && (i = !0), !t.params.newMessagesFirst && a - (s - r) >= -10 && (i = !0), i && t.scroll(e ? void 0 : 0) } else t.scroll(e ? void 0 : 0) } scroll(e, t) { e === void 0 && (e = 300); const a = this, s = a.pageContentEl.scrollTop; let r; if (typeof t < "u") r = t; else if (r = a.params.newMessagesFirst ? 0 : a.pageContentEl.scrollHeight - a.pageContentEl.offsetHeight, r === s) return a; return a.$pageContentEl.scrollTop(r, e), a } init() { const e = this; (!e.messages || e.messages.length === 0) && (e.messages = e.getMessagesData()), e.params.messages && e.params.messages.length && e.renderMessages(), e.params.autoLayout && e.layout(), e.params.scrollMessages && e.scroll(0) } destroy() { const e = this; e.emit("local::beforeDestroy messagesBeforeDestroy", e), e.$el.trigger("messages:beforedestroy"), e.$el[0] && (e.$el[0].f7Messages = null, delete e.$el[0].f7Messages), ve(e) } }; const fc = { name: "messages", static: { Messages: zn }, create() { const n = this; n.messages = we({ defaultSelector: ".messages", constructor: zn, app: n, domProp: "f7Messages", addMethods: "renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages".split(" ") }) }, on: { tabBeforeRemove(n) { const e = this; y(n).find(".messages-init").each(t => { e.messages.destroy(t) }) }, tabMounted(n) { const e = this; y(n).find(".messages-init").each(t => { e.messages.create({ el: t }) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".messages-init").each(t => { e.messages.destroy(t) }) }, pageInit(n) { const e = this; n.$el.find(".messages-init").each(t => { e.messages.create({ el: t }) }) } }, vnode: { "messages-init": { insert(n) { const e = this, t = n.elm; e.messages.create({ el: t }) }, destroy(n) { const e = this, t = n.elm; e.messages.destroy(t) } } } }; let Fn = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = { top: !1, topOffset: 0, bottomOffset: 0, attachments: [], renderAttachments: void 0, renderAttachment: void 0, maxHeight: null, resizePage: !0 }; a.useModulesParams(s), a.params = R(s, t); const r = y(a.params.el); if (r.length === 0) return a; if (r[0].f7Messagebar) return r[0].f7Messagebar; r[0].f7Messagebar = a; const i = r.parents(".page").eq(0), o = i.find(".page-content").eq(0), l = r.find(".messagebar-area"); let c; a.params.textareaEl ? c = y(a.params.textareaEl) : c = r.find("textarea"); const d = r.find(".messagebar-attachments"), u = r.find(".messagebar-sheet"); a.params.top && r.addClass("messagebar-top"), R(a, { $el: r, el: r[0], $areaEl: l, areaEl: l[0], $textareaEl: c, textareaEl: c[0], $attachmentsEl: d, attachmentsEl: d[0], attachmentsVisible: d.hasClass("messagebar-attachments-visible"), $sheetEl: u, sheetEl: u[0], sheetVisible: u.hasClass("messagebar-sheet-visible"), $pageEl: i, pageEl: i[0], $pageContentEl: o, pageContentEl: o, top: r.hasClass("messagebar-top") || a.params.top, attachments: [] }); function p() { a.params.resizePage && a.resizePage() } function m(v) { v.preventDefault() } function f(v) { const E = y(this).index(); y(v.target).closest(".messagebar-attachment-delete").length ? (y(this).trigger("messagebar:attachmentdelete", E), a.emit("local::attachmentDelete messagebarAttachmentDelete", a, this, E)) : (y(this).trigger("messagebar:attachmentclick", E), a.emit("local::attachmentClick messagebarAttachmentClick", a, this, E)) } function h() { a.checkEmptyState(), a.$el.trigger("messagebar:change"), a.emit("local::change messagebarChange", a) } function b() { a.sheetHide(), a.$el.addClass("messagebar-focused"), a.$el.trigger("messagebar:focus"), a.emit("local::focus messagebarFocus", a) } function g() { a.$el.removeClass("messagebar-focused"), a.$el.trigger("messagebar:blur"), a.emit("local::blur messagebarBlur", a) } return a.attachEvents = function () { r.on("textarea:resize", p), r.on("submit", m), r.on("click", ".messagebar-attachment", f), c.on("change input", h), c.on("focus", b), c.on("blur", g), e.on("resize", p) }, a.detachEvents = function () { r.off("textarea:resize", p), r.off("submit", m), r.off("click", ".messagebar-attachment", f), c.off("change input", h), c.off("focus", b), c.off("blur", g), e.off("resize", p) }, a.useModules(), a.init(), a } focus() { const e = this; return e.$textareaEl.focus(), e } blur() { const e = this; return e.$textareaEl.blur(), e } clear() { const e = this; return e.$textareaEl.val("").trigger("change"), e } getValue() { return this.$textareaEl.val().trim() } setValue(e) { const t = this; return t.$textareaEl.val(e).trigger("change"), t } setPlaceholder(e) { const t = this; return t.$textareaEl.attr("placeholder", e), t } resizePage() { const e = this, { params: t, $el: a, top: s, $pageEl: r, $pageContentEl: i, $areaEl: o, $textareaEl: l, $sheetEl: c, $attachmentsEl: d } = e, u = a[0].offsetHeight; let p = t.maxHeight; if (!s) { const m = parseInt(i.css("padding-bottom"), 10), f = u + t.bottomOffset; if (f !== m && i.length) { const h = parseInt(i.css("padding-top"), 10), b = i[0].scrollHeight, g = i[0].offsetHeight, E = i[0].scrollTop === b - g; p || (p = r[0].offsetHeight - h - c.outerHeight() - d.outerHeight() - parseInt(o.css("margin-top"), 10) - parseInt(o.css("margin-bottom"), 10)), l.css("max-height", `${p}px`), i.css("padding-bottom", `${f}px`), E && i.scrollTop(i[0].scrollHeight - g), a.trigger("messagebar:resizepage"), e.emit("local::resizePage messagebarResizePage", e) } } } checkEmptyState() { const e = this, { $el: t, $textareaEl: a } = e, s = a.val().trim(); s && s.length ? t.addClass("messagebar-with-value") : t.removeClass("messagebar-with-value") } attachmentsCreate(e) { e === void 0 && (e = ""); const t = this, a = y(`<div class="messagebar-attachments">${e}</div>`); return a.insertBefore(t.$textareaEl), R(t, { $attachmentsEl: a, attachmentsEl: a[0] }), t } attachmentsShow(e) { e === void 0 && (e = ""); const t = this; return t.$attachmentsEl = t.$el.find(".messagebar-attachments"), t.$attachmentsEl.length === 0 && t.attachmentsCreate(e), t.$el.addClass("messagebar-attachments-visible"), t.attachmentsVisible = !0, t.params.resizePage && t.resizePage(), t } attachmentsHide() { const e = this; return e.$el.removeClass("messagebar-attachments-visible"), e.attachmentsVisible = !1, e.params.resizePage && e.resizePage(), e } attachmentsToggle() { const e = this; return e.attachmentsVisible ? e.attachmentsHide() : e.attachmentsShow(), e } renderAttachment(e) {
    const t = this; return t.params.renderAttachment ? t.params.renderAttachment.call(t, e) : `
      <div class="messagebar-attachment">
        <img src="${e}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `} renderAttachments() { const e = this; let t; e.params.renderAttachments ? t = e.params.renderAttachments.call(e, e.attachments) : t = `${e.attachments.map(a => e.renderAttachment(a)).join("")}`, e.$attachmentsEl.length === 0 ? e.attachmentsCreate(t) : e.$attachmentsEl.html(t) } sheetCreate(e) { e === void 0 && (e = ""); const t = this, a = y(`<div class="messagebar-sheet">${e}</div>`); return t.$el.append(a), R(t, { $sheetEl: a, sheetEl: a[0] }), t } sheetShow(e) { e === void 0 && (e = ""); const t = this; return t.$sheetEl = t.$el.find(".messagebar-sheet"), t.$sheetEl.length === 0 && t.sheetCreate(e), t.$el.addClass("messagebar-sheet-visible"), t.sheetVisible = !0, t.params.resizePage && t.resizePage(), t } sheetHide() { const e = this; return e.$el.removeClass("messagebar-sheet-visible"), e.sheetVisible = !1, e.params.resizePage && e.resizePage(), e } sheetToggle() { const e = this; return e.sheetVisible ? e.sheetHide() : e.sheetShow(), e } init() { const e = this; return e.attachEvents(), e.checkEmptyState(), e } destroy() { const e = this; e.emit("local::beforeDestroy messagebarBeforeDestroy", e), e.$el.trigger("messagebar:beforedestroy"), e.detachEvents(), e.$el[0] && (e.$el[0].f7Messagebar = null, delete e.$el[0].f7Messagebar), ve(e) }
}; const hc = { name: "messagebar", static: { Messagebar: Fn }, create() { const n = this; n.messagebar = we({ defaultSelector: ".messagebar", constructor: Fn, app: n, domProp: "f7Messagebar", addMethods: "clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle".split(" ") }) }, on: { tabBeforeRemove(n) { const e = this; y(n).find(".messagebar-init").each(t => { e.messagebar.destroy(t) }) }, tabMounted(n) { const e = this; y(n).find(".messagebar-init").each(t => { e.messagebar.create(R({ el: t }, y(t).dataset())) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".messagebar-init").each(t => { e.messagebar.destroy(t) }) }, pageInit(n) { const e = this; n.$el.find(".messagebar-init").each(t => { e.messagebar.create(R({ el: t }, y(t).dataset())) }) } }, vnode: { "messagebar-init": { insert(n) { const e = this, t = n.elm; e.messagebar.create(R({ el: t }, y(t).dataset())) }, destroy(n) { const e = this, t = n.elm; e.messagebar.destroy(t) } } } }; function mc(n) { const e = n; Object.keys(e).forEach(t => { try { e[t] = null } catch { } try { delete e[t] } catch { } }) } function pt(n, e = 0) { return setTimeout(n, e) } function He() { return Date.now() } function gc(n) { const e = U(); let t; return e.getComputedStyle && (t = e.getComputedStyle(n, null)), !t && n.currentStyle && (t = n.currentStyle), t || (t = n.style), t } function Ra(n, e = "x") { const t = U(); let a, s, r; const i = gc(n, null); return t.WebKitCSSMatrix ? (s = i.transform || i.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(o => o.replace(",", ".")).join(", ")), r = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (r = i.MozTransform || i.OTransform || i.MsTransform || i.msTransform || i.transform || i.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = r.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? s = r.m41 : a.length === 16 ? s = parseFloat(a[12]) : s = parseFloat(a[4])), e === "y" && (t.WebKitCSSMatrix ? s = r.m42 : a.length === 16 ? s = parseFloat(a[13]) : s = parseFloat(a[5])), s || 0 } function At(n) { return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" } function vc(n) { return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11) } function De(...n) { const e = Object(n[0]), t = ["__proto__", "constructor", "prototype"]; for (let a = 1; a < n.length; a += 1) { const s = n[a]; if (s != null && !vc(s)) { const r = Object.keys(Object(s)).filter(i => t.indexOf(i) < 0); for (let i = 0, o = r.length; i < o; i += 1) { const l = r[i], c = Object.getOwnPropertyDescriptor(s, l); c !== void 0 && c.enumerable && (At(e[l]) && At(s[l]) ? s[l].__swiper__ ? e[l] = s[l] : De(e[l], s[l]) : !At(e[l]) && At(s[l]) ? (e[l] = {}, s[l].__swiper__ ? e[l] = s[l] : De(e[l], s[l])) : e[l] = s[l]) } } } return e } function It(n, e, t) { n.style.setProperty(e, t) } function Ls({ swiper: n, targetPosition: e, side: t }) { const a = U(), s = -n.translate; let r = null, i; const o = n.params.speed; n.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(n.cssModeFrameID); const l = e > s ? "next" : "prev", c = (u, p) => l === "next" && u >= p || l === "prev" && u <= p, d = () => { i = new Date().getTime(), r === null && (r = i); const u = Math.max(Math.min((i - r) / o, 1), 0), p = .5 - Math.cos(u * Math.PI) / 2; let m = s + p * (e - s); if (c(m, e) && (m = e), n.wrapperEl.scrollTo({ [t]: m }), c(m, e)) { n.wrapperEl.style.overflow = "hidden", n.wrapperEl.style.scrollSnapType = "", setTimeout(() => { n.wrapperEl.style.overflow = "", n.wrapperEl.scrollTo({ [t]: m }) }), a.cancelAnimationFrame(n.cssModeFrameID); return } n.cssModeFrameID = a.requestAnimationFrame(d) }; d() } function ft(n) { return n.querySelector(".swiper-slide-transform") || n.shadowEl && n.shadowEl.querySelector(".swiper-slide-transform") || n } function ke(n, e = "") { return [...n.children].filter(t => t.matches(e)) } function ze(n, e = []) { const t = document.createElement(n); return t.classList.add(...Array.isArray(e) ? e : [e]), t } function Jt(n) { const e = U(), t = ee(), a = n.getBoundingClientRect(), s = t.body, r = n.clientTop || s.clientTop || 0, i = n.clientLeft || s.clientLeft || 0, o = n === e ? e.scrollY : n.scrollTop, l = n === e ? e.scrollX : n.scrollLeft; return { top: a.top + o - r, left: a.left + l - i } } function bc(n, e) { const t = []; for (; n.previousElementSibling;) { const a = n.previousElementSibling; e ? a.matches(e) && t.push(a) : t.push(a), n = a } return t } function yc(n, e) { const t = []; for (; n.nextElementSibling;) { const a = n.nextElementSibling; e ? a.matches(e) && t.push(a) : t.push(a), n = a } return t } function st(n, e) { return U().getComputedStyle(n, null).getPropertyValue(e) } function Dt(n) { let e = n, t; if (e) { for (t = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (t += 1); return t } } function ut(n, e) { const t = []; let a = n.parentElement; for (; a;)e ? a.matches(e) && t.push(a) : t.push(a), a = a.parentElement; return t } function Ot(n, e) { function t(a) { a.target === n && (e.call(n, a), n.removeEventListener("transitionend", t)) } e && n.addEventListener("transitionend", t) } function Ha(n, e, t) { const a = U(); return t ? n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(a.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(a.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : n.offsetWidth } let wa; function Ec() { const n = U(), e = ee(); return { smoothScroll: e.documentElement && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch) } } function Rs() { return wa || (wa = Ec()), wa } let Ca; function wc({ userAgent: n } = {}) { const e = Rs(), t = U(), a = t.navigator.platform, s = n || t.navigator.userAgent, r = { ios: !1, android: !1 }, i = t.screen.width, o = t.screen.height, l = s.match(/(Android);?[\s\/]+([\d.]+)?/); let c = s.match(/(iPad).*OS\s([\d_]+)/); const d = s.match(/(iPod)(.*OS\s([\d_]+))?/), u = !c && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = a === "Win32"; let m = a === "MacIntel"; const f = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !c && m && e.touch && f.indexOf(`${i}x${o}`) >= 0 && (c = s.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), m = !1), l && !p && (r.os = "android", r.android = !0), (c || u || d) && (r.os = "ios", r.ios = !0), r } function Cc(n = {}) { return Ca || (Ca = wc(n)), Ca } let $a; function $c() { const n = U(); let e = !1; function t() { const a = n.navigator.userAgent.toLowerCase(); return a.indexOf("safari") >= 0 && a.indexOf("chrome") < 0 && a.indexOf("android") < 0 } if (t()) { const a = String(n.navigator.userAgent); if (a.includes("Version/")) { const [s, r] = a.split("Version/")[1].split(" ")[0].split(".").map(i => Number(i)); e = s < 16 || s === 16 && r < 2 } } return { isSafari: e || t(), needPerspectiveFix: e, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent) } } function xc() { return $a || ($a = $c()), $a } function kc({ swiper: n, on: e, emit: t }) { const a = U(); let s = null, r = null; const i = () => { !n || n.destroyed || !n.initialized || (t("beforeResize"), t("resize")) }, o = () => { !n || n.destroyed || !n.initialized || (s = new ResizeObserver(d => { r = a.requestAnimationFrame(() => { const { width: u, height: p } = n; let m = u, f = p; d.forEach(({ contentBoxSize: h, contentRect: b, target: g }) => { g && g !== n.el || (m = b ? b.width : (h[0] || h).inlineSize, f = b ? b.height : (h[0] || h).blockSize) }), (m !== u || f !== p) && i() }) }), s.observe(n.el)) }, l = () => { r && a.cancelAnimationFrame(r), s && s.unobserve && n.el && (s.unobserve(n.el), s = null) }, c = () => { !n || n.destroyed || !n.initialized || t("orientationchange") }; e("init", () => { if (n.params.resizeObserver && typeof a.ResizeObserver < "u") { o(); return } a.addEventListener("resize", i), a.addEventListener("orientationchange", c) }), e("destroy", () => { l(), a.removeEventListener("resize", i), a.removeEventListener("orientationchange", c) }) } function Tc({ swiper: n, extendParams: e, on: t, emit: a }) { const s = [], r = U(), i = (c, d = {}) => { const u = r.MutationObserver || r.WebkitMutationObserver, p = new u(m => { if (n.__preventObserver__) return; if (m.length === 1) { a("observerUpdate", m[0]); return } const f = function () { a("observerUpdate", m[0]) }; r.requestAnimationFrame ? r.requestAnimationFrame(f) : r.setTimeout(f, 0) }); p.observe(c, { attributes: typeof d.attributes > "u" ? !0 : d.attributes, childList: typeof d.childList > "u" ? !0 : d.childList, characterData: typeof d.characterData > "u" ? !0 : d.characterData }), s.push(p) }, o = () => { if (n.params.observer) { if (n.params.observeParents) { const c = ut(n.el); for (let d = 0; d < c.length; d += 1)i(c[d]) } i(n.el, { childList: n.params.observeSlideChildren }), i(n.wrapperEl, { attributes: !1 }) } }, l = () => { s.forEach(c => { c.disconnect() }), s.splice(0, s.length) }; e({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), t("init", o), t("destroy", l) } const Sc = { on(n, e, t) { const a = this; if (!a.eventsListeners || a.destroyed || typeof e != "function") return a; const s = t ? "unshift" : "push"; return n.split(" ").forEach(r => { a.eventsListeners[r] || (a.eventsListeners[r] = []), a.eventsListeners[r][s](e) }), a }, once(n, e, t) { const a = this; if (!a.eventsListeners || a.destroyed || typeof e != "function") return a; function s(...r) { a.off(n, s), s.__emitterProxy && delete s.__emitterProxy, e.apply(a, r) } return s.__emitterProxy = e, a.on(n, s, t) }, onAny(n, e) { const t = this; if (!t.eventsListeners || t.destroyed || typeof n != "function") return t; const a = e ? "unshift" : "push"; return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[a](n), t }, offAny(n) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e; const t = e.eventsAnyListeners.indexOf(n); return t >= 0 && e.eventsAnyListeners.splice(t, 1), e }, off(n, e) { const t = this; return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach(a => { typeof e > "u" ? t.eventsListeners[a] = [] : t.eventsListeners[a] && t.eventsListeners[a].forEach((s, r) => { (s === e || s.__emitterProxy && s.__emitterProxy === e) && t.eventsListeners[a].splice(r, 1) }) }), t }, emit(...n) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsListeners) return e; let t, a, s; return typeof n[0] == "string" || Array.isArray(n[0]) ? (t = n[0], a = n.slice(1, n.length), s = e) : (t = n[0].events, a = n[0].data, s = n[0].context || e), a.unshift(s), (Array.isArray(t) ? t : t.split(" ")).forEach(i => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(o => { o.apply(s, [i, ...a]) }), e.eventsListeners && e.eventsListeners[i] && e.eventsListeners[i].forEach(o => { o.apply(s, a) }) }), e } }; function Mc() { const n = this; let e, t; const a = n.el; typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = a.clientWidth, typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = a.clientHeight, !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(st(a, "padding-left") || 0, 10) - parseInt(st(a, "padding-right") || 0, 10), t = t - parseInt(st(a, "padding-top") || 0, 10) - parseInt(st(a, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, { width: e, height: t, size: n.isHorizontal() ? e : t })) } function Pc() { const n = this; function e(S) { return n.isHorizontal() ? S : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[S] } function t(S, P) { return parseFloat(S.getPropertyValue(e(P)) || 0) } const a = n.params, { wrapperEl: s, slidesEl: r, size: i, rtlTranslate: o, wrongRTL: l } = n, c = n.virtual && a.virtual.enabled, d = c ? n.virtual.slides.length : n.slides.length, u = ke(r, `.${n.params.slideClass}, swiper-slide`), p = c ? n.virtual.slides.length : u.length; let m = []; const f = [], h = []; let b = a.slidesOffsetBefore; typeof b == "function" && (b = a.slidesOffsetBefore.call(n)); let g = a.slidesOffsetAfter; typeof g == "function" && (g = a.slidesOffsetAfter.call(n)); const v = n.snapGrid.length, E = n.slidesGrid.length; let $ = a.spaceBetween, w = -b, C = 0, k = 0; if (typeof i > "u") return; typeof $ == "string" && $.indexOf("%") >= 0 && ($ = parseFloat($.replace("%", "")) / 100 * i), n.virtualSize = -$, u.forEach(S => { o ? S.style.marginLeft = "" : S.style.marginRight = "", S.style.marginBottom = "", S.style.marginTop = "" }), a.centeredSlides && a.cssMode && (It(s, "--swiper-centered-offset-before", ""), It(s, "--swiper-centered-offset-after", "")); const M = a.grid && a.grid.rows > 1 && n.grid; M && n.grid.initSlides(p); let A; const O = a.slidesPerView === "auto" && a.breakpoints && Object.keys(a.breakpoints).filter(S => typeof a.breakpoints[S].slidesPerView < "u").length > 0; for (let S = 0; S < p; S += 1) { A = 0; let P; if (u[S] && (P = u[S]), M && n.grid.updateSlide(S, P, p, e), !(u[S] && st(P, "display") === "none")) { if (a.slidesPerView === "auto") { O && (u[S].style[e("width")] = ""); const T = getComputedStyle(P), I = P.style.transform, H = P.style.webkitTransform; if (I && (P.style.transform = "none"), H && (P.style.webkitTransform = "none"), a.roundLengths) A = n.isHorizontal() ? Ha(P, "width", !0) : Ha(P, "height", !0); else { const D = t(T, "width"), z = t(T, "padding-left"), B = t(T, "padding-right"), L = t(T, "margin-left"), N = t(T, "margin-right"), F = T.getPropertyValue("box-sizing"); if (F && F === "border-box") A = D + L + N; else { const { clientWidth: V, offsetWidth: _ } = P; A = D + z + B + L + N + (_ - V) } } I && (P.style.transform = I), H && (P.style.webkitTransform = H), a.roundLengths && (A = Math.floor(A)) } else A = (i - (a.slidesPerView - 1) * $) / a.slidesPerView, a.roundLengths && (A = Math.floor(A)), u[S] && (u[S].style[e("width")] = `${A}px`); u[S] && (u[S].swiperSlideSize = A), h.push(A), a.centeredSlides ? (w = w + A / 2 + C / 2 + $, C === 0 && S !== 0 && (w = w - i / 2 - $), S === 0 && (w = w - i / 2 - $), Math.abs(w) < 1 / 1e3 && (w = 0), a.roundLengths && (w = Math.floor(w)), k % a.slidesPerGroup === 0 && m.push(w), f.push(w)) : (a.roundLengths && (w = Math.floor(w)), (k - Math.min(n.params.slidesPerGroupSkip, k)) % n.params.slidesPerGroup === 0 && m.push(w), f.push(w), w = w + A + $), n.virtualSize += A + $, C = A, k += 1 } } if (n.virtualSize = Math.max(n.virtualSize, i) + g, o && l && (a.effect === "slide" || a.effect === "coverflow") && (s.style.width = `${n.virtualSize + a.spaceBetween}px`), a.setWrapperSize && (s.style[e("width")] = `${n.virtualSize + a.spaceBetween}px`), M && n.grid.updateWrapperSize(A, m, e), !a.centeredSlides) { const S = []; for (let P = 0; P < m.length; P += 1) { let T = m[P]; a.roundLengths && (T = Math.floor(T)), m[P] <= n.virtualSize - i && S.push(T) } m = S, Math.floor(n.virtualSize - i) - Math.floor(m[m.length - 1]) > 1 && m.push(n.virtualSize - i) } if (c && a.loop) { const S = h[0] + $; if (a.slidesPerGroup > 1) { const P = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / a.slidesPerGroup), T = S * a.slidesPerGroup; for (let I = 0; I < P; I += 1)m.push(m[m.length - 1] + T) } for (let P = 0; P < n.virtual.slidesBefore + n.virtual.slidesAfter; P += 1)a.slidesPerGroup === 1 && m.push(m[m.length - 1] + S), f.push(f[f.length - 1] + S), n.virtualSize += S } if (m.length === 0 && (m = [0]), a.spaceBetween !== 0) { const S = n.isHorizontal() && o ? "marginLeft" : e("marginRight"); u.filter((P, T) => !a.cssMode || a.loop ? !0 : T !== u.length - 1).forEach(P => { P.style[S] = `${$}px` }) } if (a.centeredSlides && a.centeredSlidesBounds) { let S = 0; h.forEach(T => { S += T + (a.spaceBetween ? a.spaceBetween : 0) }), S -= a.spaceBetween; const P = S - i; m = m.map(T => T < 0 ? -b : T > P ? P + g : T) } if (a.centerInsufficientSlides) { let S = 0; if (h.forEach(P => { S += P + (a.spaceBetween ? a.spaceBetween : 0) }), S -= a.spaceBetween, S < i) { const P = (i - S) / 2; m.forEach((T, I) => { m[I] = T - P }), f.forEach((T, I) => { f[I] = T + P }) } } if (Object.assign(n, { slides: u, snapGrid: m, slidesGrid: f, slidesSizesGrid: h }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) { It(s, "--swiper-centered-offset-before", `${-m[0]}px`), It(s, "--swiper-centered-offset-after", `${n.size / 2 - h[h.length - 1] / 2}px`); const S = -n.snapGrid[0], P = -n.slidesGrid[0]; n.snapGrid = n.snapGrid.map(T => T + S), n.slidesGrid = n.slidesGrid.map(T => T + P) } if (p !== d && n.emit("slidesLengthChange"), m.length !== v && (n.params.watchOverflow && n.checkOverflow(), n.emit("snapGridLengthChange")), f.length !== E && n.emit("slidesGridLengthChange"), a.watchSlidesProgress && n.updateSlidesOffset(), !c && !a.cssMode && (a.effect === "slide" || a.effect === "fade")) { const S = `${a.containerModifierClass}backface-hidden`, P = n.el.classList.contains(S); p <= a.maxBackfaceHiddenSlides ? P || n.el.classList.add(S) : P && n.el.classList.remove(S) } } function Ac(n) { const e = this, t = [], a = e.virtual && e.params.virtual.enabled; let s = 0, r; typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed); const i = o => a ? e.slides[e.getSlideIndexByData(o)] : e.slides[o]; if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides) (e.visibleSlides || []).forEach(o => { t.push(o) }); else for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) { const o = e.activeIndex + r; if (o > e.slides.length && !a) break; t.push(i(o)) } else t.push(i(e.activeIndex)); for (r = 0; r < t.length; r += 1)if (typeof t[r] < "u") { const o = t[r].offsetHeight; s = o > s ? o : s } (s || s === 0) && (e.wrapperEl.style.height = `${s}px`) } function Ic() { const n = this, e = n.slides, t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0; for (let a = 0; a < e.length; a += 1)e[a].swiperSlideOffset = (n.isHorizontal() ? e[a].offsetLeft : e[a].offsetTop) - t - n.cssOverflowAdjustment() } function Oc(n = this && this.translate || 0) { const e = this, t = e.params, { slides: a, rtlTranslate: s, snapGrid: r } = e; if (a.length === 0) return; typeof a[0].swiperSlideOffset > "u" && e.updateSlidesOffset(); let i = -n; s && (i = n), a.forEach(o => { o.classList.remove(t.slideVisibleClass) }), e.visibleSlidesIndexes = [], e.visibleSlides = []; for (let o = 0; o < a.length; o += 1) { const l = a[o]; let c = l.swiperSlideOffset; t.cssMode && t.centeredSlides && (c -= a[0].swiperSlideOffset); const d = (i + (t.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + t.spaceBetween), u = (i - r[0] + (t.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + t.spaceBetween), p = -(i - c), m = p + e.slidesSizesGrid[o]; (p >= 0 && p < e.size - 1 || m > 1 && m <= e.size || p <= 0 && m >= e.size) && (e.visibleSlides.push(l), e.visibleSlidesIndexes.push(o), a[o].classList.add(t.slideVisibleClass)), l.progress = s ? -d : d, l.originalProgress = s ? -u : u } } function Bc(n) { const e = this; if (typeof n > "u") { const d = e.rtlTranslate ? -1 : 1; n = e && e.translate && e.translate * d || 0 } const t = e.params, a = e.maxTranslate() - e.minTranslate(); let { progress: s, isBeginning: r, isEnd: i, progressLoop: o } = e; const l = r, c = i; if (a === 0) s = 0, r = !0, i = !0; else { s = (n - e.minTranslate()) / a; const d = Math.abs(n - e.minTranslate()) < 1, u = Math.abs(n - e.maxTranslate()) < 1; r = d || s <= 0, i = u || s >= 1, d && (s = 0), u && (s = 1) } if (t.loop) { const d = e.getSlideIndexByData(0), u = e.getSlideIndexByData(e.slides.length - 1), p = e.slidesGrid[d], m = e.slidesGrid[u], f = e.slidesGrid[e.slidesGrid.length - 1], h = Math.abs(n); h >= p ? o = (h - p) / f : o = (h + f - m) / f, o > 1 && (o -= 1) } Object.assign(e, { progress: s, progressLoop: o, isBeginning: r, isEnd: i }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n), r && !l && e.emit("reachBeginning toEdge"), i && !c && e.emit("reachEnd toEdge"), (l && !r || c && !i) && e.emit("fromEdge"), e.emit("progress", s) } function Dc() { const n = this, { slides: e, params: t, slidesEl: a, activeIndex: s } = n, r = n.virtual && t.virtual.enabled, i = l => ke(a, `.${t.slideClass}${l}, swiper-slide${l}`)[0]; e.forEach(l => { l.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass) }); let o; if (r) if (t.loop) { let l = s - n.virtual.slidesBefore; l < 0 && (l = n.virtual.slides.length + l), l >= n.virtual.slides.length && (l -= n.virtual.slides.length), o = i(`[data-swiper-slide-index="${l}"]`) } else o = i(`[data-swiper-slide-index="${s}"]`); else o = e[s]; if (o) { o.classList.add(t.slideActiveClass); let l = yc(o, `.${t.slideClass}, swiper-slide`)[0]; t.loop && !l && (l = e[0]), l && l.classList.add(t.slideNextClass); let c = bc(o, `.${t.slideClass}, swiper-slide`)[0]; t.loop && !c === 0 && (c = e[e.length - 1]), c && c.classList.add(t.slidePrevClass) } n.emitSlidesClasses() } const Wt = (n, e) => { if (!n || n.destroyed || !n.params) return; const t = () => n.isElement ? "swiper-slide" : `.${n.params.slideClass}`, a = e.closest(t()); if (a) { const s = a.querySelector(`.${n.params.lazyPreloaderClass}`); s && s.remove() } }, Vn = (n, e) => { if (!n.slides[e]) return; const t = n.slides[e].querySelector('[loading="lazy"]'); t && t.removeAttribute("loading") }, za = n => { if (!n || n.destroyed || !n.params) return; let e = n.params.lazyPreloadPrevNext; const t = n.slides.length; if (!t || !e || e < 0) return; e = Math.min(e, t); const a = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(n.params.slidesPerView), s = n.activeIndex, r = s + a - 1; if (n.params.rewind) for (let i = s - e; i <= r + e; i += 1) { const o = (i % t + t) % t; o !== s && o > r && Vn(n, o) } else for (let i = Math.max(r - e, 0); i <= Math.min(r + e, t - 1); i += 1)i !== s && i > r && Vn(n, i) }; function Lc(n) { const { slidesGrid: e, params: t } = n, a = n.rtlTranslate ? n.translate : -n.translate; let s; for (let r = 0; r < e.length; r += 1)typeof e[r + 1] < "u" ? a >= e[r] && a < e[r + 1] - (e[r + 1] - e[r]) / 2 ? s = r : a >= e[r] && a < e[r + 1] && (s = r + 1) : a >= e[r] && (s = r); return t.normalizeSlideIndex && (s < 0 || typeof s > "u") && (s = 0), s } function Rc(n) { const e = this, t = e.rtlTranslate ? e.translate : -e.translate, { snapGrid: a, params: s, activeIndex: r, realIndex: i, snapIndex: o } = e; let l = n, c; const d = p => { let m = p - e.virtual.slidesBefore; return m < 0 && (m = e.virtual.slides.length + m), m >= e.virtual.slides.length && (m -= e.virtual.slides.length), m }; if (typeof l > "u" && (l = Lc(e)), a.indexOf(t) >= 0) c = a.indexOf(t); else { const p = Math.min(s.slidesPerGroupSkip, l); c = p + Math.floor((l - p) / s.slidesPerGroup) } if (c >= a.length && (c = a.length - 1), l === r) { c !== o && (e.snapIndex = c, e.emit("snapIndexChange")), e.params.loop && e.virtual && e.params.virtual.enabled && (e.realIndex = d(l)); return } let u; e.virtual && s.virtual.enabled && s.loop ? u = d(l) : e.slides[l] ? u = parseInt(e.slides[l].getAttribute("data-swiper-slide-index") || l, 10) : u = l, Object.assign(e, { previousSnapIndex: o, snapIndex: c, previousRealIndex: i, realIndex: u, previousIndex: r, activeIndex: l }), e.initialized && za(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), i !== u && e.emit("realIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange") } function Hc(n) { const e = this, t = e.params, a = n.closest(`.${t.slideClass}, swiper-slide`); let s = !1, r; if (a) { for (let i = 0; i < e.slides.length; i += 1)if (e.slides[i] === a) { s = !0, r = i; break } } if (a && s) e.clickedSlide = a, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(a.getAttribute("data-swiper-slide-index"), 10) : e.clickedIndex = r; else { e.clickedSlide = void 0, e.clickedIndex = void 0; return } t.slideToClickedSlide && e.clickedIndex !== void 0 && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide() } const zc = { updateSize: Mc, updateSlides: Pc, updateAutoHeight: Ac, updateSlidesOffset: Ic, updateSlidesProgress: Oc, updateProgress: Bc, updateSlidesClasses: Dc, updateActiveIndex: Rc, updateClickedSlide: Hc }; function Fc(n = this.isHorizontal() ? "x" : "y") { const e = this, { params: t, rtlTranslate: a, translate: s, wrapperEl: r } = e; if (t.virtualTranslate) return a ? -s : s; if (t.cssMode) return s; let i = Ra(r, n); return i += e.cssOverflowAdjustment(), a && (i = -i), i || 0 } function Vc(n, e) { const t = this, { rtlTranslate: a, params: s, wrapperEl: r, progress: i } = t; let o = 0, l = 0; const c = 0; t.isHorizontal() ? o = a ? -n : n : l = n, s.roundLengths && (o = Math.floor(o), l = Math.floor(l)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? o : l, s.cssMode ? r[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -o : -l : s.virtualTranslate || (t.isHorizontal() ? o -= t.cssOverflowAdjustment() : l -= t.cssOverflowAdjustment(), r.style.transform = `translate3d(${o}px, ${l}px, ${c}px)`); let d; const u = t.maxTranslate() - t.minTranslate(); u === 0 ? d = 0 : d = (n - t.minTranslate()) / u, d !== i && t.updateProgress(n), t.emit("setTranslate", t.translate, e) } function Nc() { return -this.snapGrid[0] } function Yc() { return -this.snapGrid[this.snapGrid.length - 1] } function qc(n = 0, e = this.params.speed, t = !0, a = !0, s) { const r = this, { params: i, wrapperEl: o } = r; if (r.animating && i.preventInteractionOnTransition) return !1; const l = r.minTranslate(), c = r.maxTranslate(); let d; if (a && n > l ? d = l : a && n < c ? d = c : d = n, r.updateProgress(d), i.cssMode) { const u = r.isHorizontal(); if (e === 0) o[u ? "scrollLeft" : "scrollTop"] = -d; else { if (!r.support.smoothScroll) return Ls({ swiper: r, targetPosition: -d, side: u ? "left" : "top" }), !0; o.scrollTo({ [u ? "left" : "top"]: -d, behavior: "smooth" }) } return !0 } return e === 0 ? (r.setTransition(0), r.setTranslate(d), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionEnd"))) : (r.setTransition(e), r.setTranslate(d), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (p) { !r || r.destroyed || p.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, t && r.emit("transitionEnd")) }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0 } const jc = { getTranslate: Fc, setTranslate: Vc, minTranslate: Nc, maxTranslate: Yc, translateTo: qc }; function Wc(n, e) { const t = this; t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`), t.emit("setTransition", n, e) } function Hs({ swiper: n, runCallbacks: e, direction: t, step: a }) { const { activeIndex: s, previousIndex: r } = n; let i = t; if (i || (s > r ? i = "next" : s < r ? i = "prev" : i = "reset"), n.emit(`transition${a}`), e && s !== r) { if (i === "reset") { n.emit(`slideResetTransition${a}`); return } n.emit(`slideChangeTransition${a}`), i === "next" ? n.emit(`slideNextTransition${a}`) : n.emit(`slidePrevTransition${a}`) } } function Xc(n = !0, e) { const t = this, { params: a } = t; a.cssMode || (a.autoHeight && t.updateAutoHeight(), Hs({ swiper: t, runCallbacks: n, direction: e, step: "Start" })) } function Gc(n = !0, e) { const t = this, { params: a } = t; t.animating = !1, !a.cssMode && (t.setTransition(0), Hs({ swiper: t, runCallbacks: n, direction: e, step: "End" })) } const Uc = { setTransition: Wc, transitionStart: Xc, transitionEnd: Gc }; function _c(n = 0, e = this.params.speed, t = !0, a, s) { typeof n == "string" && (n = parseInt(n, 10)); const r = this; let i = n; i < 0 && (i = 0); const { params: o, snapGrid: l, slidesGrid: c, previousIndex: d, activeIndex: u, rtlTranslate: p, wrapperEl: m, enabled: f } = r; if (r.animating && o.preventInteractionOnTransition || !f && !a && !s) return !1; const h = Math.min(r.params.slidesPerGroupSkip, i); let b = h + Math.floor((i - h) / r.params.slidesPerGroup); b >= l.length && (b = l.length - 1); const g = -l[b]; if (o.normalizeSlideIndex) for (let E = 0; E < c.length; E += 1) { const $ = -Math.floor(g * 100), w = Math.floor(c[E] * 100), C = Math.floor(c[E + 1] * 100); typeof c[E + 1] < "u" ? $ >= w && $ < C - (C - w) / 2 ? i = E : $ >= w && $ < C && (i = E + 1) : $ >= w && (i = E) } if (r.initialized && i !== u && (!r.allowSlideNext && g < r.translate && g < r.minTranslate() || !r.allowSlidePrev && g > r.translate && g > r.maxTranslate() && (u || 0) !== i)) return !1; i !== (d || 0) && t && r.emit("beforeSlideChangeStart"), r.updateProgress(g); let v; if (i > u ? v = "next" : i < u ? v = "prev" : v = "reset", p && -g === r.translate || !p && g === r.translate) return r.updateActiveIndex(i), o.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), o.effect !== "slide" && r.setTranslate(g), v !== "reset" && (r.transitionStart(t, v), r.transitionEnd(t, v)), !1; if (o.cssMode) { const E = r.isHorizontal(), $ = p ? g : -g; if (e === 0) { const w = r.virtual && r.params.virtual.enabled; w && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), w && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { m[E ? "scrollLeft" : "scrollTop"] = $ })) : m[E ? "scrollLeft" : "scrollTop"] = $, w && requestAnimationFrame(() => { r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1 }) } else { if (!r.support.smoothScroll) return Ls({ swiper: r, targetPosition: $, side: E ? "left" : "top" }), !0; m.scrollTo({ [E ? "left" : "top"]: $, behavior: "smooth" }) } return !0 } return r.setTransition(e), r.setTranslate(g), r.updateActiveIndex(i), r.updateSlidesClasses(), r.emit("beforeTransitionStart", e, a), r.transitionStart(t, v), e === 0 ? r.transitionEnd(t, v) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function ($) { !r || r.destroyed || $.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(t, v)) }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0 } function Kc(n = 0, e = this.params.speed, t = !0, a) { typeof n == "string" && (n = parseInt(n, 10)); const s = this; let r = n; return s.params.loop && (s.virtual && s.params.virtual.enabled ? r = r + s.virtual.slidesBefore : r = s.getSlideIndexByData(r)), s.slideTo(r, e, t, a) } function Qc(n = this.params.speed, e = !0, t) { const a = this, { enabled: s, params: r, animating: i } = a; if (!s) return a; let o = r.slidesPerGroup; r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (o = Math.max(a.slidesPerViewDynamic("current", !0), 1)); const l = a.activeIndex < r.slidesPerGroupSkip ? 1 : o, c = a.virtual && r.virtual.enabled; if (r.loop) { if (i && !c && r.loopPreventsSliding) return !1; a.loopFix({ direction: "next" }), a._clientLeft = a.wrapperEl.clientLeft } return r.rewind && a.isEnd ? a.slideTo(0, n, e, t) : a.slideTo(a.activeIndex + l, n, e, t) } function Zc(n = this.params.speed, e = !0, t) { const a = this, { params: s, snapGrid: r, slidesGrid: i, rtlTranslate: o, enabled: l, animating: c } = a; if (!l) return a; const d = a.virtual && s.virtual.enabled; if (s.loop) { if (c && !d && s.loopPreventsSliding) return !1; a.loopFix({ direction: "prev" }), a._clientLeft = a.wrapperEl.clientLeft } const u = o ? a.translate : -a.translate; function p(g) { return g < 0 ? -Math.floor(Math.abs(g)) : Math.floor(g) } const m = p(u), f = r.map(g => p(g)); let h = r[f.indexOf(m) - 1]; if (typeof h > "u" && s.cssMode) { let g; r.forEach((v, E) => { m >= v && (g = E) }), typeof g < "u" && (h = r[g > 0 ? g - 1 : g]) } let b = 0; if (typeof h < "u" && (b = i.indexOf(h), b < 0 && (b = a.activeIndex - 1), s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (b = b - a.slidesPerViewDynamic("previous", !0) + 1, b = Math.max(b, 0))), s.rewind && a.isBeginning) { const g = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1; return a.slideTo(g, n, e, t) } return a.slideTo(b, n, e, t) } function Jc(n = this.params.speed, e = !0, t) { const a = this; return a.slideTo(a.activeIndex, n, e, t) } function ed(n = this.params.speed, e = !0, t, a = .5) { const s = this; let r = s.activeIndex; const i = Math.min(s.params.slidesPerGroupSkip, r), o = i + Math.floor((r - i) / s.params.slidesPerGroup), l = s.rtlTranslate ? s.translate : -s.translate; if (l >= s.snapGrid[o]) { const c = s.snapGrid[o], d = s.snapGrid[o + 1]; l - c > (d - c) * a && (r += s.params.slidesPerGroup) } else { const c = s.snapGrid[o - 1], d = s.snapGrid[o]; l - c <= (d - c) * a && (r -= s.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, n, e, t) } function td() { const n = this, { params: e, slidesEl: t } = n, a = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView; let s = n.clickedIndex, r; const i = n.isElement ? "swiper-slide" : `.${e.slideClass}`; if (e.loop) { if (n.animating) return; r = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? s < n.loopedSlides - a / 2 || s > n.slides.length - n.loopedSlides + a / 2 ? (n.loopFix(), s = n.getSlideIndex(ke(t, `${i}[data-swiper-slide-index="${r}"]`)[0]), pt(() => { n.slideTo(s) })) : n.slideTo(s) : s > n.slides.length - a ? (n.loopFix(), s = n.getSlideIndex(ke(t, `${i}[data-swiper-slide-index="${r}"]`)[0]), pt(() => { n.slideTo(s) })) : n.slideTo(s) } else n.slideTo(s) } const ad = { slideTo: _c, slideToLoop: Kc, slideNext: Qc, slidePrev: Zc, slideReset: Jc, slideToClosest: ed, slideToClickedSlide: td }; function nd(n) { const e = this, { params: t, slidesEl: a } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; ke(a, `.${t.slideClass}, swiper-slide`).forEach((r, i) => { r.setAttribute("data-swiper-slide-index", i) }), e.loopFix({ slideRealIndex: n, direction: t.centeredSlides ? void 0 : "next" }) } function sd({ slideRealIndex: n, slideTo: e = !0, direction: t, setTranslate: a, activeSlideIndex: s, byController: r, byMousewheel: i } = {}) { const o = this; if (!o.params.loop) return; o.emit("beforeLoopFix"); const { slides: l, allowSlidePrev: c, allowSlideNext: d, slidesEl: u, params: p } = o; if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && p.virtual.enabled) { e && (!p.centeredSlides && o.snapIndex === 0 ? o.slideTo(o.virtual.slides.length, 0, !1, !0) : p.centeredSlides && o.snapIndex < p.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = d, o.emit("loopFix"); return } const m = p.slidesPerView === "auto" ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(p.slidesPerView, 10)); let f = p.loopedSlides || m; f % p.slidesPerGroup !== 0 && (f += p.slidesPerGroup - f % p.slidesPerGroup), o.loopedSlides = f; const h = [], b = []; let g = o.activeIndex; typeof s > "u" ? s = o.getSlideIndex(o.slides.filter(C => C.classList.contains(p.slideActiveClass))[0]) : g = s; const v = t === "next" || !t, E = t === "prev" || !t; let $ = 0, w = 0; if (s < f) { $ = Math.max(f - s, p.slidesPerGroup); for (let C = 0; C < f - s; C += 1) { const k = C - Math.floor(C / l.length) * l.length; h.push(l.length - k - 1) } } else if (s > o.slides.length - f * 2) { w = Math.max(s - (o.slides.length - f * 2), p.slidesPerGroup); for (let C = 0; C < w; C += 1) { const k = C - Math.floor(C / l.length) * l.length; b.push(k) } } if (E && h.forEach(C => { u.prepend(o.slides[C]) }), v && b.forEach(C => { u.append(o.slides[C]) }), o.recalcSlides(), p.slidesPerView === "auto" && o.updateSlides(), p.watchSlidesProgress && o.updateSlidesOffset(), e) { if (h.length > 0 && E) if (typeof n > "u") { const C = o.slidesGrid[g], M = o.slidesGrid[g + $] - C; i ? o.setTranslate(o.translate - M) : (o.slideTo(g + $, 0, !1, !0), a && (o.touches[o.isHorizontal() ? "startX" : "startY"] += M)) } else a && o.slideToLoop(n, 0, !1, !0); else if (b.length > 0 && v) if (typeof n > "u") { const C = o.slidesGrid[g], M = o.slidesGrid[g - w] - C; i ? o.setTranslate(o.translate - M) : (o.slideTo(g - w, 0, !1, !0), a && (o.touches[o.isHorizontal() ? "startX" : "startY"] += M)) } else o.slideToLoop(n, 0, !1, !0) } if (o.allowSlidePrev = c, o.allowSlideNext = d, o.controller && o.controller.control && !r) { const C = { slideRealIndex: n, slideTo: !1, direction: t, setTranslate: a, activeSlideIndex: s, byController: !0 }; Array.isArray(o.controller.control) ? o.controller.control.forEach(k => { !k.destroyed && k.params.loop && k.loopFix(C) }) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix(C) } o.emit("loopFix") } function rd() { const n = this, { params: e, slidesEl: t } = n; if (!e.loop || n.virtual && n.params.virtual.enabled) return; n.recalcSlides(); const a = []; n.slides.forEach(s => { const r = typeof s.swiperSlideIndex > "u" ? s.getAttribute("data-swiper-slide-index") * 1 : s.swiperSlideIndex; a[r] = s }), n.slides.forEach(s => { s.removeAttribute("data-swiper-slide-index") }), a.forEach(s => { t.append(s) }), n.recalcSlides(), n.slideTo(n.realIndex, 0) } const id = { loopCreate: nd, loopFix: sd, loopDestroy: rd }; function od(n) { const e = this; if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = n ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 }) } function ld() { const n = this; n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0), n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", n.isElement && requestAnimationFrame(() => { n.__preventObserver__ = !1 })) } const cd = { setGrabCursor: od, unsetGrabCursor: ld }; function dd(n, e = this) { function t(a) { if (!a || a === ee() || a === U()) return null; a.assignedSlot && (a = a.assignedSlot); const s = a.closest(n); return !s && !a.getRootNode ? null : s || t(a.getRootNode().host) } return t(e) } function ud(n) { const e = this, t = ee(), a = U(), s = e.touchEventsData; s.evCache.push(n); const { params: r, touches: i, enabled: o } = e; if (!o || !r.simulateTouch && n.pointerType === "mouse" || e.animating && r.preventInteractionOnTransition) return; !e.animating && r.cssMode && r.loop && e.loopFix(); let l = n; l.originalEvent && (l = l.originalEvent); let c = l.target; if (r.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(c) || "which" in l && l.which === 3 || "button" in l && l.button > 0 || s.isTouched && s.isMoved) return; const d = !!r.noSwipingClass && r.noSwipingClass !== "", u = n.composedPath ? n.composedPath() : n.path; d && l.target && l.target.shadowRoot && u && (c = u[0]); const p = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, m = !!(l.target && l.target.shadowRoot); if (r.noSwiping && (m ? dd(p, c) : c.closest(p))) { e.allowClick = !0; return } if (r.swipeHandler && !c.closest(r.swipeHandler)) return; i.currentX = l.pageX, i.currentY = l.pageY; const f = i.currentX, h = i.currentY, b = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection, g = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (b && (f <= g || f >= a.innerWidth - g)) if (b === "prevent") n.preventDefault(); else return; Object.assign(s, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), i.startX = f, i.startY = h, s.touchStartTime = He(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1); let v = !0; c.matches(s.focusableElements) && (v = !1, c.nodeName === "SELECT" && (s.isTouched = !1)), t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== c && t.activeElement.blur(); const E = v && e.allowTouchMove && r.touchStartPreventDefault; (r.touchStartForcePreventDefault || E) && !c.isContentEditable && l.preventDefault(), e.params.freeMode && e.params.freeMode.enabled && e.freeMode && e.animating && !r.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", l) } function pd(n) { const e = ee(), t = this, a = t.touchEventsData, { params: s, touches: r, rtlTranslate: i, enabled: o } = t; if (!o || !s.simulateTouch && n.pointerType === "mouse") return; let l = n; if (l.originalEvent && (l = l.originalEvent), !a.isTouched) { a.startMoving && a.isScrolling && t.emit("touchMoveOpposite", l); return } const c = a.evCache.findIndex(C => C.pointerId === l.pointerId); c >= 0 && (a.evCache[c] = l); const d = a.evCache.length > 1 ? a.evCache[0] : l, u = d.pageX, p = d.pageY; if (l.preventedByNestedSwiper) { r.startX = u, r.startY = p; return } if (!t.allowTouchMove) { l.target.matches(a.focusableElements) || (t.allowClick = !1), a.isTouched && (Object.assign(r, { startX: u, startY: p, prevX: t.touches.currentX, prevY: t.touches.currentY, currentX: u, currentY: p }), a.touchStartTime = He()); return } if (s.touchReleaseOnEdges && !s.loop) { if (t.isVertical()) { if (p < r.startY && t.translate <= t.maxTranslate() || p > r.startY && t.translate >= t.minTranslate()) { a.isTouched = !1, a.isMoved = !1; return } } else if (u < r.startX && t.translate <= t.maxTranslate() || u > r.startX && t.translate >= t.minTranslate()) return } if (e.activeElement && l.target === e.activeElement && l.target.matches(a.focusableElements)) { a.isMoved = !0, t.allowClick = !1; return } if (a.allowTouchCallbacks && t.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; r.currentX = u, r.currentY = p; const m = r.currentX - r.startX, f = r.currentY - r.startY; if (t.params.threshold && Math.sqrt(m ** 2 + f ** 2) < t.params.threshold) return; if (typeof a.isScrolling > "u") { let C; t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? a.isScrolling = !1 : m * m + f * f >= 25 && (C = Math.atan2(Math.abs(f), Math.abs(m)) * 180 / Math.PI, a.isScrolling = t.isHorizontal() ? C > s.touchAngle : 90 - C > s.touchAngle) } if (a.isScrolling && t.emit("touchMoveOpposite", l), typeof a.startMoving > "u" && (r.currentX !== r.startX || r.currentY !== r.startY) && (a.startMoving = !0), a.isScrolling || t.zoom && t.params.zoom && t.params.zoom.enabled && a.evCache.length > 1) { a.isTouched = !1; return } if (!a.startMoving) return; t.allowClick = !1, !s.cssMode && l.cancelable && l.preventDefault(), s.touchMoveStopPropagation && !s.nested && l.stopPropagation(); let h = t.isHorizontal() ? m : f, b = t.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY; s.oneWayMovement && (h = Math.abs(h) * (i ? 1 : -1), b = Math.abs(b) * (i ? 1 : -1)), r.diff = h, h *= s.touchRatio, i && (h = -h, b = -b); const g = t.touchesDirection; t.swipeDirection = h > 0 ? "prev" : "next", t.touchesDirection = b > 0 ? "prev" : "next"; const v = t.params.loop && !s.cssMode; if (!a.isMoved) { if (v && t.loopFix({ direction: t.swipeDirection }), a.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) { const C = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(C) } a.allowMomentumBounce = !1, s.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", l) } let E; a.isMoved && g !== t.touchesDirection && v && Math.abs(h) >= 1 && (t.loopFix({ direction: t.swipeDirection, setTranslate: !0 }), E = !0), t.emit("sliderMove", l), a.isMoved = !0, a.currentTranslate = h + a.startTranslate; let $ = !0, w = s.resistanceRatio; if (s.touchReleaseOnEdges && (w = 0), h > 0 ? (v && !E && a.currentTranslate > (s.centeredSlides ? t.minTranslate() - t.size / 2 : t.minTranslate()) && t.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), a.currentTranslate > t.minTranslate() && ($ = !1, s.resistance && (a.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + a.startTranslate + h) ** w))) : h < 0 && (v && !E && a.currentTranslate < (s.centeredSlides ? t.maxTranslate() + t.size / 2 : t.maxTranslate()) && t.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: t.slides.length - (s.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(s.slidesPerView, 10))) }), a.currentTranslate < t.maxTranslate() && ($ = !1, s.resistance && (a.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - a.startTranslate - h) ** w))), $ && (l.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (a.currentTranslate = a.startTranslate), s.threshold > 0) if (Math.abs(h) > s.threshold || a.allowThresholdMove) { if (!a.allowThresholdMove) { a.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, a.currentTranslate = a.startTranslate, r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY; return } } else { a.currentTranslate = a.startTranslate; return } !s.followFinger || s.cssMode || ((s.freeMode && s.freeMode.enabled && t.freeMode || s.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), t.params.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(a.currentTranslate), t.setTranslate(a.currentTranslate)) } function fd(n) { const e = this, t = e.touchEventsData, a = t.evCache.findIndex(E => E.pointerId === n.pointerId); if (a >= 0 && t.evCache.splice(a, 1), ["pointercancel", "pointerout", "pointerleave"].includes(n.type) && !(n.type === "pointercancel" && (e.browser.isSafari || e.browser.isWebView))) return; const { params: s, touches: r, rtlTranslate: i, slidesGrid: o, enabled: l } = e; if (!l || !s.simulateTouch && n.pointerType === "mouse") return; let c = n; if (c.originalEvent && (c = c.originalEvent), t.allowTouchCallbacks && e.emit("touchEnd", c), t.allowTouchCallbacks = !1, !t.isTouched) { t.isMoved && s.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1; return } s.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1); const d = He(), u = d - t.touchStartTime; if (e.allowClick) { const E = c.path || c.composedPath && c.composedPath(); e.updateClickedSlide(E && E[0] || c.target), e.emit("tap click", c), u < 300 && d - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", c) } if (t.lastClickTime = He(), pt(() => { e.destroyed || (e.allowClick = !0) }), !t.isTouched || !t.isMoved || !e.swipeDirection || r.diff === 0 || t.currentTranslate === t.startTranslate) { t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; return } t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; let p; if (s.followFinger ? p = i ? e.translate : -e.translate : p = -t.currentTranslate, s.cssMode) return; if (e.params.freeMode && s.freeMode.enabled) { e.freeMode.onTouchEnd({ currentPos: p }); return } let m = 0, f = e.slidesSizesGrid[0]; for (let E = 0; E < o.length; E += E < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const $ = E < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; typeof o[E + $] < "u" ? p >= o[E] && p < o[E + $] && (m = E, f = o[E + $] - o[E]) : p >= o[E] && (m = E, f = o[o.length - 1] - o[o.length - 2]) } let h = null, b = null; s.rewind && (e.isBeginning ? b = e.params.virtual && e.params.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (h = 0)); const g = (p - o[m]) / f, v = m < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (u > s.longSwipesMs) { if (!s.longSwipes) { e.slideTo(e.activeIndex); return } e.swipeDirection === "next" && (g >= s.longSwipesRatio ? e.slideTo(s.rewind && e.isEnd ? h : m + v) : e.slideTo(m)), e.swipeDirection === "prev" && (g > 1 - s.longSwipesRatio ? e.slideTo(m + v) : b !== null && g < 0 && Math.abs(g) > s.longSwipesRatio ? e.slideTo(b) : e.slideTo(m)) } else { if (!s.shortSwipes) { e.slideTo(e.activeIndex); return } e.navigation && (c.target === e.navigation.nextEl || c.target === e.navigation.prevEl) ? c.target === e.navigation.nextEl ? e.slideTo(m + v) : e.slideTo(m) : (e.swipeDirection === "next" && e.slideTo(h !== null ? h : m + v), e.swipeDirection === "prev" && e.slideTo(b !== null ? b : m)) } } function Nn() { const n = this, { params: e, el: t } = n; if (t && t.offsetWidth === 0) return; e.breakpoints && n.setBreakpoint(); const { allowSlideNext: a, allowSlidePrev: s, snapGrid: r } = n, i = n.virtual && n.params.virtual.enabled; n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses(); const o = i && e.loop; (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !o ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !i ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(n.autoplay.resizeTimeout), n.autoplay.resizeTimeout = setTimeout(() => { n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume() }, 500)), n.allowSlidePrev = s, n.allowSlideNext = a, n.params.watchOverflow && r !== n.snapGrid && n.checkOverflow() } function hd(n) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(), e.params.preventClicksPropagation && e.animating && (n.stopPropagation(), n.stopImmediatePropagation()))) } function md() { const n = this, { wrapperEl: e, rtlTranslate: t, enabled: a } = n; if (!a) return; n.previousTranslate = n.translate, n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop, n.translate === 0 && (n.translate = 0), n.updateActiveIndex(), n.updateSlidesClasses(); let s; const r = n.maxTranslate() - n.minTranslate(); r === 0 ? s = 0 : s = (n.translate - n.minTranslate()) / r, s !== n.progress && n.updateProgress(t ? -n.translate : n.translate), n.emit("setTranslate", n.translate, !1) } function gd(n) { const e = this; Wt(e, n.target), e.update() } let Yn = !1; function vd() { } const zs = (n, e) => { const t = ee(), { params: a, el: s, wrapperEl: r, device: i } = n, o = !!a.nested, l = e === "on" ? "addEventListener" : "removeEventListener", c = e; s[l]("pointerdown", n.onTouchStart, { passive: !1 }), t[l]("pointermove", n.onTouchMove, { passive: !1, capture: o }), t[l]("pointerup", n.onTouchEnd, { passive: !0 }), t[l]("pointercancel", n.onTouchEnd, { passive: !0 }), t[l]("pointerout", n.onTouchEnd, { passive: !0 }), t[l]("pointerleave", n.onTouchEnd, { passive: !0 }), (a.preventClicks || a.preventClicksPropagation) && s[l]("click", n.onClick, !0), a.cssMode && r[l]("scroll", n.onScroll), a.updateOnWindowResize ? n[c](i.ios || i.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Nn, !0) : n[c]("observerUpdate", Nn, !0), s[l]("load", n.onLoad, { capture: !0 }) }; function bd() { const n = this, e = ee(), { params: t } = n; n.onTouchStart = ud.bind(n), n.onTouchMove = pd.bind(n), n.onTouchEnd = fd.bind(n), t.cssMode && (n.onScroll = md.bind(n)), n.onClick = hd.bind(n), n.onLoad = gd.bind(n), Yn || (e.addEventListener("touchstart", vd), Yn = !0), zs(n, "on") } function yd() { zs(this, "off") } const Ed = { attachEvents: bd, detachEvents: yd }, qn = (n, e) => n.grid && e.grid && e.grid.rows > 1; function wd() { const n = this, { realIndex: e, initialized: t, params: a, el: s } = n, r = a.breakpoints; if (!r || r && Object.keys(r).length === 0) return; const i = n.getBreakpoint(r, n.params.breakpointsBase, n.el); if (!i || n.currentBreakpoint === i) return; const l = (i in r ? r[i] : void 0) || n.originalParams, c = qn(n, a), d = qn(n, l), u = a.enabled; c && !d ? (s.classList.remove(`${a.containerModifierClass}grid`, `${a.containerModifierClass}grid-column`), n.emitContainerClasses()) : !c && d && (s.classList.add(`${a.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && a.grid.fill === "column") && s.classList.add(`${a.containerModifierClass}grid-column`), n.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(h => { const b = a[h] && a[h].enabled, g = l[h] && l[h].enabled; b && !g && n[h].disable(), !b && g && n[h].enable() }); const p = l.direction && l.direction !== a.direction, m = a.loop && (l.slidesPerView !== a.slidesPerView || p); p && t && n.changeDirection(), De(n.params, l); const f = n.params.enabled; Object.assign(n, { allowTouchMove: n.params.allowTouchMove, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev }), u && !f ? n.disable() : !u && f && n.enable(), n.currentBreakpoint = i, n.emit("_beforeBreakpoint", l), m && t && (n.loopDestroy(), n.loopCreate(e), n.updateSlides()), n.emit("breakpoint", l) } function Cd(n, e = "window", t) { if (!n || e === "container" && !t) return; let a = !1; const s = U(), r = e === "window" ? s.innerHeight : t.clientHeight, i = Object.keys(n).map(o => { if (typeof o == "string" && o.indexOf("@") === 0) { const l = parseFloat(o.substr(1)); return { value: r * l, point: o } } return { value: o, point: o } }); i.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10)); for (let o = 0; o < i.length; o += 1) { const { point: l, value: c } = i[o]; e === "window" ? s.matchMedia(`(min-width: ${c}px)`).matches && (a = l) : c <= t.clientWidth && (a = l) } return a || "max" } const $d = { setBreakpoint: wd, getBreakpoint: Cd }; function xd(n, e) { const t = []; return n.forEach(a => { typeof a == "object" ? Object.keys(a).forEach(s => { a[s] && t.push(e + s) }) : typeof a == "string" && t.push(e + a) }), t } function kd() { const n = this, { classNames: e, params: t, rtl: a, el: s, device: r } = n, i = xd(["initialized", t.direction, { "free-mode": n.params.freeMode && t.freeMode.enabled }, { autoheight: t.autoHeight }, { rtl: a }, { grid: t.grid && t.grid.rows > 1 }, { "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column" }, { android: r.android }, { ios: r.ios }, { "css-mode": t.cssMode }, { centered: t.cssMode && t.centeredSlides }, { "watch-progress": t.watchSlidesProgress }], t.containerModifierClass); e.push(...i), s.classList.add(...e), n.emitContainerClasses() } function Td() { const n = this, { el: e, classNames: t } = n; e.classList.remove(...t), n.emitContainerClasses() } const Sd = { addClasses: kd, removeClasses: Td }; function Md() { const n = this, { isLocked: e, params: t } = n, { slidesOffsetBefore: a } = t; if (a) { const s = n.slides.length - 1, r = n.slidesGrid[s] + n.slidesSizesGrid[s] + a * 2; n.isLocked = n.size > r } else n.isLocked = n.snapGrid.length === 1; t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked), t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked), e && e !== n.isLocked && (n.isEnd = !1), e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock") } const Pd = { checkOverflow: Md }, Fa = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopedSlides: null, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function Ad(n, e) { return function (a = {}) { const s = Object.keys(a)[0], r = a[s]; if (typeof r != "object" || r === null) { De(e, a); return } if (["navigation", "pagination", "scrollbar"].indexOf(s) >= 0 && n[s] === !0 && (n[s] = { auto: !0 }), !(s in n && "enabled" in r)) { De(e, a); return } n[s] === !0 && (n[s] = { enabled: !0 }), typeof n[s] == "object" && !("enabled" in n[s]) && (n[s].enabled = !0), n[s] || (n[s] = { enabled: !1 }), De(e, a) } } const xa = { eventsEmitter: Sc, update: zc, translate: jc, transition: Uc, slide: ad, loop: id, grabCursor: cd, events: Ed, breakpoints: $d, checkOverflow: Pd, classes: Sd }, ka = {}; let yt = class Xe { constructor(...e) { let t, a; e.length === 1 && e[0].constructor && Object.prototype.toString.call(e[0]).slice(8, -1) === "Object" ? a = e[0] : [t, a] = e, a || (a = {}), a = De({}, a), t && !a.el && (a.el = t); const s = ee(); if (a.el && typeof a.el == "string" && s.querySelectorAll(a.el).length > 1) { const l = []; return s.querySelectorAll(a.el).forEach(c => { const d = De({}, a, { el: c }); l.push(new Xe(d)) }), l } const r = this; r.__swiper__ = !0, r.support = Rs(), r.device = Cc({ userAgent: a.userAgent }), r.browser = xc(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], a.modules && Array.isArray(a.modules) && r.modules.push(...a.modules); const i = {}; r.modules.forEach(l => { l({ params: a, swiper: r, extendParams: Ad(a, i), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r) }) }); const o = De({}, Fa, i); return r.params = De({}, o, ka, a), r.originalParams = De({}, r.params), r.passedParams = De({}, a), r.params && r.params.on && Object.keys(r.params.on).forEach(l => { r.on(l, r.params.on[l]) }), r.params && r.params.onAny && r.onAny(r.params.onAny), Object.assign(r, { enabled: r.params.enabled, el: t, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return r.params.direction === "horizontal" }, isVertical() { return r.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, evCache: [] }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.emit("_swiper"), r.params.init && r.init(), r } getSlideIndex(e) { const { slidesEl: t, params: a } = this, s = ke(t, `.${a.slideClass}, swiper-slide`), r = Dt(s[0]); return Dt(e) - r } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter(t => t.getAttribute("data-swiper-slide-index") * 1 === e)[0]) } recalcSlides() { const e = this, { slidesEl: t, params: a } = e; e.slides = ke(t, `.${a.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const a = this; e = Math.min(Math.max(e, 0), 1); const s = a.minTranslate(), i = (a.maxTranslate() - s) * e + s; a.translateTo(i, typeof t > "u" ? 0 : t), a.updateActiveIndex(), a.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter(a => a.indexOf("swiper") === 0 || a.indexOf(e.params.containerModifierClass) === 0); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter(a => a.indexOf("swiper-slide") === 0 || a.indexOf(t.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach(a => { const s = e.getSlideClasses(a); t.push({ slideEl: a, classNames: s }), e.emit("_slideClass", a, s) }), e.emit("_slideClasses", t) } slidesPerViewDynamic(e = "current", t = !1) { const a = this, { params: s, slides: r, slidesGrid: i, slidesSizesGrid: o, size: l, activeIndex: c } = a; let d = 1; if (s.centeredSlides) { let u = r[c].swiperSlideSize, p; for (let m = c + 1; m < r.length; m += 1)r[m] && !p && (u += r[m].swiperSlideSize, d += 1, u > l && (p = !0)); for (let m = c - 1; m >= 0; m -= 1)r[m] && !p && (u += r[m].swiperSlideSize, d += 1, u > l && (p = !0)) } else if (e === "current") for (let u = c + 1; u < r.length; u += 1)(t ? i[u] + o[u] - i[c] < l : i[u] - i[c] < l) && (d += 1); else for (let u = c - 1; u >= 0; u -= 1)i[c] - i[u] < l && (d += 1); return d } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: a } = e; a.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(i => { i.complete && Wt(e, i) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(); function s() { const i = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(i, e.maxTranslate()), e.minTranslate()); e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses() } let r; if (e.params.freeMode && e.params.freeMode.enabled) s(), e.params.autoHeight && e.updateAutoHeight(); else { if ((e.params.slidesPerView === "auto" || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides) { const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides : e.slides; r = e.slideTo(i.length - 1, 0, !1, !0) } else r = e.slideTo(e.activeIndex, 0, !1, !0); r || s() } a.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const a = this, s = a.params.direction; return e || (e = s === "horizontal" ? "vertical" : "horizontal"), e === s || e !== "horizontal" && e !== "vertical" || (a.el.classList.remove(`${a.params.containerModifierClass}${s}`), a.el.classList.add(`${a.params.containerModifierClass}${e}`), a.emitContainerClasses(), a.params.direction = e, a.slides.forEach(r => { e === "vertical" ? r.style.width = "" : r.style.height = "" }), a.emit("changeDirection"), t && a.update()), a } changeLanguageDirection(e) { const t = this; t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let a = e || t.params.el; if (typeof a == "string" && (a = document.querySelector(a)), !a) return !1; a.swiper = t, a.shadowEl && (t.isElement = !0); const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let i = (() => a && a.shadowRoot && a.shadowRoot.querySelector ? a.shadowRoot.querySelector(s()) : ke(a, s())[0])(); return !i && t.params.createElements && (i = ze("div", t.params.wrapperClass), a.append(i), ke(a, `.${t.params.slideClass}`).forEach(o => { i.append(o) })), Object.assign(t, { el: a, wrapperEl: i, slidesEl: t.isElement ? a : i, mounted: !0, rtl: a.dir.toLowerCase() === "rtl" || st(a, "direction") === "rtl", rtlTranslate: t.params.direction === "horizontal" && (a.dir.toLowerCase() === "rtl" || st(a, "direction") === "rtl"), wrongRTL: st(i, "display") === "-webkit-box" }), !0 } init(e) { const t = this; return t.initialized || t.mount(e) === !1 || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach(s => { s.complete ? Wt(t, s) : s.addEventListener("load", r => { Wt(t, r.target) }) }), za(t), t.initialized = !0, za(t), t.emit("init"), t.emit("afterInit")), t } destroy(e = !0, t = !0) { const a = this, { params: s, el: r, wrapperEl: i, slides: o } = a; return typeof a.params > "u" || a.destroyed || (a.emit("beforeDestroy"), a.initialized = !1, a.detachEvents(), s.loop && a.loopDestroy(), t && (a.removeClasses(), r.removeAttribute("style"), i.removeAttribute("style"), o && o.length && o.forEach(l => { l.classList.remove(s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index") })), a.emit("destroy"), Object.keys(a.eventsListeners).forEach(l => { a.off(l) }), e !== !1 && (a.el.swiper = null, mc(a)), a.destroyed = !0), null } static extendDefaults(e) { De(ka, e) } static get extendedDefaults() { return ka } static get defaults() { return Fa } static installModule(e) { Xe.prototype.__modules__ || (Xe.prototype.__modules__ = []); const t = Xe.prototype.__modules__; typeof e == "function" && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(t => Xe.installModule(t)), Xe) : (Xe.installModule(e), Xe) } }; Object.keys(xa).forEach(n => { Object.keys(xa[n]).forEach(e => { yt.prototype[e] = xa[n][e] }) }); yt.use([kc, Tc]); function Id({ swiper: n, extendParams: e, on: t, emit: a }) { e({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); let s; const r = ee(); n.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const i = r.createElement("div"); function o(m, f) { const h = n.params.virtual; if (h.cache && n.virtual.cache[f]) return n.virtual.cache[f]; let b; return h.renderSlide ? (b = h.renderSlide.call(n, m, f), typeof b == "string" && (i.innerHTML = b, b = i.children[0])) : n.isElement ? b = ze("swiper-slide") : b = ze("div", n.params.slideClass), b.setAttribute("data-swiper-slide-index", f), h.renderSlide || (b.innerHTML = m), h.cache && (n.virtual.cache[f] = b), b } function l(m) { const { slidesPerView: f, slidesPerGroup: h, centeredSlides: b, loop: g } = n.params, { addSlidesBefore: v, addSlidesAfter: E } = n.params.virtual, { from: $, to: w, slides: C, slidesGrid: k, offset: M } = n.virtual; n.params.cssMode || n.updateActiveIndex(); const A = n.activeIndex || 0; let O; n.rtlTranslate ? O = "right" : O = n.isHorizontal() ? "left" : "top"; let S, P; b ? (S = Math.floor(f / 2) + h + E, P = Math.floor(f / 2) + h + v) : (S = f + (h - 1) + E, P = (g ? f : h) + v); let T = A - P, I = A + S; g || (T = Math.max(T, 0), I = Math.min(I, C.length - 1)); let H = (n.slidesGrid[T] || 0) - (n.slidesGrid[0] || 0); g && A >= P ? (T -= P, b || (H += n.slidesGrid[0])) : g && A < P && (T = -P, b && (H += n.slidesGrid[0])), Object.assign(n.virtual, { from: T, to: I, offset: H, slidesGrid: n.slidesGrid, slidesBefore: P, slidesAfter: S }); function D() { n.updateSlides(), n.updateProgress(), n.updateSlidesClasses(), a("virtualUpdate") } if ($ === T && w === I && !m) { n.slidesGrid !== k && H !== M && n.slides.forEach(V => { V.style[O] = `${H - Math.abs(n.cssOverflowAdjustment())}px` }), n.updateProgress(), a("virtualUpdate"); return } if (n.params.virtual.renderExternal) { n.params.virtual.renderExternal.call(n, { offset: H, from: T, to: I, slides: function () { const _ = []; for (let J = T; J <= I; J += 1)_.push(C[J]); return _ }() }), n.params.virtual.renderExternalUpdate ? D() : a("virtualUpdate"); return } const z = [], B = [], L = V => { let _ = V; return V < 0 ? _ = C.length + V : _ >= C.length && (_ = _ - C.length), _ }; if (m) n.slidesEl.querySelectorAll(`.${n.params.slideClass}, swiper-slide`).forEach(V => { V.remove() }); else for (let V = $; V <= w; V += 1)if (V < T || V > I) { const _ = L(V); n.slidesEl.querySelectorAll(`.${n.params.slideClass}[data-swiper-slide-index="${_}"], swiper-slide[data-swiper-slide-index="${_}"]`).forEach(J => { J.remove() }) } const N = g ? -C.length : 0, F = g ? C.length * 2 : C.length; for (let V = N; V < F; V += 1)if (V >= T && V <= I) { const _ = L(V); typeof w > "u" || m ? B.push(_) : (V > w && B.push(_), V < $ && z.push(_)) } if (B.forEach(V => { n.slidesEl.append(o(C[V], V)) }), g) for (let V = z.length - 1; V >= 0; V -= 1) { const _ = z[V]; n.slidesEl.prepend(o(C[_], _)) } else z.sort((V, _) => _ - V), z.forEach(V => { n.slidesEl.prepend(o(C[V], V)) }); ke(n.slidesEl, ".swiper-slide, swiper-slide").forEach(V => { V.style[O] = `${H - Math.abs(n.cssOverflowAdjustment())}px` }), D() } function c(m) { if (typeof m == "object" && "length" in m) for (let f = 0; f < m.length; f += 1)m[f] && n.virtual.slides.push(m[f]); else n.virtual.slides.push(m); l(!0) } function d(m) { const f = n.activeIndex; let h = f + 1, b = 1; if (Array.isArray(m)) { for (let g = 0; g < m.length; g += 1)m[g] && n.virtual.slides.unshift(m[g]); h = f + m.length, b = m.length } else n.virtual.slides.unshift(m); if (n.params.virtual.cache) { const g = n.virtual.cache, v = {}; Object.keys(g).forEach(E => { const $ = g[E], w = $.getAttribute("data-swiper-slide-index"); w && $.setAttribute("data-swiper-slide-index", parseInt(w, 10) + b), v[parseInt(E, 10) + b] = $ }), n.virtual.cache = v } l(!0), n.slideTo(h, 0) } function u(m) { if (typeof m > "u" || m === null) return; let f = n.activeIndex; if (Array.isArray(m)) for (let h = m.length - 1; h >= 0; h -= 1)n.virtual.slides.splice(m[h], 1), n.params.virtual.cache && delete n.virtual.cache[m[h]], m[h] < f && (f -= 1), f = Math.max(f, 0); else n.virtual.slides.splice(m, 1), n.params.virtual.cache && delete n.virtual.cache[m], m < f && (f -= 1), f = Math.max(f, 0); l(!0), n.slideTo(f, 0) } function p() { n.virtual.slides = [], n.params.virtual.cache && (n.virtual.cache = {}), l(!0), n.slideTo(0, 0) } t("beforeInit", () => { if (!n.params.virtual.enabled) return; let m; if (typeof n.passedParams.virtual.slides > "u") { const f = [...n.slidesEl.children].filter(h => h.matches(`.${n.params.slideClass}, swiper-slide`)); f && f.length && (n.virtual.slides = [...f], m = !0, f.forEach((h, b) => { h.setAttribute("data-swiper-slide-index", b), n.virtual.cache[b] = h, h.remove() })) } m || (n.virtual.slides = n.params.virtual.slides), n.classNames.push(`${n.params.containerModifierClass}virtual`), n.params.watchSlidesProgress = !0, n.originalParams.watchSlidesProgress = !0, n.params.initialSlide || l() }), t("setTranslate", () => { n.params.virtual.enabled && (n.params.cssMode && !n._immediateVirtual ? (clearTimeout(s), s = setTimeout(() => { l() }, 100)) : l()) }), t("init update resize", () => { n.params.virtual.enabled && n.params.cssMode && It(n.wrapperEl, "--swiper-virtual-size", `${n.virtualSize}px`) }), Object.assign(n.virtual, { appendSlide: c, prependSlide: d, removeSlide: u, removeAllSlides: p, update: l }) } function Od({ swiper: n, extendParams: e, on: t, emit: a }) { const s = ee(), r = U(); n.keyboard = { enabled: !1 }, e({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }); function i(c) { if (!n.enabled) return; const { rtlTranslate: d } = n; let u = c; u.originalEvent && (u = u.originalEvent); const p = u.keyCode || u.charCode, m = n.params.keyboard.pageUpDown, f = m && p === 33, h = m && p === 34, b = p === 37, g = p === 39, v = p === 38, E = p === 40; if (!n.allowSlideNext && (n.isHorizontal() && g || n.isVertical() && E || h) || !n.allowSlidePrev && (n.isHorizontal() && b || n.isVertical() && v || f)) return !1; if (!(u.shiftKey || u.altKey || u.ctrlKey || u.metaKey) && !(s.activeElement && s.activeElement.nodeName && (s.activeElement.nodeName.toLowerCase() === "input" || s.activeElement.nodeName.toLowerCase() === "textarea"))) { if (n.params.keyboard.onlyInViewport && (f || h || b || g || v || E)) { let $ = !1; if (ut(n.el, `.${n.params.slideClass}, swiper-slide`).length > 0 && ut(n.el, `.${n.params.slideActiveClass}`).length === 0) return; const w = n.el, C = w.clientWidth, k = w.clientHeight, M = r.innerWidth, A = r.innerHeight, O = Jt(w); d && (O.left -= w.scrollLeft); const S = [[O.left, O.top], [O.left + C, O.top], [O.left, O.top + k], [O.left + C, O.top + k]]; for (let P = 0; P < S.length; P += 1) { const T = S[P]; if (T[0] >= 0 && T[0] <= M && T[1] >= 0 && T[1] <= A) { if (T[0] === 0 && T[1] === 0) continue; $ = !0 } } if (!$) return } n.isHorizontal() ? ((f || h || b || g) && (u.preventDefault ? u.preventDefault() : u.returnValue = !1), ((h || g) && !d || (f || b) && d) && n.slideNext(), ((f || b) && !d || (h || g) && d) && n.slidePrev()) : ((f || h || v || E) && (u.preventDefault ? u.preventDefault() : u.returnValue = !1), (h || E) && n.slideNext(), (f || v) && n.slidePrev()), a("keyPress", p) } } function o() { n.keyboard.enabled || (s.addEventListener("keydown", i), n.keyboard.enabled = !0) } function l() { n.keyboard.enabled && (s.removeEventListener("keydown", i), n.keyboard.enabled = !1) } t("init", () => { n.params.keyboard.enabled && o() }), t("destroy", () => { n.keyboard.enabled && l() }), Object.assign(n.keyboard, { enable: o, disable: l }) } function Bd({ swiper: n, extendParams: e, on: t, emit: a }) { const s = U(); e({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null } }), n.mousewheel = { enabled: !1 }; let r, i = He(), o; const l = []; function c(v) { let C = 0, k = 0, M = 0, A = 0; return "detail" in v && (k = v.detail), "wheelDelta" in v && (k = -v.wheelDelta / 120), "wheelDeltaY" in v && (k = -v.wheelDeltaY / 120), "wheelDeltaX" in v && (C = -v.wheelDeltaX / 120), "axis" in v && v.axis === v.HORIZONTAL_AXIS && (C = k, k = 0), M = C * 10, A = k * 10, "deltaY" in v && (A = v.deltaY), "deltaX" in v && (M = v.deltaX), v.shiftKey && !M && (M = A, A = 0), (M || A) && v.deltaMode && (v.deltaMode === 1 ? (M *= 40, A *= 40) : (M *= 800, A *= 800)), M && !C && (C = M < 1 ? -1 : 1), A && !k && (k = A < 1 ? -1 : 1), { spinX: C, spinY: k, pixelX: M, pixelY: A } } function d() { n.enabled && (n.mouseEntered = !0) } function u() { n.enabled && (n.mouseEntered = !1) } function p(v) { return n.params.mousewheel.thresholdDelta && v.delta < n.params.mousewheel.thresholdDelta || n.params.mousewheel.thresholdTime && He() - i < n.params.mousewheel.thresholdTime ? !1 : v.delta >= 6 && He() - i < 60 ? !0 : (v.direction < 0 ? (!n.isEnd || n.params.loop) && !n.animating && (n.slideNext(), a("scroll", v.raw)) : (!n.isBeginning || n.params.loop) && !n.animating && (n.slidePrev(), a("scroll", v.raw)), i = new s.Date().getTime(), !1) } function m(v) { const E = n.params.mousewheel; if (v.direction < 0) { if (n.isEnd && !n.params.loop && E.releaseOnEdges) return !0 } else if (n.isBeginning && !n.params.loop && E.releaseOnEdges) return !0; return !1 } function f(v) { let E = v, $ = !0; if (!n.enabled) return; const w = n.params.mousewheel; n.params.cssMode && E.preventDefault(); let C = n.el; n.params.mousewheel.eventsTarget !== "container" && (C = document.querySelector(n.params.mousewheel.eventsTarget)); const k = C && C.contains(E.target); if (!n.mouseEntered && !k && !w.releaseOnEdges) return !0; E.originalEvent && (E = E.originalEvent); let M = 0; const A = n.rtlTranslate ? -1 : 1, O = c(E); if (w.forceToAxis) if (n.isHorizontal()) if (Math.abs(O.pixelX) > Math.abs(O.pixelY)) M = -O.pixelX * A; else return !0; else if (Math.abs(O.pixelY) > Math.abs(O.pixelX)) M = -O.pixelY; else return !0; else M = Math.abs(O.pixelX) > Math.abs(O.pixelY) ? -O.pixelX * A : -O.pixelY; if (M === 0) return !0; w.invert && (M = -M); let S = n.getTranslate() + M * w.sensitivity; if (S >= n.minTranslate() && (S = n.minTranslate()), S <= n.maxTranslate() && (S = n.maxTranslate()), $ = n.params.loop ? !0 : !(S === n.minTranslate() || S === n.maxTranslate()), $ && n.params.nested && E.stopPropagation(), !n.params.freeMode || !n.params.freeMode.enabled) { const P = { time: He(), delta: Math.abs(M), direction: Math.sign(M), raw: v }; l.length >= 2 && l.shift(); const T = l.length ? l[l.length - 1] : void 0; if (l.push(P), T ? (P.direction !== T.direction || P.delta > T.delta || P.time > T.time + 150) && p(P) : p(P), m(P)) return !0 } else { const P = { time: He(), delta: Math.abs(M), direction: Math.sign(M) }, T = o && P.time < o.time + 500 && P.delta <= o.delta && P.direction === o.direction; if (!T) { o = void 0; let I = n.getTranslate() + M * w.sensitivity; const H = n.isBeginning, D = n.isEnd; if (I >= n.minTranslate() && (I = n.minTranslate()), I <= n.maxTranslate() && (I = n.maxTranslate()), n.setTransition(0), n.setTranslate(I), n.updateProgress(), n.updateActiveIndex(), n.updateSlidesClasses(), (!H && n.isBeginning || !D && n.isEnd) && n.updateSlidesClasses(), n.params.loop && n.loopFix({ direction: P.direction < 0 ? "next" : "prev", byMousewheel: !0 }), n.params.freeMode.sticky) { clearTimeout(r), r = void 0, l.length >= 15 && l.shift(); const z = l.length ? l[l.length - 1] : void 0, B = l[0]; if (l.push(P), z && (P.delta > z.delta || P.direction !== z.direction)) l.splice(0); else if (l.length >= 15 && P.time - B.time < 500 && B.delta - P.delta >= 1 && P.delta <= 6) { const L = M > 0 ? .8 : .2; o = P, l.splice(0), r = pt(() => { n.slideToClosest(n.params.speed, !0, void 0, L) }, 0) } r || (r = pt(() => { o = P, l.splice(0), n.slideToClosest(n.params.speed, !0, void 0, .5) }, 500)) } if (T || a("scroll", E), n.params.autoplay && n.params.autoplayDisableOnInteraction && n.autoplay.stop(), I === n.minTranslate() || I === n.maxTranslate()) return !0 } } return E.preventDefault ? E.preventDefault() : E.returnValue = !1, !1 } function h(v) { let E = n.el; n.params.mousewheel.eventsTarget !== "container" && (E = document.querySelector(n.params.mousewheel.eventsTarget)), E[v]("mouseenter", d), E[v]("mouseleave", u), E[v]("wheel", f) } function b() { return n.params.cssMode ? (n.wrapperEl.removeEventListener("wheel", f), !0) : n.mousewheel.enabled ? !1 : (h("addEventListener"), n.mousewheel.enabled = !0, !0) } function g() { return n.params.cssMode ? (n.wrapperEl.addEventListener(event, f), !0) : n.mousewheel.enabled ? (h("removeEventListener"), n.mousewheel.enabled = !1, !0) : !1 } t("init", () => { !n.params.mousewheel.enabled && n.params.cssMode && g(), n.params.mousewheel.enabled && b() }), t("destroy", () => { n.params.cssMode && b(), n.mousewheel.enabled && g() }), Object.assign(n.mousewheel, { enable: b, disable: g }) } function _a(n, e, t, a) { return n.params.createElements && Object.keys(a).forEach(s => { if (!t[s] && t.auto === !0) { let r = ke(n.el, `.${a[s]}`)[0]; r || (r = ze("div", a[s]), r.className = a[s], n.el.append(r)), t[s] = r, e[s] = r } }), t } function Dd({ swiper: n, extendParams: e, on: t, emit: a }) { e({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), n.navigation = { nextEl: null, prevEl: null }; const s = f => (Array.isArray(f) || (f = [f].filter(h => !!h)), f); function r(f) { let h; return f && typeof f == "string" && n.isElement && (h = n.el.shadowRoot.querySelector(f), h) ? h : (f && (typeof f == "string" && (h = [...document.querySelectorAll(f)]), n.params.uniqueNavElements && typeof f == "string" && h.length > 1 && n.el.querySelectorAll(f).length === 1 && (h = n.el.querySelector(f))), f && !h ? f : h) } function i(f, h) { const b = n.params.navigation; f = s(f), f.forEach(g => { g && (g.classList[h ? "add" : "remove"](...b.disabledClass.split(" ")), g.tagName === "BUTTON" && (g.disabled = h), n.params.watchOverflow && n.enabled && g.classList[n.isLocked ? "add" : "remove"](b.lockClass)) }) } function o() { const { nextEl: f, prevEl: h } = n.navigation; if (n.params.loop) { i(h, !1), i(f, !1); return } i(h, n.isBeginning && !n.params.rewind), i(f, n.isEnd && !n.params.rewind) } function l(f) { f.preventDefault(), !(n.isBeginning && !n.params.loop && !n.params.rewind) && (n.slidePrev(), a("navigationPrev")) } function c(f) { f.preventDefault(), !(n.isEnd && !n.params.loop && !n.params.rewind) && (n.slideNext(), a("navigationNext")) } function d() { const f = n.params.navigation; if (n.params.navigation = _a(n, n.originalParams.navigation, n.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(f.nextEl || f.prevEl)) return; let h = r(f.nextEl), b = r(f.prevEl); Object.assign(n.navigation, { nextEl: h, prevEl: b }), h = s(h), b = s(b); const g = (v, E) => { v && v.addEventListener("click", E === "next" ? c : l), !n.enabled && v && v.classList.add(...f.lockClass.split(" ")) }; h.forEach(v => g(v, "next")), b.forEach(v => g(v, "prev")) } function u() { let { nextEl: f, prevEl: h } = n.navigation; f = s(f), h = s(h); const b = (g, v) => { g.removeEventListener("click", v === "next" ? c : l), g.classList.remove(...n.params.navigation.disabledClass.split(" ")) }; f.forEach(g => b(g, "next")), h.forEach(g => b(g, "prev")) } t("init", () => { n.params.navigation.enabled === !1 ? m() : (d(), o()) }), t("toEdge fromEdge lock unlock", () => { o() }), t("destroy", () => { u() }), t("enable disable", () => { let { nextEl: f, prevEl: h } = n.navigation; f = s(f), h = s(h), [...f, ...h].filter(b => !!b).forEach(b => b.classList[n.enabled ? "remove" : "add"](n.params.navigation.lockClass)) }), t("click", (f, h) => { let { nextEl: b, prevEl: g } = n.navigation; b = s(b), g = s(g); const v = h.target; if (n.params.navigation.hideOnClick && !g.includes(v) && !b.includes(v)) { if (n.pagination && n.params.pagination && n.params.pagination.clickable && (n.pagination.el === v || n.pagination.el.contains(v))) return; let E; b.length ? E = b[0].classList.contains(n.params.navigation.hiddenClass) : g.length && (E = g[0].classList.contains(n.params.navigation.hiddenClass)), a(E === !0 ? "navigationShow" : "navigationHide"), [...b, ...g].filter($ => !!$).forEach($ => $.classList.toggle(n.params.navigation.hiddenClass)) } }); const p = () => { n.el.classList.remove(...n.params.navigation.navigationDisabledClass.split(" ")), d(), o() }, m = () => { n.el.classList.add(...n.params.navigation.navigationDisabledClass.split(" ")), u() }; Object.assign(n.navigation, { enable: p, disable: m, update: o, init: d, destroy: u }) } function at(n = "") { return `.${n.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function Ld({ swiper: n, extendParams: e, on: t, emit: a }) { const s = "swiper-pagination"; e({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: g => g, formatFractionTotal: g => g, bulletClass: `${s}-bullet`, bulletActiveClass: `${s}-bullet-active`, modifierClass: `${s}-`, currentClass: `${s}-current`, totalClass: `${s}-total`, hiddenClass: `${s}-hidden`, progressbarFillClass: `${s}-progressbar-fill`, progressbarOppositeClass: `${s}-progressbar-opposite`, clickableClass: `${s}-clickable`, lockClass: `${s}-lock`, horizontalClass: `${s}-horizontal`, verticalClass: `${s}-vertical`, paginationDisabledClass: `${s}-disabled` } }), n.pagination = { el: null, bullets: [] }; let r, i = 0; const o = g => (Array.isArray(g) || (g = [g].filter(v => !!v)), g); function l() { return !n.params.pagination.el || !n.pagination.el || Array.isArray(n.pagination.el) && n.pagination.el.length === 0 } function c(g, v) { const { bulletActiveClass: E } = n.params.pagination; g && (g = g[`${v === "prev" ? "previous" : "next"}ElementSibling`], g && (g.classList.add(`${E}-${v}`), g = g[`${v === "prev" ? "previous" : "next"}ElementSibling`], g && g.classList.add(`${E}-${v}-${v}`))) } function d(g) { const v = g.target.closest(at(n.params.pagination.bulletClass)); if (!v) return; g.preventDefault(); const E = Dt(v) * n.params.slidesPerGroup; if (n.params.loop) { if (n.realIndex === E) return; const $ = n.getSlideIndexByData(E), w = n.getSlideIndexByData(n.realIndex); $ > n.slides.length - n.loopedSlides && n.loopFix({ direction: $ > w ? "next" : "prev", activeSlideIndex: $, slideTo: !1 }), n.slideToLoop(E) } else n.slideTo(E) } function u() { const g = n.rtl, v = n.params.pagination; if (l()) return; let E = n.pagination.el; E = o(E); let $, w; const C = n.virtual && n.params.virtual.enabled ? n.virtual.slides.length : n.slides.length, k = n.params.loop ? Math.ceil(C / n.params.slidesPerGroup) : n.snapGrid.length; if (n.params.loop ? (w = n.previousRealIndex || 0, $ = n.params.slidesPerGroup > 1 ? Math.floor(n.realIndex / n.params.slidesPerGroup) : n.realIndex) : typeof n.snapIndex < "u" ? ($ = n.snapIndex, w = n.previousSnapIndex) : (w = n.previousIndex || 0, $ = n.activeIndex || 0), v.type === "bullets" && n.pagination.bullets && n.pagination.bullets.length > 0) { const M = n.pagination.bullets; let A, O, S; if (v.dynamicBullets && (r = Ha(M[0], n.isHorizontal() ? "width" : "height", !0), E.forEach(P => { P.style[n.isHorizontal() ? "width" : "height"] = `${r * (v.dynamicMainBullets + 4)}px` }), v.dynamicMainBullets > 1 && w !== void 0 && (i += $ - (w || 0), i > v.dynamicMainBullets - 1 ? i = v.dynamicMainBullets - 1 : i < 0 && (i = 0)), A = Math.max($ - i, 0), O = A + (Math.min(M.length, v.dynamicMainBullets) - 1), S = (O + A) / 2), M.forEach(P => { const T = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(I => `${v.bulletActiveClass}${I}`)].map(I => typeof I == "string" && I.includes(" ") ? I.split(" ") : I).flat(); P.classList.remove(...T) }), E.length > 1) M.forEach(P => { const T = Dt(P); T === $ && P.classList.add(...v.bulletActiveClass.split(" ")), v.dynamicBullets && (T >= A && T <= O && P.classList.add(...`${v.bulletActiveClass}-main`.split(" ")), T === A && c(P, "prev"), T === O && c(P, "next")) }); else { const P = M[$]; if (P && P.classList.add(...v.bulletActiveClass.split(" ")), v.dynamicBullets) { const T = M[A], I = M[O]; for (let H = A; H <= O; H += 1)M[H] && M[H].classList.add(...`${v.bulletActiveClass}-main`.split(" ")); c(T, "prev"), c(I, "next") } } if (v.dynamicBullets) { const P = Math.min(M.length, v.dynamicMainBullets + 4), T = (r * P - r) / 2 - S * r, I = g ? "right" : "left"; M.forEach(H => { H.style[n.isHorizontal() ? I : "top"] = `${T}px` }) } } E.forEach((M, A) => { if (v.type === "fraction" && (M.querySelectorAll(at(v.currentClass)).forEach(O => { O.textContent = v.formatFractionCurrent($ + 1) }), M.querySelectorAll(at(v.totalClass)).forEach(O => { O.textContent = v.formatFractionTotal(k) })), v.type === "progressbar") { let O; v.progressbarOpposite ? O = n.isHorizontal() ? "vertical" : "horizontal" : O = n.isHorizontal() ? "horizontal" : "vertical"; const S = ($ + 1) / k; let P = 1, T = 1; O === "horizontal" ? P = S : T = S, M.querySelectorAll(at(v.progressbarFillClass)).forEach(I => { I.style.transform = `translate3d(0,0,0) scaleX(${P}) scaleY(${T})`, I.style.transitionDuration = `${n.params.speed}ms` }) } v.type === "custom" && v.renderCustom ? (M.innerHTML = v.renderCustom(n, $ + 1, k), A === 0 && a("paginationRender", M)) : (A === 0 && a("paginationRender", M), a("paginationUpdate", M)), n.params.watchOverflow && n.enabled && M.classList[n.isLocked ? "add" : "remove"](v.lockClass) }) } function p() { const g = n.params.pagination; if (l()) return; const v = n.virtual && n.params.virtual.enabled ? n.virtual.slides.length : n.slides.length; let E = n.pagination.el; E = o(E); let $ = ""; if (g.type === "bullets") { let w = n.params.loop ? Math.ceil(v / n.params.slidesPerGroup) : n.snapGrid.length; n.params.freeMode && n.params.freeMode.enabled && w > v && (w = v); for (let C = 0; C < w; C += 1)g.renderBullet ? $ += g.renderBullet.call(n, C, g.bulletClass) : $ += `<${g.bulletElement} class="${g.bulletClass}"></${g.bulletElement}>` } g.type === "fraction" && (g.renderFraction ? $ = g.renderFraction.call(n, g.currentClass, g.totalClass) : $ = `<span class="${g.currentClass}"></span> / <span class="${g.totalClass}"></span>`), g.type === "progressbar" && (g.renderProgressbar ? $ = g.renderProgressbar.call(n, g.progressbarFillClass) : $ = `<span class="${g.progressbarFillClass}"></span>`), n.pagination.bullets = [], E.forEach(w => { g.type !== "custom" && (w.innerHTML = $ || ""), g.type === "bullets" && n.pagination.bullets.push(...w.querySelectorAll(at(g.bulletClass))) }), g.type !== "custom" && a("paginationRender", E[0]) } function m() { n.params.pagination = _a(n, n.originalParams.pagination, n.params.pagination, { el: "swiper-pagination" }); const g = n.params.pagination; if (!g.el) return; let v; typeof g.el == "string" && n.isElement && (v = n.el.shadowRoot.querySelector(g.el)), !v && typeof g.el == "string" && (v = [...document.querySelectorAll(g.el)]), v || (v = g.el), !(!v || v.length === 0) && (n.params.uniqueNavElements && typeof g.el == "string" && Array.isArray(v) && v.length > 1 && (v = [...n.el.querySelectorAll(g.el)], v.length > 1 && (v = v.filter(E => ut(E, ".swiper")[0] === n.el)[0])), Array.isArray(v) && v.length === 1 && (v = v[0]), Object.assign(n.pagination, { el: v }), v = o(v), v.forEach(E => { g.type === "bullets" && g.clickable && E.classList.add(g.clickableClass), E.classList.add(g.modifierClass + g.type), E.classList.add(n.isHorizontal() ? g.horizontalClass : g.verticalClass), g.type === "bullets" && g.dynamicBullets && (E.classList.add(`${g.modifierClass}${g.type}-dynamic`), i = 0, g.dynamicMainBullets < 1 && (g.dynamicMainBullets = 1)), g.type === "progressbar" && g.progressbarOpposite && E.classList.add(g.progressbarOppositeClass), g.clickable && E.addEventListener("click", d), n.enabled || E.classList.add(g.lockClass) })) } function f() { const g = n.params.pagination; if (l()) return; let v = n.pagination.el; v && (v = o(v), v.forEach(E => { E.classList.remove(g.hiddenClass), E.classList.remove(g.modifierClass + g.type), E.classList.remove(n.isHorizontal() ? g.horizontalClass : g.verticalClass), g.clickable && E.removeEventListener("click", d) })), n.pagination.bullets && n.pagination.bullets.forEach(E => E.classList.remove(...g.bulletActiveClass.split(" "))) } t("changeDirection", () => { if (!n.pagination || !n.pagination.el) return; const g = n.params.pagination; let { el: v } = n.pagination; v = o(v), v.forEach(E => { E.classList.remove(g.horizontalClass, g.verticalClass), E.classList.add(n.isHorizontal() ? g.horizontalClass : g.verticalClass) }) }), t("init", () => { n.params.pagination.enabled === !1 ? b() : (m(), p(), u()) }), t("activeIndexChange", () => { typeof n.snapIndex > "u" && u() }), t("snapIndexChange", () => { u() }), t("snapGridLengthChange", () => { p(), u() }), t("destroy", () => { f() }), t("enable disable", () => { let { el: g } = n.pagination; g && (g = o(g), g.forEach(v => v.classList[n.enabled ? "remove" : "add"](n.params.pagination.lockClass))) }), t("lock unlock", () => { u() }), t("click", (g, v) => { const E = v.target; let { el: $ } = n.pagination; if (Array.isArray($) || ($ = [$].filter(w => !!w)), n.params.pagination.el && n.params.pagination.hideOnClick && $ && $.length > 0 && !E.classList.contains(n.params.pagination.bulletClass)) { if (n.navigation && (n.navigation.nextEl && E === n.navigation.nextEl || n.navigation.prevEl && E === n.navigation.prevEl)) return; const w = $[0].classList.contains(n.params.pagination.hiddenClass); a(w === !0 ? "paginationShow" : "paginationHide"), $.forEach(C => C.classList.toggle(n.params.pagination.hiddenClass)) } }); const h = () => { n.el.classList.remove(n.params.pagination.paginationDisabledClass); let { el: g } = n.pagination; g && (g = o(g), g.forEach(v => v.classList.remove(n.params.pagination.paginationDisabledClass))), m(), p(), u() }, b = () => { n.el.classList.add(n.params.pagination.paginationDisabledClass); let { el: g } = n.pagination; g && (g = o(g), g.forEach(v => v.classList.add(n.params.pagination.paginationDisabledClass))), f() }; Object.assign(n.pagination, { enable: h, disable: b, render: p, update: u, init: m, destroy: f }) } function Rd({ swiper: n, extendParams: e, on: t, emit: a }) { const s = ee(); let r = !1, i = null, o = null, l, c, d, u; e({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), n.scrollbar = { el: null, dragEl: null }; function p() { if (!n.params.scrollbar.el || !n.scrollbar.el) return; const { scrollbar: S, rtlTranslate: P } = n, { dragEl: T, el: I } = S, H = n.params.scrollbar, D = n.params.loop ? n.progressLoop : n.progress; let z = c, B = (d - c) * D; P ? (B = -B, B > 0 ? (z = c - B, B = 0) : -B + c > d && (z = d + B)) : B < 0 ? (z = c + B, B = 0) : B + c > d && (z = d - B), n.isHorizontal() ? (T.style.transform = `translate3d(${B}px, 0, 0)`, T.style.width = `${z}px`) : (T.style.transform = `translate3d(0px, ${B}px, 0)`, T.style.height = `${z}px`), H.hide && (clearTimeout(i), I.style.opacity = 1, i = setTimeout(() => { I.style.opacity = 0, I.style.transitionDuration = "400ms" }, 1e3)) } function m(S) { !n.params.scrollbar.el || !n.scrollbar.el || (n.scrollbar.dragEl.style.transitionDuration = `${S}ms`) } function f() { if (!n.params.scrollbar.el || !n.scrollbar.el) return; const { scrollbar: S } = n, { dragEl: P, el: T } = S; P.style.width = "", P.style.height = "", d = n.isHorizontal() ? T.offsetWidth : T.offsetHeight, u = n.size / (n.virtualSize + n.params.slidesOffsetBefore - (n.params.centeredSlides ? n.snapGrid[0] : 0)), n.params.scrollbar.dragSize === "auto" ? c = d * u : c = parseInt(n.params.scrollbar.dragSize, 10), n.isHorizontal() ? P.style.width = `${c}px` : P.style.height = `${c}px`, u >= 1 ? T.style.display = "none" : T.style.display = "", n.params.scrollbar.hide && (T.style.opacity = 0), n.params.watchOverflow && n.enabled && S.el.classList[n.isLocked ? "add" : "remove"](n.params.scrollbar.lockClass) } function h(S) { return n.isHorizontal() ? S.clientX : S.clientY } function b(S) { const { scrollbar: P, rtlTranslate: T } = n, { el: I } = P; let H; H = (h(S) - Jt(I)[n.isHorizontal() ? "left" : "top"] - (l !== null ? l : c / 2)) / (d - c), H = Math.max(Math.min(H, 1), 0), T && (H = 1 - H); const D = n.minTranslate() + (n.maxTranslate() - n.minTranslate()) * H; n.updateProgress(D), n.setTranslate(D), n.updateActiveIndex(), n.updateSlidesClasses() } function g(S) { const P = n.params.scrollbar, { scrollbar: T, wrapperEl: I } = n, { el: H, dragEl: D } = T; r = !0, l = S.target === D ? h(S) - S.target.getBoundingClientRect()[n.isHorizontal() ? "left" : "top"] : null, S.preventDefault(), S.stopPropagation(), I.style.transitionDuration = "100ms", D.style.transitionDuration = "100ms", b(S), clearTimeout(o), H.style.transitionDuration = "0ms", P.hide && (H.style.opacity = 1), n.params.cssMode && (n.wrapperEl.style["scroll-snap-type"] = "none"), a("scrollbarDragStart", S) } function v(S) { const { scrollbar: P, wrapperEl: T } = n, { el: I, dragEl: H } = P; r && (S.preventDefault ? S.preventDefault() : S.returnValue = !1, b(S), T.style.transitionDuration = "0ms", I.style.transitionDuration = "0ms", H.style.transitionDuration = "0ms", a("scrollbarDragMove", S)) } function E(S) { const P = n.params.scrollbar, { scrollbar: T, wrapperEl: I } = n, { el: H } = T; r && (r = !1, n.params.cssMode && (n.wrapperEl.style["scroll-snap-type"] = "", I.style.transitionDuration = ""), P.hide && (clearTimeout(o), o = pt(() => { H.style.opacity = 0, H.style.transitionDuration = "400ms" }, 1e3)), a("scrollbarDragEnd", S), P.snapOnRelease && n.slideToClosest()) } function $(S) { const { scrollbar: P, params: T } = n, I = P.el; if (!I) return; const H = I, D = T.passiveListeners ? { passive: !1, capture: !1 } : !1, z = T.passiveListeners ? { passive: !0, capture: !1 } : !1; if (!H) return; const B = S === "on" ? "addEventListener" : "removeEventListener"; H[B]("pointerdown", g, D), s[B]("pointermove", v, D), s[B]("pointerup", E, z) } function w() { !n.params.scrollbar.el || !n.scrollbar.el || $("on") } function C() { !n.params.scrollbar.el || !n.scrollbar.el || $("off") } function k() { const { scrollbar: S, el: P } = n; n.params.scrollbar = _a(n, n.originalParams.scrollbar, n.params.scrollbar, { el: "swiper-scrollbar" }); const T = n.params.scrollbar; if (!T.el) return; let I; typeof T.el == "string" && n.isElement && (I = n.el.shadowRoot.querySelector(T.el)), !I && typeof T.el == "string" ? I = s.querySelectorAll(T.el) : I || (I = T.el), n.params.uniqueNavElements && typeof T.el == "string" && I.length > 1 && P.querySelectorAll(T.el).length === 1 && (I = P.querySelector(T.el)), I.length > 0 && (I = I[0]), I.classList.add(n.isHorizontal() ? T.horizontalClass : T.verticalClass); let H; I && (H = I.querySelector(`.${n.params.scrollbar.dragClass}`), H || (H = ze("div", n.params.scrollbar.dragClass), I.append(H))), Object.assign(S, { el: I, dragEl: H }), T.draggable && w(), I && I.classList[n.enabled ? "remove" : "add"](n.params.scrollbar.lockClass) } function M() { const S = n.params.scrollbar, P = n.scrollbar.el; P && P.classList.remove(n.isHorizontal() ? S.horizontalClass : S.verticalClass), C() } t("init", () => { n.params.scrollbar.enabled === !1 ? O() : (k(), f(), p()) }), t("update resize observerUpdate lock unlock", () => { f() }), t("setTranslate", () => { p() }), t("setTransition", (S, P) => { m(P) }), t("enable disable", () => { const { el: S } = n.scrollbar; S && S.classList[n.enabled ? "remove" : "add"](n.params.scrollbar.lockClass) }), t("destroy", () => { M() }); const A = () => { n.el.classList.remove(n.params.scrollbar.scrollbarDisabledClass), n.scrollbar.el && n.scrollbar.el.classList.remove(n.params.scrollbar.scrollbarDisabledClass), k(), f(), p() }, O = () => { n.el.classList.add(n.params.scrollbar.scrollbarDisabledClass), n.scrollbar.el && n.scrollbar.el.classList.add(n.params.scrollbar.scrollbarDisabledClass), M() }; Object.assign(n.scrollbar, { enable: A, disable: O, updateSize: f, setTranslate: p, init: k, destroy: M }) } function Hd({ swiper: n, extendParams: e, on: t }) { e({ parallax: { enabled: !1 } }); const a = (i, o) => { const { rtl: l } = n, c = l ? -1 : 1, d = i.getAttribute("data-swiper-parallax") || "0"; let u = i.getAttribute("data-swiper-parallax-x"), p = i.getAttribute("data-swiper-parallax-y"); const m = i.getAttribute("data-swiper-parallax-scale"), f = i.getAttribute("data-swiper-parallax-opacity"), h = i.getAttribute("data-swiper-parallax-rotate"); if (u || p ? (u = u || "0", p = p || "0") : n.isHorizontal() ? (u = d, p = "0") : (p = d, u = "0"), u.indexOf("%") >= 0 ? u = `${parseInt(u, 10) * o * c}%` : u = `${u * o * c}px`, p.indexOf("%") >= 0 ? p = `${parseInt(p, 10) * o}%` : p = `${p * o}px`, typeof f < "u" && f !== null) { const g = f - (f - 1) * (1 - Math.abs(o)); i.style.opacity = g } let b = `translate3d(${u}, ${p}, 0px)`; if (typeof m < "u" && m !== null) { const g = m - (m - 1) * (1 - Math.abs(o)); b += ` scale(${g})` } if (h && typeof h < "u" && h !== null) { const g = h * o * -1; b += ` rotate(${g}deg)` } i.style.transform = b }, s = () => { const { el: i, slides: o, progress: l, snapGrid: c } = n; ke(i, "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach(d => { a(d, l) }), o.forEach((d, u) => { let p = d.progress; n.params.slidesPerGroup > 1 && n.params.slidesPerView !== "auto" && (p += Math.ceil(u / 2) - l * (c.length - 1)), p = Math.min(Math.max(p, -1), 1), d.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]").forEach(m => { a(m, p) }) }) }, r = (i = n.params.speed) => { const { el: o } = n; o.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach(l => { let c = parseInt(l.getAttribute("data-swiper-parallax-duration"), 10) || i; i === 0 && (c = 0), l.style.transitionDuration = `${c}ms` }) }; t("beforeInit", () => { n.params.parallax.enabled && (n.params.watchSlidesProgress = !0, n.originalParams.watchSlidesProgress = !0) }), t("init", () => { n.params.parallax.enabled && s() }), t("setTranslate", () => { n.params.parallax.enabled && s() }), t("setTransition", (i, o) => { n.params.parallax.enabled && r(o) }) } function zd({ swiper: n, extendParams: e, on: t, emit: a }) { const s = U(); e({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), n.zoom = { enabled: !1 }; let r = 1, i = !1, o, l; const c = [], d = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, u = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, p = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let m = 1; Object.defineProperty(n.zoom, "scale", { get() { return m }, set(D) { if (m !== D) { const z = d.imageEl, B = d.slideEl; a("zoomChange", D, z, B) } m = D } }); function f() { if (c.length < 2) return 1; const D = c[0].pageX, z = c[0].pageY, B = c[1].pageX, L = c[1].pageY; return Math.sqrt((B - D) ** 2 + (L - z) ** 2) } function h() { if (c.length < 2) return { x: null, y: null }; const D = d.imageEl.getBoundingClientRect(); return [(c[0].pageX + (c[1].pageX - c[0].pageX) / 2 - D.x) / r, (c[0].pageY + (c[1].pageY - c[0].pageY) / 2 - D.y) / r] } function b() { return n.isElement ? "swiper-slide" : `.${n.params.slideClass}` } function g(D) { const z = b(); return !!(D.target.matches(z) || n.slides.filter(B => B.contains(D.target)).length > 0) } function v(D) { const z = `.${n.params.zoom.containerClass}`; return !!(D.target.matches(z) || [...n.el.querySelectorAll(z)].filter(B => B.contains(D.target)).length > 0) } function E(D) { if (D.pointerType === "mouse" && c.splice(0, c.length), !g(D)) return; const z = n.params.zoom; if (o = !1, l = !1, c.push(D), !(c.length < 2)) { if (o = !0, d.scaleStart = f(), !d.slideEl) { d.slideEl = D.target.closest(`.${n.params.slideClass}, swiper-slide`), d.slideEl || (d.slideEl = n.slides[n.activeIndex]); let B = d.slideEl.querySelector(`.${z.containerClass}`); if (B && (B = B.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = B, B ? d.imageWrapEl = ut(d.imageEl, `.${z.containerClass}`)[0] : d.imageWrapEl = void 0, !d.imageWrapEl) { d.imageEl = void 0; return } d.maxRatio = d.imageWrapEl.getAttribute("data-swiper-zoom") || z.maxRatio } if (d.imageEl) { const [B, L] = h(); d.originX = B, d.originY = L, d.imageEl.style.transitionDuration = "0ms" } i = !0 } } function $(D) { if (!g(D)) return; const z = n.params.zoom, B = n.zoom, L = c.findIndex(N => N.pointerId === D.pointerId); L >= 0 && (c[L] = D), !(c.length < 2) && (l = !0, d.scaleMove = f(), d.imageEl && (B.scale = d.scaleMove / d.scaleStart * r, B.scale > d.maxRatio && (B.scale = d.maxRatio - 1 + (B.scale - d.maxRatio + 1) ** .5), B.scale < z.minRatio && (B.scale = z.minRatio + 1 - (z.minRatio - B.scale + 1) ** .5), d.imageEl.style.transform = `translate3d(0,0,0) scale(${B.scale})`)) } function w(D) { if (!g(D) || D.pointerType === "mouse" && D.type === "pointerout") return; const z = n.params.zoom, B = n.zoom, L = c.findIndex(N => N.pointerId === D.pointerId); L >= 0 && c.splice(L, 1), !(!o || !l) && (o = !1, l = !1, d.imageEl && (B.scale = Math.max(Math.min(B.scale, d.maxRatio), z.minRatio), d.imageEl.style.transitionDuration = `${n.params.speed}ms`, d.imageEl.style.transform = `translate3d(0,0,0) scale(${B.scale})`, r = B.scale, i = !1, B.scale > 1 && d.slideEl ? d.slideEl.classList.add(`${z.zoomedSlideClass}`) : B.scale <= 1 && d.slideEl && d.slideEl.classList.remove(`${z.zoomedSlideClass}`), B.scale === 1 && (d.originX = 0, d.originY = 0, d.slideEl = void 0))) } function C(D) { const z = n.device; if (!d.imageEl || u.isTouched) return; z.android && D.cancelable && D.preventDefault(), u.isTouched = !0; const B = c.length > 0 ? c[0] : D; u.touchesStart.x = B.pageX, u.touchesStart.y = B.pageY } function k(D) { if (!g(D) || !v(D)) return; const z = n.zoom; if (!d.imageEl || !u.isTouched || !d.slideEl) return; u.isMoved || (u.width = d.imageEl.offsetWidth, u.height = d.imageEl.offsetHeight, u.startX = Ra(d.imageWrapEl, "x") || 0, u.startY = Ra(d.imageWrapEl, "y") || 0, d.slideWidth = d.slideEl.offsetWidth, d.slideHeight = d.slideEl.offsetHeight, d.imageWrapEl.style.transitionDuration = "0ms"); const B = u.width * z.scale, L = u.height * z.scale; if (B < d.slideWidth && L < d.slideHeight) return; if (u.minX = Math.min(d.slideWidth / 2 - B / 2, 0), u.maxX = -u.minX, u.minY = Math.min(d.slideHeight / 2 - L / 2, 0), u.maxY = -u.minY, u.touchesCurrent.x = c.length > 0 ? c[0].pageX : D.pageX, u.touchesCurrent.y = c.length > 0 ? c[0].pageY : D.pageY, Math.max(Math.abs(u.touchesCurrent.x - u.touchesStart.x), Math.abs(u.touchesCurrent.y - u.touchesStart.y)) > 5 && (n.allowClick = !1), !u.isMoved && !i) { if (n.isHorizontal() && (Math.floor(u.minX) === Math.floor(u.startX) && u.touchesCurrent.x < u.touchesStart.x || Math.floor(u.maxX) === Math.floor(u.startX) && u.touchesCurrent.x > u.touchesStart.x)) { u.isTouched = !1; return } if (!n.isHorizontal() && (Math.floor(u.minY) === Math.floor(u.startY) && u.touchesCurrent.y < u.touchesStart.y || Math.floor(u.maxY) === Math.floor(u.startY) && u.touchesCurrent.y > u.touchesStart.y)) { u.isTouched = !1; return } } D.cancelable && D.preventDefault(), D.stopPropagation(), u.isMoved = !0; const F = (z.scale - r) / (d.maxRatio - n.params.zoom.minRatio), { originX: V, originY: _ } = d; u.currentX = u.touchesCurrent.x - u.touchesStart.x + u.startX + F * (u.width - V * 2), u.currentY = u.touchesCurrent.y - u.touchesStart.y + u.startY + F * (u.height - _ * 2), u.currentX < u.minX && (u.currentX = u.minX + 1 - (u.minX - u.currentX + 1) ** .8), u.currentX > u.maxX && (u.currentX = u.maxX - 1 + (u.currentX - u.maxX + 1) ** .8), u.currentY < u.minY && (u.currentY = u.minY + 1 - (u.minY - u.currentY + 1) ** .8), u.currentY > u.maxY && (u.currentY = u.maxY - 1 + (u.currentY - u.maxY + 1) ** .8), p.prevPositionX || (p.prevPositionX = u.touchesCurrent.x), p.prevPositionY || (p.prevPositionY = u.touchesCurrent.y), p.prevTime || (p.prevTime = Date.now()), p.x = (u.touchesCurrent.x - p.prevPositionX) / (Date.now() - p.prevTime) / 2, p.y = (u.touchesCurrent.y - p.prevPositionY) / (Date.now() - p.prevTime) / 2, Math.abs(u.touchesCurrent.x - p.prevPositionX) < 2 && (p.x = 0), Math.abs(u.touchesCurrent.y - p.prevPositionY) < 2 && (p.y = 0), p.prevPositionX = u.touchesCurrent.x, p.prevPositionY = u.touchesCurrent.y, p.prevTime = Date.now(), d.imageWrapEl.style.transform = `translate3d(${u.currentX}px, ${u.currentY}px,0)` } function M() { const D = n.zoom; if (!d.imageEl) return; if (!u.isTouched || !u.isMoved) { u.isTouched = !1, u.isMoved = !1; return } u.isTouched = !1, u.isMoved = !1; let z = 300, B = 300; const L = p.x * z, N = u.currentX + L, F = p.y * B, V = u.currentY + F; p.x !== 0 && (z = Math.abs((N - u.currentX) / p.x)), p.y !== 0 && (B = Math.abs((V - u.currentY) / p.y)); const _ = Math.max(z, B); u.currentX = N, u.currentY = V; const J = u.width * D.scale, Q = u.height * D.scale; u.minX = Math.min(d.slideWidth / 2 - J / 2, 0), u.maxX = -u.minX, u.minY = Math.min(d.slideHeight / 2 - Q / 2, 0), u.maxY = -u.minY, u.currentX = Math.max(Math.min(u.currentX, u.maxX), u.minX), u.currentY = Math.max(Math.min(u.currentY, u.maxY), u.minY), d.imageWrapEl.style.transitionDuration = `${_}ms`, d.imageWrapEl.style.transform = `translate3d(${u.currentX}px, ${u.currentY}px,0)` } function A() { const D = n.zoom; d.slideEl && n.activeIndex !== n.slides.indexOf(d.slideEl) && (d.imageEl && (d.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), d.imageWrapEl && (d.imageWrapEl.style.transform = "translate3d(0,0,0)"), d.slideEl.classList.remove(`${n.params.zoom.zoomedSlideClass}`), D.scale = 1, r = 1, d.slideEl = void 0, d.imageEl = void 0, d.imageWrapEl = void 0, d.originX = 0, d.originY = 0) } function O(D) { const z = n.zoom, B = n.params.zoom; if (!d.slideEl) { D && D.target && (d.slideEl = D.target.closest(`.${n.params.slideClass}, swiper-slide`)), d.slideEl || (n.params.virtual && n.params.virtual.enabled && n.virtual ? d.slideEl = ke(n.slidesEl, `.${n.params.slideActiveClass}`)[0] : d.slideEl = n.slides[n.activeIndex]); let de = d.slideEl.querySelector(`.${B.containerClass}`); de && (de = de.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = de, de ? d.imageWrapEl = ut(d.imageEl, `.${B.containerClass}`)[0] : d.imageWrapEl = void 0 } if (!d.imageEl || !d.imageWrapEl) return; n.params.cssMode && (n.wrapperEl.style.overflow = "hidden", n.wrapperEl.style.touchAction = "none"), d.slideEl.classList.add(`${B.zoomedSlideClass}`); let L, N, F, V, _, J, Q, j, Y, X, K, W, G, Z, ie, ge, te, le; typeof u.touchesStart.x > "u" && D ? (L = D.pageX, N = D.pageY) : (L = u.touchesStart.x, N = u.touchesStart.y); const ce = typeof D == "number" ? D : null; r === 1 && ce && (L = void 0, N = void 0), z.scale = ce || d.imageWrapEl.getAttribute("data-swiper-zoom") || B.maxRatio, r = ce || d.imageWrapEl.getAttribute("data-swiper-zoom") || B.maxRatio, D && !(r === 1 && ce) ? (te = d.slideEl.offsetWidth, le = d.slideEl.offsetHeight, F = Jt(d.slideEl).left + s.scrollX, V = Jt(d.slideEl).top + s.scrollY, _ = F + te / 2 - L, J = V + le / 2 - N, Y = d.imageEl.offsetWidth, X = d.imageEl.offsetHeight, K = Y * z.scale, W = X * z.scale, G = Math.min(te / 2 - K / 2, 0), Z = Math.min(le / 2 - W / 2, 0), ie = -G, ge = -Z, Q = _ * z.scale, j = J * z.scale, Q < G && (Q = G), Q > ie && (Q = ie), j < Z && (j = Z), j > ge && (j = ge)) : (Q = 0, j = 0), ce && z.scale === 1 && (d.originX = 0, d.originY = 0), d.imageWrapEl.style.transitionDuration = "300ms", d.imageWrapEl.style.transform = `translate3d(${Q}px, ${j}px,0)`, d.imageEl.style.transitionDuration = "300ms", d.imageEl.style.transform = `translate3d(0,0,0) scale(${z.scale})` } function S() { const D = n.zoom, z = n.params.zoom; if (!d.slideEl) { n.params.virtual && n.params.virtual.enabled && n.virtual ? d.slideEl = ke(n.slidesEl, `.${n.params.slideActiveClass}`)[0] : d.slideEl = n.slides[n.activeIndex]; let B = d.slideEl.querySelector(`.${z.containerClass}`); B && (B = B.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = B, B ? d.imageWrapEl = ut(d.imageEl, `.${z.containerClass}`)[0] : d.imageWrapEl = void 0 } !d.imageEl || !d.imageWrapEl || (n.params.cssMode && (n.wrapperEl.style.overflow = "", n.wrapperEl.style.touchAction = ""), D.scale = 1, r = 1, d.imageWrapEl.style.transitionDuration = "300ms", d.imageWrapEl.style.transform = "translate3d(0,0,0)", d.imageEl.style.transitionDuration = "300ms", d.imageEl.style.transform = "translate3d(0,0,0) scale(1)", d.slideEl.classList.remove(`${z.zoomedSlideClass}`), d.slideEl = void 0, d.originX = 0, d.originY = 0) } function P(D) { const z = n.zoom; z.scale && z.scale !== 1 ? S() : O(D) } function T() { const D = n.params.passiveListeners ? { passive: !0, capture: !1 } : !1, z = n.params.passiveListeners ? { passive: !1, capture: !0 } : !0; return { passiveListener: D, activeListenerWithCapture: z } } function I() { const D = n.zoom; if (D.enabled) return; D.enabled = !0; const { passiveListener: z, activeListenerWithCapture: B } = T(); n.wrapperEl.addEventListener("pointerdown", E, z), n.wrapperEl.addEventListener("pointermove", $, B), ["pointerup", "pointercancel", "pointerout"].forEach(L => { n.wrapperEl.addEventListener(L, w, z) }), n.wrapperEl.addEventListener("pointermove", k, B) } function H() { const D = n.zoom; if (!D.enabled) return; D.enabled = !1; const { passiveListener: z, activeListenerWithCapture: B } = T(); n.wrapperEl.removeEventListener("pointerdown", E, z), n.wrapperEl.removeEventListener("pointermove", $, B), ["pointerup", "pointercancel", "pointerout"].forEach(L => { n.wrapperEl.removeEventListener(L, w, z) }), n.wrapperEl.removeEventListener("pointermove", k, B) } t("init", () => { n.params.zoom.enabled && I() }), t("destroy", () => { H() }), t("touchStart", (D, z) => { n.zoom.enabled && C(z) }), t("touchEnd", (D, z) => { n.zoom.enabled && M(z) }), t("doubleTap", (D, z) => { !n.animating && n.params.zoom.enabled && n.zoom.enabled && n.params.zoom.toggle && P(z) }), t("transitionEnd", () => { n.zoom.enabled && n.params.zoom.enabled && A() }), t("slideChange", () => { n.zoom.enabled && n.params.zoom.enabled && n.params.cssMode && A() }), Object.assign(n.zoom, { enable: I, disable: H, in: O, out: S, toggle: P }) } function Fd({ swiper: n, extendParams: e, on: t }) { e({ controller: { control: void 0, inverse: !1, by: "slide" } }), n.controller = { control: void 0 }; function a(l, c) { const d = function () { let f, h, b; return (g, v) => { for (h = -1, f = g.length; f - h > 1;)b = f + h >> 1, g[b] <= v ? h = b : f = b; return f } }(); this.x = l, this.y = c, this.lastIndex = l.length - 1; let u, p; return this.interpolate = function (f) { return f ? (p = d(this.x, f), u = p - 1, (f - this.x[u]) * (this.y[p] - this.y[u]) / (this.x[p] - this.x[u]) + this.y[u]) : 0 }, this } function s(l) { n.controller.spline = n.params.loop ? new a(n.slidesGrid, l.slidesGrid) : new a(n.snapGrid, l.snapGrid) } function r(l, c) { const d = n.controller.control; let u, p; const m = n.constructor; function f(h) { if (h.destroyed) return; const b = n.rtlTranslate ? -n.translate : n.translate; n.params.controller.by === "slide" && (s(h), p = -n.controller.spline.interpolate(-b)), (!p || n.params.controller.by === "container") && (u = (h.maxTranslate() - h.minTranslate()) / (n.maxTranslate() - n.minTranslate()), (Number.isNaN(u) || !Number.isFinite(u)) && (u = 1), p = (b - n.minTranslate()) * u + h.minTranslate()), n.params.controller.inverse && (p = h.maxTranslate() - p), h.updateProgress(p), h.setTranslate(p, n), h.updateActiveIndex(), h.updateSlidesClasses() } if (Array.isArray(d)) for (let h = 0; h < d.length; h += 1)d[h] !== c && d[h] instanceof m && f(d[h]); else d instanceof m && c !== d && f(d) } function i(l, c) { const d = n.constructor, u = n.controller.control; let p; function m(f) { f.destroyed || (f.setTransition(l, n), l !== 0 && (f.transitionStart(), f.params.autoHeight && pt(() => { f.updateAutoHeight() }), Ot(f.wrapperEl, () => { u && f.transitionEnd() }))) } if (Array.isArray(u)) for (p = 0; p < u.length; p += 1)u[p] !== c && u[p] instanceof d && m(u[p]); else u instanceof d && c !== u && m(u) } function o() { n.controller.control && n.controller.spline && (n.controller.spline = void 0, delete n.controller.spline) } t("beforeInit", () => { if (typeof window < "u" && (typeof n.params.controller.control == "string" || n.params.controller.control instanceof HTMLElement)) { const l = document.querySelector(n.params.controller.control); if (l && l.swiper) n.controller.control = l.swiper; else if (l) { const c = d => { n.controller.control = d.detail[0], n.update(), l.removeEventListener("init", c) }; l.addEventListener("init", c) } return } n.controller.control = n.params.controller.control }), t("update", () => { o() }), t("resize", () => { o() }), t("observerUpdate", () => { o() }), t("setTranslate", (l, c, d) => { !n.controller.control || n.controller.control.destroyed || n.controller.setTranslate(c, d) }), t("setTransition", (l, c, d) => { !n.controller.control || n.controller.control.destroyed || n.controller.setTransition(c, d) }), Object.assign(n.controller, { setTranslate: r, setTransition: i }) } function Vd({ swiper: n, extendParams: e, on: t }) { e({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), n.a11y = { clicked: !1 }; let a = null; function s(T) { const I = a; I.length !== 0 && (I.innerHTML = "", I.innerHTML = T) } const r = T => (Array.isArray(T) || (T = [T].filter(I => !!I)), T); function i(T = 16) { const I = () => Math.round(16 * Math.random()).toString(16); return "x".repeat(T).replace(/x/g, I) } function o(T) { T = r(T), T.forEach(I => { I.setAttribute("tabIndex", "0") }) } function l(T) { T = r(T), T.forEach(I => { I.setAttribute("tabIndex", "-1") }) } function c(T, I) { T = r(T), T.forEach(H => { H.setAttribute("role", I) }) } function d(T, I) { T = r(T), T.forEach(H => { H.setAttribute("aria-roledescription", I) }) } function u(T, I) { T = r(T), T.forEach(H => { H.setAttribute("aria-controls", I) }) } function p(T, I) { T = r(T), T.forEach(H => { H.setAttribute("aria-label", I) }) } function m(T, I) { T = r(T), T.forEach(H => { H.setAttribute("id", I) }) } function f(T, I) { T = r(T), T.forEach(H => { H.setAttribute("aria-live", I) }) } function h(T) { T = r(T), T.forEach(I => { I.setAttribute("aria-disabled", !0) }) } function b(T) { T = r(T), T.forEach(I => { I.setAttribute("aria-disabled", !1) }) } function g(T) { if (T.keyCode !== 13 && T.keyCode !== 32) return; const I = n.params.a11y, H = T.target; n.pagination && n.pagination.el && (H === n.pagination.el || n.pagination.el.contains(T.target)) && !T.target.matches(at(n.params.pagination.bulletClass)) || (n.navigation && n.navigation.nextEl && H === n.navigation.nextEl && (n.isEnd && !n.params.loop || n.slideNext(), n.isEnd ? s(I.lastSlideMessage) : s(I.nextSlideMessage)), n.navigation && n.navigation.prevEl && H === n.navigation.prevEl && (n.isBeginning && !n.params.loop || n.slidePrev(), n.isBeginning ? s(I.firstSlideMessage) : s(I.prevSlideMessage)), n.pagination && H.matches(at(n.params.pagination.bulletClass)) && H.click()) } function v() { if (n.params.loop || n.params.rewind || !n.navigation) return; const { nextEl: T, prevEl: I } = n.navigation; I && (n.isBeginning ? (h(I), l(I)) : (b(I), o(I))), T && (n.isEnd ? (h(T), l(T)) : (b(T), o(T))) } function E() { return n.pagination && n.pagination.bullets && n.pagination.bullets.length } function $() { return E() && n.params.pagination.clickable } function w() { const T = n.params.a11y; E() && n.pagination.bullets.forEach(I => { n.params.pagination.clickable && (o(I), n.params.pagination.renderBullet || (c(I, "button"), p(I, T.paginationBulletMessage.replace(/\{\{index\}\}/, Dt(I) + 1)))), I.matches(at(n.params.pagination.bulletActiveClass)) ? I.setAttribute("aria-current", "true") : I.removeAttribute("aria-current") }) } const C = (T, I, H) => { o(T), T.tagName !== "BUTTON" && (c(T, "button"), T.addEventListener("keydown", g)), p(T, H), u(T, I) }, k = () => { n.a11y.clicked = !0 }, M = () => { requestAnimationFrame(() => { requestAnimationFrame(() => { n.destroyed || (n.a11y.clicked = !1) }) }) }, A = T => { if (n.a11y.clicked) return; const I = T.target.closest(`.${n.params.slideClass}, swiper-slide`); if (!I || !n.slides.includes(I)) return; const H = n.slides.indexOf(I) === n.activeIndex, D = n.params.watchSlidesProgress && n.visibleSlides && n.visibleSlides.includes(I); H || D || T.sourceCapabilities && T.sourceCapabilities.firesTouchEvents || (n.isHorizontal() ? n.el.scrollLeft = 0 : n.el.scrollTop = 0, n.slideTo(n.slides.indexOf(I), 0)) }, O = () => { const T = n.params.a11y; T.itemRoleDescriptionMessage && d(n.slides, T.itemRoleDescriptionMessage), T.slideRole && c(n.slides, T.slideRole); const I = n.slides.length; T.slideLabelMessage && n.slides.forEach((H, D) => { const z = n.params.loop ? parseInt(H.getAttribute("data-swiper-slide-index"), 10) : D, B = T.slideLabelMessage.replace(/\{\{index\}\}/, z + 1).replace(/\{\{slidesLength\}\}/, I); p(H, B) }) }, S = () => { const T = n.params.a11y; n.el.append(a); const I = n.el; T.containerRoleDescriptionMessage && d(I, T.containerRoleDescriptionMessage), T.containerMessage && p(I, T.containerMessage); const H = n.wrapperEl, D = T.id || H.getAttribute("id") || `swiper-wrapper-${i(16)}`, z = n.params.autoplay && n.params.autoplay.enabled ? "off" : "polite"; m(H, D), f(H, z), O(); let { nextEl: B, prevEl: L } = n.navigation ? n.navigation : {}; B = r(B), L = r(L), B && B.forEach(N => C(N, D, T.nextSlideMessage)), L && L.forEach(N => C(N, D, T.prevSlideMessage)), $() && (Array.isArray(n.pagination.el) ? n.pagination.el : [n.pagination.el]).forEach(F => { F.addEventListener("keydown", g) }), n.el.addEventListener("focus", A, !0), n.el.addEventListener("pointerdown", k, !0), n.el.addEventListener("pointerup", M, !0) }; function P() { a && a.length > 0 && a.remove(); let { nextEl: T, prevEl: I } = n.navigation ? n.navigation : {}; T = r(T), I = r(I), T && T.forEach(H => H.removeEventListener("keydown", g)), I && I.forEach(H => H.removeEventListener("keydown", g)), $() && (Array.isArray(n.pagination.el) ? n.pagination.el : [n.pagination.el]).forEach(D => { D.removeEventListener("keydown", g) }), n.el.removeEventListener("focus", A, !0), n.el.removeEventListener("pointerdown", k, !0), n.el.removeEventListener("pointerup", M, !0) } t("beforeInit", () => { a = ze("span", n.params.a11y.notificationClass), a.setAttribute("aria-live", "assertive"), a.setAttribute("aria-atomic", "true"), n.isElement && a.setAttribute("slot", "container-end") }), t("afterInit", () => { n.params.a11y.enabled && S() }), t("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { n.params.a11y.enabled && O() }), t("fromEdge toEdge afterInit lock unlock", () => { n.params.a11y.enabled && v() }), t("paginationUpdate", () => { n.params.a11y.enabled && w() }), t("destroy", () => { n.params.a11y.enabled && P() }) } function Nd({ swiper: n, extendParams: e, on: t }) { e({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let a = !1, s = {}; const r = p => p.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), i = p => { const m = U(); let f; p ? f = new URL(p) : f = m.location; const h = f.pathname.slice(1).split("/").filter(E => E !== ""), b = h.length, g = h[b - 2], v = h[b - 1]; return { key: g, value: v } }, o = (p, m) => { const f = U(); if (!a || !n.params.history.enabled) return; let h; n.params.url ? h = new URL(n.params.url) : h = f.location; const b = n.slides[m]; let g = r(b.getAttribute("data-history")); if (n.params.history.root.length > 0) { let E = n.params.history.root; E[E.length - 1] === "/" && (E = E.slice(0, E.length - 1)), g = `${E}/${p ? `${p}/` : ""}${g}` } else h.pathname.includes(p) || (g = `${p ? `${p}/` : ""}${g}`); n.params.history.keepQuery && (g += h.search); const v = f.history.state; v && v.value === g || (n.params.history.replaceState ? f.history.replaceState({ value: g }, null, g) : f.history.pushState({ value: g }, null, g)) }, l = (p, m, f) => { if (m) for (let h = 0, b = n.slides.length; h < b; h += 1) { const g = n.slides[h]; if (r(g.getAttribute("data-history")) === m) { const E = n.getSlideIndex(g); n.slideTo(E, p, f) } } else n.slideTo(0, p, f) }, c = () => { s = i(n.params.url), l(n.params.speed, s.value, !1) }, d = () => { const p = U(); if (n.params.history) { if (!p.history || !p.history.pushState) { n.params.history.enabled = !1, n.params.hashNavigation.enabled = !0; return } if (a = !0, s = i(n.params.url), !s.key && !s.value) { n.params.history.replaceState || p.addEventListener("popstate", c); return } l(0, s.value, n.params.runCallbacksOnInit), n.params.history.replaceState || p.addEventListener("popstate", c) } }, u = () => { const p = U(); n.params.history.replaceState || p.removeEventListener("popstate", c) }; t("init", () => { n.params.history.enabled && d() }), t("destroy", () => { n.params.history.enabled && u() }), t("transitionEnd _freeModeNoMomentumRelease", () => { a && o(n.params.history.key, n.activeIndex) }), t("slideChange", () => { a && n.params.cssMode && o(n.params.history.key, n.activeIndex) }) } function Yd({ swiper: n, extendParams: e, emit: t, on: a }) { let s = !1; const r = ee(), i = U(); e({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(u, p) { if (n.virtual && n.params.virtual.enabled) { const m = n.slides.filter(h => h.getAttribute("data-hash") === p)[0]; return m ? parseInt(m.getAttribute("data-swiper-slide-index"), 10) : 0 } return n.getSlideIndex(ke(n.slidesEl, `.${n.params.slideClass}[data-hash="${p}"], swiper-slide[data-hash="${p}"]`)[0]) } } }); const o = () => { t("hashChange"); const u = r.location.hash.replace("#", ""), p = n.slidesEl.querySelector(`[data-swiper-slide-index="${n.activeIndex}"]`), m = p ? p.getAttribute("data-hash") : ""; if (u !== m) { const f = n.params.hashNavigation.getSlideIndex(n, u); if (console.log(f), typeof f > "u") return; n.slideTo(f) } }, l = () => { if (!s || !n.params.hashNavigation.enabled) return; const u = n.slidesEl.querySelector(`[data-swiper-slide-index="${n.activeIndex}"]`), p = u ? u.getAttribute("data-hash") || u.getAttribute("data-history") : ""; n.params.hashNavigation.replaceState && i.history && i.history.replaceState ? (i.history.replaceState(null, null, `#${p}` || ""), t("hashSet")) : (r.location.hash = p || "", t("hashSet")) }, c = () => { if (!n.params.hashNavigation.enabled || n.params.history && n.params.history.enabled) return; s = !0; const u = r.location.hash.replace("#", ""); if (u) { const m = n.params.hashNavigation.getSlideIndex(n, u); n.slideTo(m || 0, 0, n.params.runCallbacksOnInit, !0) } n.params.hashNavigation.watchState && i.addEventListener("hashchange", o) }, d = () => { n.params.hashNavigation.watchState && i.removeEventListener("hashchange", o) }; a("init", () => { n.params.hashNavigation.enabled && c() }), a("destroy", () => { n.params.hashNavigation.enabled && d() }), a("transitionEnd _freeModeNoMomentumRelease", () => { s && l() }), a("slideChange", () => { s && n.params.cssMode && l() }) } function qd({ swiper: n, extendParams: e, on: t, emit: a, params: s }) { n.autoplay = { running: !1, paused: !1, timeLeft: 0 }, e({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let r, i, o = s && s.autoplay ? s.autoplay.delay : 3e3, l = s && s.autoplay ? s.autoplay.delay : 3e3, c, d = new Date().getTime, u, p, m, f, h, b; function g(D) { !n || n.destroyed || !n.wrapperEl || D.target === n.wrapperEl && (n.wrapperEl.removeEventListener("transitionend", g), M()) } const v = () => { if (n.destroyed || !n.autoplay.running) return; n.autoplay.paused ? u = !0 : u && (l = c, u = !1); const D = n.autoplay.paused ? c : d + l - new Date().getTime(); n.autoplay.timeLeft = D, a("autoplayTimeLeft", D, D / o), i = requestAnimationFrame(() => { v() }) }, E = () => { let D; return n.virtual && n.params.virtual.enabled ? D = n.slides.filter(B => B.classList.contains("swiper-slide-active"))[0] : D = n.slides[n.activeIndex], D ? parseInt(D.getAttribute("data-swiper-autoplay"), 10) : void 0 }, $ = D => { if (n.destroyed || !n.autoplay.running) return; cancelAnimationFrame(i), v(); let z = typeof D > "u" ? n.params.autoplay.delay : D; o = n.params.autoplay.delay, l = n.params.autoplay.delay; const B = E(); !Number.isNaN(B) && B > 0 && typeof D > "u" && (z = B, o = B, l = B), c = z; const L = n.params.speed, N = () => { !n || n.destroyed || (n.params.autoplay.reverseDirection ? !n.isBeginning || n.params.loop || n.params.rewind ? (n.slidePrev(L, !0, !0), a("autoplay")) : n.params.autoplay.stopOnLastSlide || (n.slideTo(n.slides.length - 1, L, !0, !0), a("autoplay")) : !n.isEnd || n.params.loop || n.params.rewind ? (n.slideNext(L, !0, !0), a("autoplay")) : n.params.autoplay.stopOnLastSlide || (n.slideTo(0, L, !0, !0), a("autoplay")), n.params.cssMode && (d = new Date().getTime(), requestAnimationFrame(() => { $() }))) }; return z > 0 ? (clearTimeout(r), r = setTimeout(() => { N() }, z)) : requestAnimationFrame(() => { N() }), z }, w = () => { n.autoplay.running = !0, $(), a("autoplayStart") }, C = () => { n.autoplay.running = !1, clearTimeout(r), cancelAnimationFrame(i), a("autoplayStop") }, k = (D, z) => { if (n.destroyed || !n.autoplay.running) return; clearTimeout(r), D || (b = !0); const B = () => { a("autoplayPause"), n.params.autoplay.waitForTransition ? n.wrapperEl.addEventListener("transitionend", g) : M() }; if (n.autoplay.paused = !0, z) { h && (c = n.params.autoplay.delay), h = !1, B(); return } c = (c || n.params.autoplay.delay) - (new Date().getTime() - d), !(n.isEnd && c < 0 && !n.params.loop) && (c < 0 && (c = 0), B()) }, M = () => { n.isEnd && c < 0 && !n.params.loop || n.destroyed || !n.autoplay.running || (d = new Date().getTime(), b ? (b = !1, $(c)) : $(), n.autoplay.paused = !1, a("autoplayResume")) }, A = () => { if (n.destroyed || !n.autoplay.running) return; const D = ee(); D.visibilityState === "hidden" && (b = !0, k(!0)), D.visibilityState === "visible" && M() }, O = D => { D.pointerType === "mouse" && (b = !0, k(!0)) }, S = D => { D.pointerType === "mouse" && n.autoplay.paused && M() }, P = () => { n.params.autoplay.pauseOnMouseEnter && (n.el.addEventListener("pointerenter", O), n.el.addEventListener("pointerleave", S)) }, T = () => { n.el.removeEventListener("pointerenter", O), n.el.removeEventListener("pointerleave", S) }, I = () => { ee().addEventListener("visibilitychange", A) }, H = () => { ee().removeEventListener("visibilitychange", A) }; t("init", () => { n.params.autoplay.enabled && (P(), I(), d = new Date().getTime(), w()) }), t("destroy", () => { T(), H(), n.autoplay.running && C() }), t("beforeTransitionStart", (D, z, B) => { n.destroyed || !n.autoplay.running || (B || !n.params.autoplay.disableOnInteraction ? k(!0, !0) : C()) }), t("sliderFirstMove", () => { if (!(n.destroyed || !n.autoplay.running)) { if (n.params.autoplay.disableOnInteraction) { C(); return } p = !0, m = !1, b = !1, f = setTimeout(() => { b = !0, m = !0, k(!0) }, 200) } }), t("touchEnd", () => { if (!(n.destroyed || !n.autoplay.running || !p)) { if (clearTimeout(f), clearTimeout(r), n.params.autoplay.disableOnInteraction) { m = !1, p = !1; return } m && n.params.cssMode && M(), m = !1, p = !1 } }), t("slideChange", () => { n.destroyed || !n.autoplay.running || (h = !0) }), Object.assign(n.autoplay, { start: w, stop: C, pause: k, resume: M }) } function jd({ swiper: n, extendParams: e, on: t }) { e({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let a = !1, s = !1; n.thumbs = { swiper: null }; function r() { const l = n.thumbs.swiper; if (!l || l.destroyed) return; const c = l.clickedIndex, d = l.clickedSlide; if (d && d.classList.contains(n.params.thumbs.slideThumbActiveClass) || typeof c > "u" || c === null) return; let u; l.params.loop ? u = parseInt(l.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : u = c, n.params.loop ? n.slideToLoop(u) : n.slideTo(u) } function i() { const { thumbs: l } = n.params; if (a) return !1; a = !0; const c = n.constructor; if (l.swiper instanceof c) n.thumbs.swiper = l.swiper, Object.assign(n.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(n.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), n.thumbs.swiper.update(); else if (At(l.swiper)) { const d = Object.assign({}, l.swiper); Object.assign(d, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), n.thumbs.swiper = new c(d), s = !0 } return n.thumbs.swiper.el.classList.add(n.params.thumbs.thumbsContainerClass), n.thumbs.swiper.on("tap", r), !0 } function o(l) { const c = n.thumbs.swiper; if (!c || c.destroyed) return; const d = c.params.slidesPerView === "auto" ? c.slidesPerViewDynamic() : c.params.slidesPerView; let u = 1; const p = n.params.thumbs.slideThumbActiveClass; if (n.params.slidesPerView > 1 && !n.params.centeredSlides && (u = n.params.slidesPerView), n.params.thumbs.multipleActiveThumbs || (u = 1), u = Math.floor(u), c.slides.forEach(h => h.classList.remove(p)), c.params.loop || c.params.virtual && c.params.virtual.enabled) for (let h = 0; h < u; h += 1)ke(c.slidesEl, `[data-swiper-slide-index="${n.realIndex + h}"]`).forEach(b => { b.classList.add(p) }); else for (let h = 0; h < u; h += 1)c.slides[n.realIndex + h] && c.slides[n.realIndex + h].classList.add(p); const m = n.params.thumbs.autoScrollOffset, f = m && !c.params.loop; if (n.realIndex !== c.realIndex || f) { const h = c.activeIndex; let b, g; if (c.params.loop) { const v = c.slides.filter(E => E.getAttribute("data-swiper-slide-index") === `${n.realIndex}`)[0]; b = c.slides.indexOf(v), g = n.activeIndex > n.previousIndex ? "next" : "prev" } else b = n.realIndex, g = b > n.previousIndex ? "next" : "prev"; f && (b += g === "next" ? m : -1 * m), c.visibleSlidesIndexes && c.visibleSlidesIndexes.indexOf(b) < 0 && (c.params.centeredSlides ? b > h ? b = b - Math.floor(d / 2) + 1 : b = b + Math.floor(d / 2) - 1 : b > h && c.params.slidesPerGroup, c.slideTo(b, l ? 0 : void 0)) } } t("beforeInit", () => { const { thumbs: l } = n.params; if (!(!l || !l.swiper)) if (typeof l.swiper == "string" || l.swiper instanceof HTMLElement) { const c = ee(), d = () => { const p = typeof l.swiper == "string" ? c.querySelector(l.swiper) : l.swiper; if (p && p.swiper) l.swiper = p.swiper, i(), o(!0); else if (p) { const m = f => { l.swiper = f.detail[0], p.removeEventListener("init", m), i(), o(!0), l.swiper.update(), n.update() }; p.addEventListener("init", m) } return p }, u = () => { if (n.destroyed) return; d() || requestAnimationFrame(u) }; requestAnimationFrame(u) } else i(), o(!0) }), t("slideChange update resize observerUpdate", () => { o() }), t("setTransition", (l, c) => { const d = n.thumbs.swiper; !d || d.destroyed || d.setTransition(c) }), t("beforeDestroy", () => { const l = n.thumbs.swiper; !l || l.destroyed || s && l.destroy() }), Object.assign(n.thumbs, { init: i, update: o }) } function Wd({ swiper: n, extendParams: e, emit: t, once: a }) { e({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }); function s() { const o = n.getTranslate(); n.setTranslate(o), n.setTransition(0), n.touchEventsData.velocities.length = 0, n.freeMode.onTouchEnd({ currentPos: n.rtl ? n.translate : -n.translate }) } function r() { const { touchEventsData: o, touches: l } = n; o.velocities.length === 0 && o.velocities.push({ position: l[n.isHorizontal() ? "startX" : "startY"], time: o.touchStartTime }), o.velocities.push({ position: l[n.isHorizontal() ? "currentX" : "currentY"], time: He() }) } function i({ currentPos: o }) { const { params: l, wrapperEl: c, rtlTranslate: d, snapGrid: u, touchEventsData: p } = n, f = He() - p.touchStartTime; if (o < -n.minTranslate()) { n.slideTo(n.activeIndex); return } if (o > -n.maxTranslate()) { n.slides.length < u.length ? n.slideTo(u.length - 1) : n.slideTo(n.slides.length - 1); return } if (l.freeMode.momentum) { if (p.velocities.length > 1) { const C = p.velocities.pop(), k = p.velocities.pop(), M = C.position - k.position, A = C.time - k.time; n.velocity = M / A, n.velocity /= 2, Math.abs(n.velocity) < l.freeMode.minimumVelocity && (n.velocity = 0), (A > 150 || He() - C.time > 300) && (n.velocity = 0) } else n.velocity = 0; n.velocity *= l.freeMode.momentumVelocityRatio, p.velocities.length = 0; let h = 1e3 * l.freeMode.momentumRatio; const b = n.velocity * h; let g = n.translate + b; d && (g = -g); let v = !1, E; const $ = Math.abs(n.velocity) * 20 * l.freeMode.momentumBounceRatio; let w; if (g < n.maxTranslate()) l.freeMode.momentumBounce ? (g + n.maxTranslate() < -$ && (g = n.maxTranslate() - $), E = n.maxTranslate(), v = !0, p.allowMomentumBounce = !0) : g = n.maxTranslate(), l.loop && l.centeredSlides && (w = !0); else if (g > n.minTranslate()) l.freeMode.momentumBounce ? (g - n.minTranslate() > $ && (g = n.minTranslate() + $), E = n.minTranslate(), v = !0, p.allowMomentumBounce = !0) : g = n.minTranslate(), l.loop && l.centeredSlides && (w = !0); else if (l.freeMode.sticky) { let C; for (let k = 0; k < u.length; k += 1)if (u[k] > -g) { C = k; break } Math.abs(u[C] - g) < Math.abs(u[C - 1] - g) || n.swipeDirection === "next" ? g = u[C] : g = u[C - 1], g = -g } if (w && a("transitionEnd", () => { n.loopFix() }), n.velocity !== 0) { if (d ? h = Math.abs((-g - n.translate) / n.velocity) : h = Math.abs((g - n.translate) / n.velocity), l.freeMode.sticky) { const C = Math.abs((d ? -g : g) - n.translate), k = n.slidesSizesGrid[n.activeIndex]; C < k ? h = l.speed : C < 2 * k ? h = l.speed * 1.5 : h = l.speed * 2.5 } } else if (l.freeMode.sticky) { n.slideToClosest(); return } l.freeMode.momentumBounce && v ? (n.updateProgress(E), n.setTransition(h), n.setTranslate(g), n.transitionStart(!0, n.swipeDirection), n.animating = !0, Ot(c, () => { !n || n.destroyed || !p.allowMomentumBounce || (t("momentumBounce"), n.setTransition(l.speed), setTimeout(() => { n.setTranslate(E), Ot(c, () => { !n || n.destroyed || n.transitionEnd() }) }, 0)) })) : n.velocity ? (t("_freeModeNoMomentumRelease"), n.updateProgress(g), n.setTransition(h), n.setTranslate(g), n.transitionStart(!0, n.swipeDirection), n.animating || (n.animating = !0, Ot(c, () => { !n || n.destroyed || n.transitionEnd() }))) : n.updateProgress(g), n.updateActiveIndex(), n.updateSlidesClasses() } else if (l.freeMode.sticky) { n.slideToClosest(); return } else l.freeMode && t("_freeModeNoMomentumRelease"); (!l.freeMode.momentum || f >= l.longSwipesMs) && (n.updateProgress(), n.updateActiveIndex(), n.updateSlidesClasses()) } Object.assign(n, { freeMode: { onTouchStart: s, onTouchMove: r, onTouchEnd: i } }) } function Xd({ swiper: n, extendParams: e }) { e({ grid: { rows: 1, fill: "column" } }); let t, a, s; const r = l => { const { slidesPerView: c } = n.params, { rows: d, fill: u } = n.params.grid; a = t / d, s = Math.floor(l / d), Math.floor(l / d) === l / d ? t = l : t = Math.ceil(l / d) * d, c !== "auto" && u === "row" && (t = Math.max(t, c * d)) }, i = (l, c, d, u) => { const { slidesPerGroup: p, spaceBetween: m } = n.params, { rows: f, fill: h } = n.params.grid; let b, g, v; if (h === "row" && p > 1) { const E = Math.floor(l / (p * f)), $ = l - f * p * E, w = E === 0 ? p : Math.min(Math.ceil((d - E * f * p) / f), p); v = Math.floor($ / w), g = $ - v * w + E * p, b = g + v * t / f, c.style.order = b } else h === "column" ? (g = Math.floor(l / f), v = l - g * f, (g > s || g === s && v === f - 1) && (v += 1, v >= f && (v = 0, g += 1))) : (v = Math.floor(l / a), g = l - v * a); c.style[u("margin-top")] = v !== 0 ? m && `${m}px` : "" }, o = (l, c, d) => { const { spaceBetween: u, centeredSlides: p, roundLengths: m } = n.params, { rows: f } = n.params.grid; if (n.virtualSize = (l + u) * t, n.virtualSize = Math.ceil(n.virtualSize / f) - u, n.wrapperEl.style[d("width")] = `${n.virtualSize + u}px`, p) { const h = []; for (let b = 0; b < c.length; b += 1) { let g = c[b]; m && (g = Math.floor(g)), c[b] < n.virtualSize + c[0] && h.push(g) } c.splice(0, c.length), c.push(...h) } }; n.grid = { initSlides: r, updateSlide: i, updateWrapperSize: o } } function Gd(n) { const e = this, { params: t, slidesEl: a } = e; t.loop && e.loopDestroy(); const s = r => { if (typeof r == "string") { const i = document.createElement("div"); i.innerHTML = r, a.append(i.children[0]), i.innerHTML = "" } else a.append(r) }; if (typeof n == "object" && "length" in n) for (let r = 0; r < n.length; r += 1)n[r] && s(n[r]); else s(n); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update() } function Ud(n) { const e = this, { params: t, activeIndex: a, slidesEl: s } = e; t.loop && e.loopDestroy(); let r = a + 1; const i = o => { if (typeof o == "string") { const l = document.createElement("div"); l.innerHTML = o, s.prepend(l.children[0]), l.innerHTML = "" } else s.prepend(o) }; if (typeof n == "object" && "length" in n) { for (let o = 0; o < n.length; o += 1)n[o] && i(n[o]); r = a + n.length } else i(n); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), e.slideTo(r, 0, !1) } function _d(n, e) { const t = this, { params: a, activeIndex: s, slidesEl: r } = t; let i = s; a.loop && (i -= t.loopedSlides, t.loopDestroy(), t.recalcSlides()); const o = t.slides.length; if (n <= 0) { t.prependSlide(e); return } if (n >= o) { t.appendSlide(e); return } let l = i > n ? i + 1 : i; const c = []; for (let d = o - 1; d >= n; d -= 1) { const u = t.slides[d]; u.remove(), c.unshift(u) } if (typeof e == "object" && "length" in e) { for (let d = 0; d < e.length; d += 1)e[d] && r.append(e[d]); l = i > n ? i + e.length : i } else r.append(e); for (let d = 0; d < c.length; d += 1)r.append(c[d]); t.recalcSlides(), a.loop && t.loopCreate(), (!a.observer || t.isElement) && t.update(), a.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1) } function Kd(n) { const e = this, { params: t, activeIndex: a } = e; let s = a; t.loop && (s -= e.loopedSlides, e.loopDestroy()); let r = s, i; if (typeof n == "object" && "length" in n) { for (let o = 0; o < n.length; o += 1)i = n[o], e.slides[i] && e.slides[i].remove(), i < r && (r -= 1); r = Math.max(r, 0) } else i = n, e.slides[i] && e.slides[i].remove(), i < r && (r -= 1), r = Math.max(r, 0); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), t.loop ? e.slideTo(r + e.loopedSlides, 0, !1) : e.slideTo(r, 0, !1) } function Qd() { const n = this, e = []; for (let t = 0; t < n.slides.length; t += 1)e.push(t); n.removeSlide(e) } function Zd({ swiper: n }) { Object.assign(n, { appendSlide: Gd.bind(n), prependSlide: Ud.bind(n), addSlide: _d.bind(n), removeSlide: Kd.bind(n), removeAllSlides: Qd.bind(n) }) } function $t(n) { const { effect: e, swiper: t, on: a, setTranslate: s, setTransition: r, overwriteParams: i, perspective: o, recreateShadows: l, getEffectParams: c } = n; a("beforeInit", () => { if (t.params.effect !== e) return; t.classNames.push(`${t.params.containerModifierClass}${e}`), o && o() && t.classNames.push(`${t.params.containerModifierClass}3d`); const u = i ? i() : {}; Object.assign(t.params, u), Object.assign(t.originalParams, u) }), a("setTranslate", () => { t.params.effect === e && s() }), a("setTransition", (u, p) => { t.params.effect === e && r(p) }), a("transitionEnd", () => { if (t.params.effect === e && l) { if (!c || !c().slideShadows) return; t.slides.forEach(u => { u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(p => p.remove()) }), l() } }); let d; a("virtualUpdate", () => { t.params.effect === e && (t.slides.length || (d = !0), requestAnimationFrame(() => { d && t.slides && t.slides.length && (s(), d = !1) })) }) } function Rt(n, e) { const t = ft(e); return t !== e && (t.style.backfaceVisibility = "hidden", t.style["-webkit-backface-visibility"] = "hidden"), t } function ia({ swiper: n, duration: e, transformElements: t, allSlides: a }) { const { activeIndex: s } = n, r = i => i.parentElement ? i.parentElement : n.slides.filter(l => l.shadowEl && l.shadowEl === i.parentNode)[0]; if (n.params.virtualTranslate && e !== 0) { let i = !1, o; a ? o = t : o = t.filter(l => { const c = l.classList.contains("swiper-slide-transform") ? r(l) : l; return n.getSlideIndex(c) === s }), o.forEach(l => { Ot(l, () => { if (i || !n || n.destroyed) return; i = !0, n.animating = !1; const c = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); n.wrapperEl.dispatchEvent(c) }) }) } } function Jd({ swiper: n, extendParams: e, on: t }) { e({ fadeEffect: { crossFade: !1 } }), $t({ effect: "fade", swiper: n, on: t, setTranslate: () => { const { slides: r } = n, i = n.params.fadeEffect; for (let o = 0; o < r.length; o += 1) { const l = n.slides[o]; let d = -l.swiperSlideOffset; n.params.virtualTranslate || (d -= n.translate); let u = 0; n.isHorizontal() || (u = d, d = 0); const p = n.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(l.progress), 0) : 1 + Math.min(Math.max(l.progress, -1), 0), m = Rt(i, l); m.style.opacity = p, m.style.transform = `translate3d(${d}px, ${u}px, 0px)` } }, setTransition: r => { const i = n.slides.map(o => ft(o)); i.forEach(o => { o.style.transitionDuration = `${r}ms` }), ia({ swiper: n, duration: r, transformElements: i, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !n.params.cssMode }) }) } function eu({ swiper: n, extendParams: e, on: t }) { e({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const a = (o, l, c) => { let d = c ? o.querySelector(".swiper-slide-shadow-left") : o.querySelector(".swiper-slide-shadow-top"), u = c ? o.querySelector(".swiper-slide-shadow-right") : o.querySelector(".swiper-slide-shadow-bottom"); d || (d = ze("div", `swiper-slide-shadow-${c ? "left" : "top"}`), o.append(d)), u || (u = ze("div", `swiper-slide-shadow-${c ? "right" : "bottom"}`), o.append(u)), d && (d.style.opacity = Math.max(-l, 0)), u && (u.style.opacity = Math.max(l, 0)) }; $t({ effect: "cube", swiper: n, on: t, setTranslate: () => { const { el: o, wrapperEl: l, slides: c, width: d, height: u, rtlTranslate: p, size: m, browser: f } = n, h = n.params.cubeEffect, b = n.isHorizontal(), g = n.virtual && n.params.virtual.enabled; let v = 0, E; h.shadow && (b ? (E = n.slidesEl.querySelector(".swiper-cube-shadow"), E || (E = ze("div", "swiper-cube-shadow"), n.slidesEl.append(E)), E.style.height = `${d}px`) : (E = o.querySelector(".swiper-cube-shadow"), E || (E = ze("div", "swiper-cube-shadow"), o.append(E)))); for (let w = 0; w < c.length; w += 1) { const C = c[w]; let k = w; g && (k = parseInt(C.getAttribute("data-swiper-slide-index"), 10)); let M = k * 90, A = Math.floor(M / 360); p && (M = -M, A = Math.floor(-M / 360)); const O = Math.max(Math.min(C.progress, 1), -1); let S = 0, P = 0, T = 0; k % 4 === 0 ? (S = -A * 4 * m, T = 0) : (k - 1) % 4 === 0 ? (S = 0, T = -A * 4 * m) : (k - 2) % 4 === 0 ? (S = m + A * 4 * m, T = m) : (k - 3) % 4 === 0 && (S = -m, T = 3 * m + m * 4 * A), p && (S = -S), b || (P = S, S = 0); const I = `rotateX(${b ? 0 : -M}deg) rotateY(${b ? M : 0}deg) translate3d(${S}px, ${P}px, ${T}px)`; O <= 1 && O > -1 && (v = k * 90 + O * 90, p && (v = -k * 90 - O * 90)), C.style.transform = I, h.slideShadows && a(C, O, b) } if (l.style.transformOrigin = `50% 50% -${m / 2}px`, l.style["-webkit-transform-origin"] = `50% 50% -${m / 2}px`, h.shadow) if (b) E.style.transform = `translate3d(0px, ${d / 2 + h.shadowOffset}px, ${-d / 2}px) rotateX(90deg) rotateZ(0deg) scale(${h.shadowScale})`; else { const w = Math.abs(v) - Math.floor(Math.abs(v) / 90) * 90, C = 1.5 - (Math.sin(w * 2 * Math.PI / 360) / 2 + Math.cos(w * 2 * Math.PI / 360) / 2), k = h.shadowScale, M = h.shadowScale / C, A = h.shadowOffset; E.style.transform = `scale3d(${k}, 1, ${M}) translate3d(0px, ${u / 2 + A}px, ${-u / 2 / M}px) rotateX(-90deg)` } const $ = (f.isSafari || f.isWebView) && f.needPerspectiveFix ? -m / 2 : 0; l.style.transform = `translate3d(0px,0,${$}px) rotateX(${n.isHorizontal() ? 0 : v}deg) rotateY(${n.isHorizontal() ? -v : 0}deg)`, l.style.setProperty("--swiper-cube-translate-z", `${$}px`) }, setTransition: o => { const { el: l, slides: c } = n; if (c.forEach(d => { d.style.transitionDuration = `${o}ms`, d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(u => { u.style.transitionDuration = `${o}ms` }) }), n.params.cubeEffect.shadow && !n.isHorizontal()) { const d = l.querySelector(".swiper-cube-shadow"); d && (d.style.transitionDuration = `${o}ms`) } }, recreateShadows: () => { const o = n.isHorizontal(); n.slides.forEach(l => { const c = Math.max(Math.min(l.progress, 1), -1); a(l, c, o) }) }, getEffectParams: () => n.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) } function Et(n, e, t) { const a = `swiper-slide-shadow${t ? `-${t}` : ""}`, s = ft(e); let r = s.querySelector(`.${a}`); return r || (r = ze("div", `swiper-slide-shadow${t ? `-${t}` : ""}`), s.append(r)), r } function tu({ swiper: n, extendParams: e, on: t }) { e({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const a = (o, l, c) => { let d = n.isHorizontal() ? o.querySelector(".swiper-slide-shadow-left") : o.querySelector(".swiper-slide-shadow-top"), u = n.isHorizontal() ? o.querySelector(".swiper-slide-shadow-right") : o.querySelector(".swiper-slide-shadow-bottom"); d || (d = Et(c, o, n.isHorizontal() ? "left" : "top")), u || (u = Et(c, o, n.isHorizontal() ? "right" : "bottom")), d && (d.style.opacity = Math.max(-l, 0)), u && (u.style.opacity = Math.max(l, 0)) }; $t({ effect: "flip", swiper: n, on: t, setTranslate: () => { const { slides: o, rtlTranslate: l } = n, c = n.params.flipEffect; for (let d = 0; d < o.length; d += 1) { const u = o[d]; let p = u.progress; n.params.flipEffect.limitRotation && (p = Math.max(Math.min(u.progress, 1), -1)); const m = u.swiperSlideOffset; let h = -180 * p, b = 0, g = n.params.cssMode ? -m - n.translate : -m, v = 0; n.isHorizontal() ? l && (h = -h) : (v = g, g = 0, b = -h, h = 0), u.style.zIndex = -Math.abs(Math.round(p)) + o.length, c.slideShadows && a(u, p, c); const E = `translate3d(${g}px, ${v}px, 0px) rotateX(${b}deg) rotateY(${h}deg)`, $ = Rt(c, u); $.style.transform = E } }, setTransition: o => { const l = n.slides.map(c => ft(c)); l.forEach(c => { c.style.transitionDuration = `${o}ms`, c.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d => { d.style.transitionDuration = `${o}ms` }) }), ia({ swiper: n, duration: o, transformElements: l }) }, recreateShadows: () => { const o = n.params.flipEffect; n.slides.forEach(l => { let c = l.progress; n.params.flipEffect.limitRotation && (c = Math.max(Math.min(l.progress, 1), -1)), a(l, c, o) }) }, getEffectParams: () => n.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !n.params.cssMode }) }) } function au({ swiper: n, extendParams: e, on: t }) { e({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }), $t({ effect: "coverflow", swiper: n, on: t, setTranslate: () => { const { width: r, height: i, slides: o, slidesSizesGrid: l } = n, c = n.params.coverflowEffect, d = n.isHorizontal(), u = n.translate, p = d ? -u + r / 2 : -u + i / 2, m = d ? c.rotate : -c.rotate, f = c.depth; for (let h = 0, b = o.length; h < b; h += 1) { const g = o[h], v = l[h], E = g.swiperSlideOffset, $ = (p - E - v / 2) / v, w = typeof c.modifier == "function" ? c.modifier($) : $ * c.modifier; let C = d ? m * w : 0, k = d ? 0 : m * w, M = -f * Math.abs(w), A = c.stretch; typeof A == "string" && A.indexOf("%") !== -1 && (A = parseFloat(c.stretch) / 100 * v); let O = d ? 0 : A * w, S = d ? A * w : 0, P = 1 - (1 - c.scale) * Math.abs(w); Math.abs(S) < .001 && (S = 0), Math.abs(O) < .001 && (O = 0), Math.abs(M) < .001 && (M = 0), Math.abs(C) < .001 && (C = 0), Math.abs(k) < .001 && (k = 0), Math.abs(P) < .001 && (P = 0); const T = `translate3d(${S}px,${O}px,${M}px)  rotateX(${k}deg) rotateY(${C}deg) scale(${P})`, I = Rt(c, g); if (I.style.transform = T, g.style.zIndex = -Math.abs(Math.round(w)) + 1, c.slideShadows) { let H = d ? g.querySelector(".swiper-slide-shadow-left") : g.querySelector(".swiper-slide-shadow-top"), D = d ? g.querySelector(".swiper-slide-shadow-right") : g.querySelector(".swiper-slide-shadow-bottom"); H || (H = Et(c, g, d ? "left" : "top")), D || (D = Et(c, g, d ? "right" : "bottom")), H && (H.style.opacity = w > 0 ? w : 0), D && (D.style.opacity = -w > 0 ? -w : 0) } } }, setTransition: r => { n.slides.map(o => ft(o)).forEach(o => { o.style.transitionDuration = `${r}ms`, o.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(l => { l.style.transitionDuration = `${r}ms` }) }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) } function nu({ swiper: n, extendParams: e, on: t }) { e({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const a = i => typeof i == "string" ? i : `${i}px`; $t({ effect: "creative", swiper: n, on: t, setTranslate: () => { const { slides: i, wrapperEl: o, slidesSizesGrid: l } = n, c = n.params.creativeEffect, { progressMultiplier: d } = c, u = n.params.centeredSlides; if (u) { const p = l[0] / 2 - n.params.slidesOffsetBefore || 0; o.style.transform = `translateX(calc(50% - ${p}px))` } for (let p = 0; p < i.length; p += 1) { const m = i[p], f = m.progress, h = Math.min(Math.max(m.progress, -c.limitProgress), c.limitProgress); let b = h; u || (b = Math.min(Math.max(m.originalProgress, -c.limitProgress), c.limitProgress)); const g = m.swiperSlideOffset, v = [n.params.cssMode ? -g - n.translate : -g, 0, 0], E = [0, 0, 0]; let $ = !1; n.isHorizontal() || (v[1] = v[0], v[0] = 0); let w = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; h < 0 ? (w = c.next, $ = !0) : h > 0 && (w = c.prev, $ = !0), v.forEach((P, T) => { v[T] = `calc(${P}px + (${a(w.translate[T])} * ${Math.abs(h * d)}))` }), E.forEach((P, T) => { E[T] = w.rotate[T] * Math.abs(h * d) }), m.style.zIndex = -Math.abs(Math.round(f)) + i.length; const C = v.join(", "), k = `rotateX(${E[0]}deg) rotateY(${E[1]}deg) rotateZ(${E[2]}deg)`, M = b < 0 ? `scale(${1 + (1 - w.scale) * b * d})` : `scale(${1 - (1 - w.scale) * b * d})`, A = b < 0 ? 1 + (1 - w.opacity) * b * d : 1 - (1 - w.opacity) * b * d, O = `translate3d(${C}) ${k} ${M}`; if ($ && w.shadow || !$) { let P = m.querySelector(".swiper-slide-shadow"); if (!P && w.shadow && (P = Et(c, m)), P) { const T = c.shadowPerProgress ? h * (1 / c.limitProgress) : h; P.style.opacity = Math.min(Math.max(Math.abs(T), 0), 1) } } const S = Rt(c, m); S.style.transform = O, S.style.opacity = A, w.origin && (S.style.transformOrigin = w.origin) } }, setTransition: i => { const o = n.slides.map(l => ft(l)); o.forEach(l => { l.style.transitionDuration = `${i}ms`, l.querySelectorAll(".swiper-slide-shadow").forEach(c => { c.style.transitionDuration = `${i}ms` }) }), ia({ swiper: n, duration: i, transformElements: o, allSlides: !0 }) }, perspective: () => n.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !n.params.cssMode }) }) } function su({ swiper: n, extendParams: e, on: t }) {
  e({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), $t({
    effect: "cards", swiper: n, on: t, setTranslate: () => {
      const { slides: r, activeIndex: i } = n, o = n.params.cardsEffect, { startTranslate: l, isTouched: c } = n.touchEventsData, d = n.translate; for (let u = 0; u < r.length; u += 1) {
        const p = r[u], m = p.progress, f = Math.min(Math.max(m, -4), 4); let h = p.swiperSlideOffset; n.params.centeredSlides && !n.params.cssMode && (n.wrapperEl.style.transform = `translateX(${n.minTranslate()}px)`), n.params.centeredSlides && n.params.cssMode && (h -= r[0].swiperSlideOffset); let b = n.params.cssMode ? -h - n.translate : -h, g = 0; const v = -100 * Math.abs(f); let E = 1, $ = -o.perSlideRotate * f, w = o.perSlideOffset - Math.abs(f) * .75; const C = n.virtual && n.params.virtual.enabled ? n.virtual.from + u : u, k = (C === i || C === i - 1) && f > 0 && f < 1 && (c || n.params.cssMode) && d < l, M = (C === i || C === i + 1) && f < 0 && f > -1 && (c || n.params.cssMode) && d > l; if (k || M) { const P = (1 - Math.abs((Math.abs(f) - .5) / .5)) ** .5; $ += -28 * f * P, E += -.5 * P, w += 96 * P, g = `${-25 * P * Math.abs(f)}%` } if (f < 0 ? b = `calc(${b}px + (${w * Math.abs(f)}%))` : f > 0 ? b = `calc(${b}px + (-${w * Math.abs(f)}%))` : b = `${b}px`, !n.isHorizontal()) { const P = g; g = b, b = P } const A = f < 0 ? `${1 + (1 - E) * f}` : `${1 - (1 - E) * f}`, O = `
        translate3d(${b}, ${g}, ${v}px)
        rotateZ(${o.rotate ? $ : 0}deg)
        scale(${A})
      `; if (o.slideShadows) { let P = p.querySelector(".swiper-slide-shadow"); P || (P = Et(o, p)), P && (P.style.opacity = Math.min(Math.max((Math.abs(f) - .5) / .5, 0), 1)) } p.style.zIndex = -Math.abs(Math.round(m)) + r.length; const S = Rt(o, p); S.style.transform = O
      }
    }, setTransition: r => { const i = n.slides.map(o => ft(o)); i.forEach(o => { o.style.transitionDuration = `${r}ms`, o.querySelectorAll(".swiper-slide-shadow").forEach(l => { l.style.transitionDuration = `${r}ms` }) }), ia({ swiper: n, duration: r, transformElements: i }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !n.params.cssMode })
  })
} const ru = [Id, Od, Bd, Dd, Ld, Rd, Hd, zd, Fd, Vd, Nd, Yd, qd, jd, Wd, Xd, Zd, Jd, eu, tu, au, nu, su]; yt.use(ru); const oa = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopedSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideNextClass", "slidePrevClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function ea(n) { return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" } function ta(n, e) { const t = ["__proto__", "constructor", "prototype"]; Object.keys(e).filter(a => t.indexOf(a) < 0).forEach(a => { typeof n[a] > "u" ? n[a] = e[a] : ea(e[a]) && ea(n[a]) && Object.keys(e[a]).length > 0 ? e[a].__swiper__ ? n[a] = e[a] : ta(n[a], e[a]) : n[a] = e[a] }) } function iu(n = {}) { return n.navigation && typeof n.navigation.nextEl > "u" && typeof n.navigation.prevEl > "u" } function ou(n = {}) { return n.pagination && typeof n.pagination.el > "u" } function lu(n = {}) { return n.scrollbar && typeof n.scrollbar.el > "u" } function Xt(n = "") { return n.replace(/-[a-z]/g, e => e.toUpperCase().replace("-", "")) } const jn = n => { if (parseFloat(n) === Number(n)) return Number(n); if (n === "true" || n === "") return !0; if (n === "false") return !1; if (n === "null") return null; if (n !== "undefined") return n }, Wn = ["a11y", "autoplay", "controller", "cards-effect", "coverflow-effect", "creative-effect", "cube-effect", "fade-effect", "flip-effect", "free-mode", "grid", "hash-navigation", "history", "keyboard", "mousewheel", "navigation", "pagination", "parallax", "scrollbar", "thumbs", "virtual", "zoom"]; function Xn(n) { const e = {}, t = {}; ta(e, Fa); const a = [...oa, "on"], s = a.map(r => r.replace(/_/, "")); return a.forEach(r => { r = r.replace("_", ""), typeof n[r] < "u" && (t[r] = n[r]) }), [...n.attributes].forEach(r => { const i = Wn.filter(o => r.name.indexOf(`${o}-`) === 0)[0]; if (i) { const o = Xt(i), l = Xt(r.name.split(`${i}-`)[1]); t[o] || (t[o] = {}), t[o] === !0 && (t[o] = { enabled: !0 }), t[o][l] = jn(r.value) } else { const o = Xt(r.name); if (!s.includes(o)) return; const l = jn(r.value); t[o] && Wn.includes(r.name) ? (t[o].constructor !== Object && (t[o] = {}), t[o].enabled = l) : t[o] = l } }), ta(e, t), e.navigation ? e.navigation = { prevEl: ".swiper-button-prev", nextEl: ".swiper-button-next", ...e.navigation !== !0 ? e.navigation : {} } : e.navigation === !1 && delete e.navigation, e.scrollbar ? e.scrollbar = { el: ".swiper-scrollbar", ...e.scrollbar !== !0 ? e.scrollbar : {} } : e.scrollbar === !1 && delete e.scrollbar, e.pagination ? e.pagination = { el: ".swiper-pagination", ...e.pagination !== !0 ? e.pagination : {} } : e.pagination === !1 && delete e.pagination, { params: e, passedParams: t } } function cu({ swiper: n, slides: e, passedParams: t, changedParams: a, nextEl: s, prevEl: r, scrollbarEl: i, paginationEl: o }) { const l = a.filter(M => M !== "children" && M !== "direction" && M !== "wrapperClass"), { params: c, pagination: d, navigation: u, scrollbar: p, virtual: m, thumbs: f } = n; let h, b, g, v, E, $, w, C; a.includes("thumbs") && t.thumbs && t.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (h = !0), a.includes("controller") && t.controller && t.controller.control && c.controller && !c.controller.control && (b = !0), a.includes("pagination") && t.pagination && (t.pagination.el || o) && (c.pagination || c.pagination === !1) && d && !d.el && (g = !0), a.includes("scrollbar") && t.scrollbar && (t.scrollbar.el || i) && (c.scrollbar || c.scrollbar === !1) && p && !p.el && (v = !0), a.includes("navigation") && t.navigation && (t.navigation.prevEl || r) && (t.navigation.nextEl || s) && (c.navigation || c.navigation === !1) && u && !u.prevEl && !u.nextEl && (E = !0); const k = M => { n[M] && (n[M].destroy(), M === "navigation" ? (n.isElement && (n[M].prevEl.remove(), n[M].nextEl.remove()), c[M].prevEl = void 0, c[M].nextEl = void 0, n[M].prevEl = void 0, n[M].nextEl = void 0) : (n.isElement && n[M].el.remove(), c[M].el = void 0, n[M].el = void 0)) }; a.includes("loop") && n.isElement && (c.loop && !t.loop ? $ = !0 : !c.loop && t.loop ? w = !0 : C = !0), l.forEach(M => { if (ea(c[M]) && ea(t[M])) ta(c[M], t[M]); else { const A = t[M]; (A === !0 || A === !1) && (M === "navigation" || M === "pagination" || M === "scrollbar") ? A === !1 && k(M) : c[M] = t[M] } }), l.includes("controller") && !b && n.controller && n.controller.control && c.controller && c.controller.control && (n.controller.control = c.controller.control), a.includes("children") && e && m && c.virtual.enabled && (m.slides = e, m.update(!0)), a.includes("children") && e && c.loop && (C = !0), h && f.init() && f.update(!0), b && (n.controller.control = c.controller.control), g && (n.isElement && (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-pagination"), n.el.shadowEl.appendChild(o)), o && (c.pagination.el = o), d.init(), d.render(), d.update()), v && (n.isElement && (!i || typeof i == "string") && (i = document.createElement("div"), i.classList.add("swiper-scrollbar"), n.el.shadowEl.appendChild(i)), i && (c.scrollbar.el = i), p.init(), p.updateSize(), p.setTranslate()), E && (n.isElement && ((!s || typeof s == "string") && (s = document.createElement("div"), s.classList.add("swiper-button-next"), n.el.shadowEl.appendChild(s)), (!r || typeof r == "string") && (r = document.createElement("div"), r.classList.add("swiper-button-prev"), n.el.shadowEl.appendChild(r))), s && (c.navigation.nextEl = s), r && (c.navigation.prevEl = r), u.init(), u.update()), a.includes("allowSlideNext") && (n.allowSlideNext = t.allowSlideNext), a.includes("allowSlidePrev") && (n.allowSlidePrev = t.allowSlidePrev), a.includes("direction") && n.changeDirection(t.direction, !1), ($ || C) && n.loopDestroy(), (w || C) && n.loopCreate(), n.update() } const du = "@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}", uu = ":root{--swiper-theme-color:#007aff}.swiper,swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}:host(.swiper-vertical)>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight swiper-slide{height:auto}:host(.swiper-autoheight) .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}:host(.swiper-3d.swiper-css-mode) .swiper-wrapper{perspective:1200px}:host(.swiper-3d) .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d swiper-slide{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}:host(.swiper-css-mode)>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}:host(.swiper-css-mode)>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>swiper-slide{scroll-snap-align:start start}:host(.swiper-horizontal.swiper-css-mode)>.swiper-wrapper{scroll-snap-type:x mandatory}:host(.swiper-vertical.swiper-css-mode)>.swiper-wrapper{scroll-snap-type:y mandatory}:host(.swiper-centered)>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered>swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-centered.swiper-horizontal>swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}:host(.swiper-centered.swiper-horizontal)>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}:host(.swiper-centered.swiper-vertical)>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,swiper-container:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper-virtual swiper-slide{-webkit-backface-visibility:hidden;transform:translateZ(0)}:host(.swiper-virtual.swiper-css-mode) .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}:host(.swiper-virtual.swiper-css-mode.swiper-horizontal) .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}:host(.swiper-virtual.swiper-css-mode.swiper-vertical) .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,:host(.swiper-rtl) .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-prev:after,:host(.swiper-rtl) .swiper-button-next:after{content:'prev'}.swiper-button-next,:host(.swiper-rtl) .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-next:after,:host(.swiper-rtl) .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,:host(.swiper-horizontal.swiper-rtl) .swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}:host(.swiper-rtl) .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;-ms-touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move;touch-action:none}.swiper .swiper-notification,swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}:host(.swiper-free-mode)>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}:host(.swiper-grid)>.swiper-wrapper{flex-wrap:wrap}:host(.swiper-grid-column)>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode swiper-slide{transition-timing-function:ease-out}.swiper-fade swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade swiper-slide swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube swiper-slide swiper-slide{pointer-events:none}.swiper-cube.swiper-rtl swiper-slide{transform-origin:100% 0}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-next,.swiper-cube .swiper-slide-prev,.swiper-cube swiper-slide-next+swiper-slide{pointer-events:auto;visibility:visible}.swiper-cube .swiper-slide-shadow-bottom,.swiper-cube .swiper-slide-shadow-left,.swiper-cube .swiper-slide-shadow-right,.swiper-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-flip{overflow:visible}.swiper-flip swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip swiper-slide swiper-slide{pointer-events:none}.swiper-flip .swiper-slide-active,.swiper-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-flip .swiper-slide-shadow-bottom,.swiper-flip .swiper-slide-shadow-left,.swiper-flip .swiper-slide-shadow-right,.swiper-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-creative swiper-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards swiper-slide{transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}"; let aa = !0; const Va = (n, e) => {
  let t = document.querySelector("style#swiper-element-styles"); const a = t && t.preInit && !n; !n && e && e.cssLinks().forEach(s => { const r = document.createElement("link"); r.rel = "stylesheet", r.href = s, document.head.prepend(r) }), (!t || a) && (t = t || document.createElement("style"), t.textContent = [du, e ? e.cssStyles() : ""].join(`
`), t.id = "swiper-element-styles", t.preInit = n, document.head.prepend(t))
}; class pu { } const Fs = typeof window > "u" || typeof HTMLElement > "u" ? pu : HTMLElement; class Vs extends Fs {
  constructor() { super(), this.tempDiv = document.createElement("div"), this.shadowEl = this.attachShadow({ mode: "open" }) } cssStyles() {
    return [aa ? uu : "", ...this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : []].join(`
`)
  } cssLinks() { return this.injectStylesUrls || [] } render() {
    aa && Va(!1, this); const e = this.cssStyles(); e.length && (this.stylesEl = document.createElement("style"), this.stylesEl.textContent = e, this.shadowEl.appendChild(this.stylesEl)), this.cssLinks().forEach(t => { if (document.querySelector(`link[href="${t}"]`)) return; const s = document.createElement("link"); s.rel = "stylesheet", s.href = t, this.shadowEl.appendChild(s) }), this.tempDiv.innerHTML = `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper">
        <slot></slot>
      </div>
      <slot name="container-end"></slot>
      ${iu(this.passedParams) ? `
        <div class="swiper-button-prev"></div>
        <div class="swiper-button-next"></div>
      `: ""}
      ${ou(this.passedParams) ? `
        <div class="swiper-pagination"></div>
      `: ""}
      ${lu(this.passedParams) ? `
        <div class="swiper-scrollbar"></div>
      `: ""}
    `, [...this.tempDiv.children].forEach(t => { this.shadowEl.appendChild(t) })
  } initialize() { if (this.initialized) return; this.initialized = !0; const { params: e, passedParams: t } = Xn(this); this.swiperParams = e, this.passedParams = t, delete this.swiperParams.init, this.render(), this.swiper = new yt(this, { ...e, touchEventsTarget: "container", ...e.virtual ? {} : { observer: !0 }, onAny: (a, ...s) => { const r = e.eventsPrefix ? `${e.eventsPrefix}${a.toLowerCase()}` : a.toLowerCase(), i = new CustomEvent(r, { detail: s, bubbles: !0, cancelable: !0 }); this.dispatchEvent(i) } }) } connectedCallback() { if (this.init === !1 || this.getAttribute("init") === "false") { Va(!0, this); return } this.initialize() } disconnectedCallback() { this.swiper && this.swiper.destroy && this.swiper.destroy(), this.initialized = !1 } updateSwiperOnPropChange(e) { const { params: t, passedParams: a } = Xn(this); this.passedParams = a, this.swiperParams = t, cu({ swiper: this.swiper, passedParams: this.passedParams, changedParams: [Xt(e)], ...e === "navigation" && a[e] ? { prevEl: ".swiper-button-prev", nextEl: ".swiper-button-next" } : {}, ...e === "pagination" && a[e] ? { paginationEl: ".swiper-pagination" } : {}, ...e === "scrollbar" && a[e] ? { scrollbarEl: ".swiper-scrollbar" } : {} }) } attributeChangedCallback(e, t, a) { this.initialized && this.updateSwiperOnPropChange(e, a) } static get observedAttributes() { return oa.filter(t => t.includes("_")).map(t => t.replace(/[A-Z]/g, a => `-${a}`).replace("_", "").toLowerCase()) }
} oa.forEach(n => { n !== "init" && (n = n.replace("_", ""), Object.defineProperty(Vs.prototype, n, { configurable: !0, get() { return (this.passedParams || {})[n] }, set(e) { this.passedParams || (this.passedParams = {}), this.passedParams[n] = e, this.initialized && this.updateSwiperOnPropChange(n, e) } })) }); class fu extends Fs { constructor() { super(), this.tempDiv = document.createElement("div"), this.shadowEl = this.attachShadow({ mode: "open" }) } render() { const e = this.lazy || this.getAttribute("lazy") === "" || this.getAttribute("lazy") === "true"; if (this.tempDiv.innerHTML = "<slot />", [...this.tempDiv.children].forEach(t => { this.shadowEl.appendChild(t) }), e) { const t = document.createElement("div"); t.classList.add("swiper-lazy-preloader"), this.appendChild(t) } } initialize() { this.render() } connectedCallback() { this.initialize() } } const hu = (n = !0) => { typeof window > "u" || (n || (aa = !1), aa && Va(!0), window.customElements.get("swiper-container") || window.customElements.define("swiper-container", Vs), window.customElements.get("swiper-slide") || window.customElements.define("swiper-slide", fu)) }; typeof window < "u" && (window.SwiperElementRegisterParams = n => { oa.push(...n) }); hu(); function Ta(n) { const e = this, t = y(n); if (t.length === 0) return; const a = t[0].swiper && t[0].swiper.isElement; if (t[0].swiper && !t[0].swiper.isElement) return; let s, r = {}, i, o; t.hasClass("tabs") && (s = t.children("swiper-slide").indexOf(t.children(".tab-active")[0]), i = !0, o = t.find(".tabs-routable").length > 0), t.attr("data-swiper") ? r = JSON.parse(t.attr("data-swiper")) : t[0].f7SwiperParams ? r = t[0].f7SwiperParams : (r = t.dataset(), Object.keys(r).forEach(u => { const p = r[u]; if (typeof p == "string" && p.indexOf("{") === 0 && p.indexOf("}") > 0) try { r[u] = JSON.parse(p) } catch { } })), typeof r.initialSlide > "u" && typeof s < "u" && (r.initialSlide = s); const l = a ? t[0].swiper : e.swiper.create(t[0], r); a && l.slideTo(s, 0); function c() { l.update() } const d = t.parents(".tab").filter(u => y(u).parent(".tabs").parent(".tabs-animated-wrap, swiper-container.tabs").length === 0).eq(0); t.parents(".popup, .login-screen, .sheet-modal, .popover").on("modal:open", c), t.parents(".panel").on("panel:open", c), d && d.length && d.on("tab:show", c), l.on("beforeDestroy", () => { t.parents(".popup, .login-screen, .sheet-modal, .popover").off("modal:open", c), t.parents(".panel").off("panel:open", c), d && d.length && d.off("tab:show", c) }), i && l.on("slideChange", () => { if (o) { let u = e.views.get(t.parents(".view")); u || (u = e.views.main); const p = u.router, m = p.findTabRouteUrl(y(l.slides).eq(l.activeIndex)[0]); m && setTimeout(() => { p.navigate(m) }, 0) } else e.tab.show({ tabEl: y(l.slides).eq(l.activeIndex) }) }) } const mu = { name: "swiper", static: { Swiper: yt }, create() { const n = this; n.swiper = we({ defaultSelector: ".swiper", constructor: yt, domProp: "swiper" }) }, on: { pageMounted(n) { const e = this; n.$el.find("swiper-container.tabs").each(t => { Ta.call(e, t) }) }, pageInit(n) { const e = this; n.$el.find("swiper-container.tabs").each(t => { Ta.call(e, t) }) }, pageReinit(n) { const e = this; n.$el.find("swiper-container.tabs").each(t => { const a = e.swiper.get(t); a && a.update && a.update() }) }, tabMounted(n) { const e = this; y(n).find("swiper-container.tabs").each(t => { Ta.call(e, t) }) }, tabShow(n) { const e = this; y(n).find("swiper-container.tabs").each(t => { const a = e.swiper.get(t); a && a.update && a.update() }) }, tabBeforeRemove(n) { const e = this; y(n).find("swiper-container.tabs").each(t => { e.swiper.destroy(t) }) } } }; let Gn = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this; a.app = e; const s = R({ on: {} }, e.params.photoBrowser); a.useModulesParams(s), a.params = R(s, t), R(a, { exposed: !1, opened: !1, activeIndex: a.params.swiper.initialSlide, url: a.params.url, swipeToClose: { allow: !0, isTouched: !1, diff: void 0, start: void 0, current: void 0, started: !1, activeSlide: void 0, timeStart: void 0 } }), a.useModules(), a.init() } get view() { const { params: e, app: t } = this; return e.view || t.views.main } onSlideChange(e) { const t = this; t.activeIndex = e.activeIndex; let a = e.activeIndex + 1, s = t.params.virtualSlides ? t.params.photos.length : e.slides.length; e.params.loop && (s -= 2, a -= e.loopedSlides, a < 1 && (a = s + a), a > s && (a -= s)); const r = t.params.virtualSlides ? y(e.wrapperEl).find(`.swiper-slide[data-swiper-slide-index="${e.activeIndex}"]`) : y(e.slides).eq(e.activeIndex), i = t.params.virtualSlides ? y(e.wrapperEl).find(`.swiper-slide[data-swiper-slide-index="${e.previousIndex}"]`) : y(e.slides).eq(e.previousIndex); let o = t.$el.find(".photo-browser-current"), l = t.$el.find(".photo-browser-total"), c; if (t.params.type === "page" && t.params.navbar && o.length === 0 && t.app.theme === "ios" && (c = t.app.navbar.getElByPage(t.$el), c && (o = y(c).find(".photo-browser-current"), l = y(c).find(".photo-browser-total"))), o.length && l.length && (o.text(a), l.text(s), c || (c = o.parents(".navbar")[0]), c && t.app.navbar.size(c)), t.captions.length > 0) { const u = e.params.loop ? r.attr("data-swiper-slide-index") : t.activeIndex; t.$captionsContainerEl.find(".photo-browser-caption-active").removeClass("photo-browser-caption-active"), t.$captionsContainerEl.find(`[data-caption-index="${u}"]`).addClass("photo-browser-caption-active") } const d = i.find("video"); d.length > 0 && "pause" in d[0] && d[0].pause() } onTouchStart() { const t = this.swipeToClose; t.allow && (t.isTouched = !0) } onTouchMove(e) { const t = this, a = t.swipeToClose; a.isTouched && (a.started || (a.started = !0, a.start = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY, t.params.virtualSlides ? a.activeSlide = y(t.swiper.wrapperEl).children(".swiper-slide-active") : a.activeSlide = y(t.swiper.slides).eq(t.swiper.activeIndex), a.timeStart = Ie()), e.preventDefault(), a.current = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY, a.diff = a.start - a.current, t.$el.transition(0).transform(`translate3d(0,${-a.diff}px,0)`)) } onTouchEnd() { const e = this, t = e.swipeToClose; if (t.isTouched = !1, !t.started) { t.started = !1; return } t.started = !1, t.allow = !1; const a = Math.abs(t.diff), s = new Date().getTime() - t.timeStart; if (s < 300 && a > 20 || s >= 300 && a > 100) { $e(() => { e.$el && (t.diff < 0 ? e.$el.addClass("swipe-close-to-bottom") : e.$el.addClass("swipe-close-to-top")), e.emit("local::swipeToClose", e), e.$el.transform("").transition(""), e.close(), t.allow = !0 }); return } a !== 0 ? e.$el.addClass("photo-browser-transitioning").transitionEnd(() => { t.allow = !0, e.$el.removeClass("photo-browser-transitioning") }) : t.allow = !0, $e(() => { e.$el.transform("").transition("") }) } renderNavbar() { const e = this; if (e.params.renderNavbar) return e.params.renderNavbar.call(e); const t = e.params.iconsColor, a = e.app.theme === "ios" && e.params.pageBackLinkText ? e.params.pageBackLinkText : "", s = typeof e.params.navbarShowCount > "u" ? e.params.photos.length > 1 : e.params.navbarShowCount, r = e.params.type !== "page"; return x("div", { class: `navbar navbar-photo-browser ${e.params.theme === "dark" ? "navbar-photo-browser-dark" : ""}` }, x("div", { class: "navbar-bg" }), x("div", { class: "navbar-inner navbar-inner-centered-title sliding" }, !r && x("div", { class: "left" }, x("a", { class: `link ${a ? "" : "icon-only"} back` }, x("i", { class: `icon icon-back ${t ? `color-${t}` : ""}` }), a && x("span", null, a))), s && x("div", { class: "title" }, x("span", { class: "photo-browser-current" }), x("span", { class: "photo-browser-of" }, e.params.navbarOfText), x("span", { class: "photo-browser-total" })), r && (e.params.popupCloseLinkText || e.params.popupCloseLinkIcon) && x("div", { class: "right" }, x("a", { class: "link popup-close", "data-popup": ".photo-browser-popup" }, e.params.popupCloseLinkIcon && e.app.theme === "ios" && x("i", null, x("svg", { xmlns: "http://www.w3.org/2000/svg", width: "56", height: "56", viewBox: "0 0 56 56" }, x("path", { fill: "currentColor", d: "M 10.0234 43.0234 C 9.2266 43.8203 9.2031 45.1797 10.0234 45.9766 C 10.8438 46.7734 12.1797 46.7734 13.0000 45.9766 L 28.0000 30.9766 L 43.0000 45.9766 C 43.7969 46.7734 45.1563 46.7969 45.9766 45.9766 C 46.7734 45.1562 46.7734 43.8203 45.9766 43.0234 L 30.9531 28.0000 L 45.9766 13.0000 C 46.7734 12.2031 46.7969 10.8437 45.9766 10.0469 C 45.1328 9.2266 43.7969 9.2266 43.0000 10.0469 L 28.0000 25.0469 L 13.0000 10.0469 C 12.1797 9.2266 10.8203 9.2031 10.0234 10.0469 C 9.2266 10.8672 9.2266 12.2031 10.0234 13.0000 L 25.0234 28.0000 Z" }))), e.params.popupCloseLinkIcon && e.app.theme === "md" && x("i", null, x("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" }, x("path", { d: "M0 0h24v24H0V0z", fill: "none" }), x("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" }))), e.params.popupCloseLinkText && x("span", null, e.params.popupCloseLinkText))))) } renderToolbar() { const e = this; if (e.params.renderToolbar) return e.params.renderToolbar.call(e); const t = e.params.iconsColor; return x("div", { class: "toolbar toolbar-bottom tabbar" }, x("div", { class: "toolbar-inner" }, x("a", { class: "link photo-browser-prev" }, x("i", { class: `icon icon-back ${t ? `color-${t}` : ""}` })), x("a", { class: "link photo-browser-next" }, x("i", { class: `icon icon-forward ${t ? `color-${t}` : ""}` })))) } renderThumbs() { const e = this; return x("div", { class: "toolbar toolbar-bottom photo-browser-thumbs" }, x("div", { class: "swiper" }, x("div", { class: "swiper-wrapper" }, e.params.thumbs.map((t, a) => e.renderThumb(t, a))))) } renderCaption(e, t) { const a = this; return a.params.renderCaption ? a.params.renderCaption.call(a, e, t) : x("div", { class: "photo-browser-caption", "data-caption-index": t }, e) } renderObject(e, t) { const a = this; return a.params.renderObject ? a.params.renderObject.call(a, e, t) : x("div", { class: "photo-browser-slide photo-browser-object-slide swiper-slide", "data-swiper-slide-index": t }, e.html ? e.html : e) } renderLazyPhoto(e, t) { const a = this; return a.params.renderLazyPhoto ? a.params.renderLazyPhoto.call(a, e, t) : x("div", { class: "photo-browser-slide photo-browser-slide-lazy swiper-slide", "data-swiper-slide-index": t }, x("div", { class: "swiper-lazy-preloader" }), x("span", { class: "swiper-zoom-container" }, x("img", { loading: "lazy", src: e.url ? e.url : e }))) } renderPhoto(e, t) { const a = this; return a.params.renderPhoto ? a.params.renderPhoto.call(a, e, t) : x("div", { class: "photo-browser-slide swiper-slide", "data-swiper-slide-index": t }, x("span", { class: "swiper-zoom-container" }, x("img", { src: e.url ? e.url : e }))) } renderThumb(e, t) { const a = this, s = typeof e == "string" ? e : e.url; return a.params.renderThumb ? a.params.renderThumb.call(a, e, t) : x("div", { class: "photo-browser-thumbs-slide swiper-slide", "data-swiper-slide-index": t }, s && x("img", { src: s, loading: "lazy" })) } render() { const e = this; return e.params.render ? e.params.render.call(e, e.params) : x("div", { class: `photo-browser photo-browser-${e.params.theme}` }, x("div", { class: "view" }, x("div", { class: `page photo-browser-page photo-browser-page-${e.params.theme} no-toolbar ${e.params.navbar ? "" : "no-navbar"}`, "data-name": "photo-browser-page" }, e.params.navbar && e.renderNavbar(), e.params.toolbar && e.renderToolbar(), e.params.thumbs && e.params.thumbs.length && e.renderThumbs(), x("div", { class: `photo-browser-captions photo-browser-captions-${e.params.captionsTheme || e.params.theme}` }, e.params.photos.map((t, a) => t.caption ? e.renderCaption(t.caption, a) : "")), x("div", { class: "photo-browser-swiper-container swiper" }, x("div", { class: "photo-browser-swiper-wrapper swiper-wrapper" }, !e.params.virtualSlides && e.params.photos.map((t, a) => t.html || (typeof t == "string" || t instanceof String) && t.indexOf("<") >= 0 && t.indexOf(">") >= 0 ? e.renderObject(t, a) : e.params.lazy === !0 ? e.renderLazyPhoto(t, a) : e.renderPhoto(t, a))))))) } renderStandalone() { const e = this; return e.params.renderStandalone ? e.params.renderStandalone.call(e) : `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${e.render()}</div>` } renderPage() { const e = this; return e.params.renderPage ? e.params.renderPage.call(e) : e.render() } renderPopup() { const e = this; return e.params.renderPopup ? e.params.renderPopup.call(e) : `<div class="popup photo-browser-popup">${e.render()}</div>` } onOpen(e, t) { const a = this, s = a.app, r = y(t); r[0].f7PhotoBrowser = a, a.$el = r, a.el = r[0], a.openedIn = e, a.opened = !0, a.$swiperContainerEl = a.$el.find(".photo-browser-swiper-container"), a.$swiperWrapperEl = a.$el.find(".photo-browser-swiper-wrapper"), a.slides = a.$el.find(".photo-browser-slide"), a.$captionsContainerEl = a.$el.find(".photo-browser-captions"), a.captions = a.$el.find(".photo-browser-caption"); const i = a.params.thumbs && a.params.thumbs.length > 0; let o, l, c; const d = a.activeIndex, u = R({}, a.params.swiper, { initialSlide: d, on: { click(m) { clearTimeout(o), a.params.exposition && (o = setTimeout(() => { a.expositionToggle() }, 350)), a.emit("local::tap", m), a.emit("local::click", m) }, doubleClick(m) { clearTimeout(o), a.emit("local::doubleTap", m), a.emit("local::doubleClick", m) }, slideChange() { const m = this; i && a.thumbsSwiper && !c && (l = !0, a.thumbsSwiper.slideTo(a.swiper.activeIndex), setTimeout(() => { l = !1 })), a.onSlideChange(m); for (var f = arguments.length, h = new Array(f), b = 0; b < f; b++)h[b] = arguments[b]; a.emit("local::slideChange", ...h) }, transitionStart() { for (var m = arguments.length, f = new Array(m), h = 0; h < m; h++)f[h] = arguments[h]; a.emit("local::transitionStart", ...f) }, transitionEnd() { for (var m = arguments.length, f = new Array(m), h = 0; h < m; h++)f[h] = arguments[h]; a.emit("local::transitionEnd", ...f) }, slideChangeTransitionStart() { const m = this; a.onSlideChange(m); for (var f = arguments.length, h = new Array(f), b = 0; b < f; b++)h[b] = arguments[b]; a.emit("local::slideChangeTransitionStart", ...h) }, slideChangeTransitionEnd() { for (var m = arguments.length, f = new Array(m), h = 0; h < m; h++)f[h] = arguments[h]; a.emit("local::slideChangeTransitionEnd", ...f) } } }); a.params.swipeToClose && a.params.type !== "page" && R(u.on, { touchStart(m, f) { a.onTouchStart(f), a.emit("local::touchStart", f) }, touchMoveOpposite(m, f) { a.onTouchMove(f), a.emit("local::touchMoveOpposite", f) }, touchEnd(m, f) { a.onTouchEnd(f), a.emit("local::touchEnd", f) } }), a.params.virtualSlides && R(u, { virtual: { slides: a.params.photos, renderSlide(m, f) { return m.html || (typeof m == "string" || m instanceof String) && m.indexOf("<") >= 0 && m.indexOf(">") >= 0 ? a.renderObject(m, f) : a.params.lazy === !0 ? a.renderLazyPhoto(m, f) : a.renderPhoto(m, f) } } }); const p = U(); if (a.swiper = s.swiper ? s.swiper.create(a.$swiperContainerEl[0], u) : new p.Swiper(a.$swiperContainerEl[0], u), (a.activeIndex === 0 || a.params.virtualSlides) && a.onSlideChange(a.swiper), i) { const m = { el: a.$el.find(".photo-browser-thumbs .swiper")[0], slidesPerView: "auto", centeredSlides: !0, spaceBetween: 4, watchSlidesProgress: !0, initialSlide: d, on: { touchMove() { c = !0 }, touchEnd() { c = !1 }, slideChange(f) { l || a.swiper.slideTo(f.activeIndex, 0) }, click(f) { if (!f.clickedSlide) return; const h = parseInt(y(f.clickedSlide).attr("data-swiper-slide-index"), 10); f.slideTo(h, 0) } } }; a.thumbsSwiper = s.swiper ? s.swiper.create(m) : new p.Swiper(m) } a.$el && a.$el.trigger("photobrowser:open"), a.emit("local::open photoBrowserOpen", a) } onOpened() { const e = this; e.$el && e.params.type === "standalone" && e.$el.css("animation", "none"), e.$el && e.$el.trigger("photobrowser:opened"), e.emit("local::opened photoBrowserOpened", e) } onClose() { const e = this; e.destroyed || (e.swiper && e.swiper.destroy && (e.swiper.destroy(!0, !1), e.swiper = null, delete e.swiper), e.thumbsSwiper && e.thumbsSwiper.destroy && (e.thumbsSwiper.destroy(!0, !1), e.thumbsSwiper = null, delete e.thumbsSwiper), e.$el && e.$el.trigger("photobrowser:close"), e.emit("local::close photoBrowserClose", e)) } onClosed() { const e = this; e.destroyed || (e.opened = !1, e.$el = null, e.el = null, delete e.$el, delete e.el, e.$el && e.$el.trigger("photobrowser:closed"), e.emit("local::closed photoBrowserClosed", e)) } openPage() { const e = this; if (e.opened) return e; const t = e.renderPage(); return e.view.router.navigate({ url: e.url, route: { content: t, path: e.url, on: { pageBeforeIn(a, s) { e.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${e.params.theme}`), e.onOpen("page", s.el) }, pageAfterIn(a, s) { e.onOpened("page", s.el) }, pageBeforeOut(a, s) { e.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${e.params.theme}`), e.onClose("page", s.el) }, pageAfterOut(a, s) { e.onClosed("page", s.el) } } } }), e } openStandalone() { const e = this; if (e.opened) return e; const a = { backdrop: !1, content: e.renderStandalone(), on: { popupOpen(s) { e.onOpen("popup", s.el) }, popupOpened(s) { e.onOpened("popup", s.el) }, popupClose(s) { e.onClose("popup", s.el) }, popupClosed(s) { e.onClosed("popup", s.el) } } }; return e.params.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, popup: a } }) : e.modal = e.app.popup.create(a).open(), e } openPopup() { const e = this; if (e.opened) return e; const a = { content: e.renderPopup(), push: e.params.popupPush, closeByBackdropClick: e.params.closeByBackdropClick, on: { popupOpen(s) { e.onOpen("popup", s.el) }, popupOpened(s) { e.onOpened("popup", s.el) }, popupClose(s) { e.onClose("popup", s.el) }, popupClosed(s) { e.onClosed("popup", s.el) } } }; return e.params.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, popup: a } }) : e.modal = e.app.popup.create(a).open(), e } expositionEnable() { const e = this; return e.params.type === "page" && e.view.$el.addClass("with-photo-browser-page-exposed"), e.$el && e.$el.addClass("photo-browser-exposed"), e.params.expositionHideCaptions && e.$captionsContainerEl.addClass("photo-browser-captions-exposed"), e.exposed = !0, e } expositionDisable() { const e = this; return e.params.type === "page" && e.view.$el.removeClass("with-photo-browser-page-exposed"), e.$el && e.$el.removeClass("photo-browser-exposed"), e.params.expositionHideCaptions && e.$captionsContainerEl.removeClass("photo-browser-captions-exposed"), e.exposed = !1, e } expositionToggle() { const e = this; return e.params.type === "page" && e.view.$el.toggleClass("with-photo-browser-page-exposed"), e.$el && e.$el.toggleClass("photo-browser-exposed"), e.params.expositionHideCaptions && e.$captionsContainerEl.toggleClass("photo-browser-captions-exposed"), e.exposed = !e.exposed, e } open(e) { const t = this, a = t.params.type; return t.opened ? (t.swiper && typeof e < "u" && t.swiper.slideTo(parseInt(e, 10)), t) : (typeof e < "u" && (t.activeIndex = e), a === "standalone" && t.openStandalone(), a === "page" && t.openPage(), a === "popup" && t.openPopup(), t) } close() { const e = this; return e.opened && (e.params.routableModals && e.view || e.openedIn === "page" ? e.view.router.back() : (e.modal.once("modalClosed", () => { $e(() => { e.destroyed || (e.modal.destroy(), delete e.modal) }) }), e.modal.close())), e } init() { } destroy() { let e = this; e.emit("local::beforeDestroy photoBrowserBeforeDestroy", e), e.$el && (e.$el.trigger("photobrowser:beforedestroy"), e.$el[0].f7PhotoBrowser = null, delete e.$el[0].f7PhotoBrowser), ve(e), e.destroyed = !0, e = null } }; const gu = { name: "photoBrowser", params: { photoBrowser: { photos: [], thumbs: [], exposition: !0, expositionHideCaptions: !1, type: "standalone", navbar: !0, toolbar: !0, theme: "light", captionsTheme: void 0, iconsColor: void 0, popupPush: !1, swipeToClose: !0, pageBackLinkText: "Back", popupCloseLinkText: void 0, popupCloseLinkIcon: !0, navbarOfText: "of", navbarShowCount: void 0, view: void 0, url: "photos/", routableModals: !1, virtualSlides: !0, lazy: !0, closeByBackdropClick: !0, renderNavbar: void 0, renderToolbar: void 0, renderCaption: void 0, renderObject: void 0, renderLazyPhoto: void 0, renderPhoto: void 0, renderThumb: void 0, renderPage: void 0, renderPopup: void 0, renderStandalone: void 0, swiper: { cssMode: !1, initialSlide: 0, spaceBetween: 20, speed: 300, loop: !1, keyboard: { enabled: !0 }, navigation: { nextEl: ".photo-browser-next", prevEl: ".photo-browser-prev" }, zoom: { enabled: !0, maxRatio: 3, minRatio: 1 } } } }, create() { const n = this; n.photoBrowser = we({ defaultSelector: ".photo-browser-popup, .photo-browser-page", constructor: Gn, app: n, domProp: "f7PhotoBrowser" }) }, static: { PhotoBrowser: Gn } }; let Un = class extends Ye { constructor(e, t) { const a = R({ on: {} }, e.params.notification, t); super(e, a); const s = this; s.app = e, s.params = a; const { icon: r, title: i, titleRightText: o, subtitle: l, text: c, closeButton: d, closeTimeout: u, cssClass: p, closeOnClick: m } = s.params; let f; if (s.params.el) f = y(s.params.el); else { const T = s.render({ icon: r, title: i, titleRightText: o, subtitle: l, text: c, closeButton: d, cssClass: p }); f = y(T) } if (f && f.length > 0 && f[0].f7Modal) return f[0].f7Modal; if (f.length === 0) return s.destroy(); R(s, { $el: f, el: f[0], type: "notification" }), f[0].f7Modal = s, d && f.find(".notification-close-button").on("click", () => { s.close() }), f.on("click", T => { d && y(T.target).closest(".notification-close-button").length || (s.emit("local::click notificationClick", s), m && s.close()) }), s.on("beforeDestroy", () => { f.off("click") }); let h, b, g, v, E, $; const w = {}; function C(T) { h || (h = !0, b = !1, g = void 0, E = Ie(), w.x = T.type === "touchstart" ? T.targetTouches[0].pageX : T.pageX, w.y = T.type === "touchstart" ? T.targetTouches[0].pageY : T.pageY) } function k(T) { if (!h) return; const I = T.type === "touchmove" ? T.targetTouches[0].pageX : T.pageX, H = T.type === "touchmove" ? T.targetTouches[0].pageY : T.pageY; if (typeof g > "u" && (g = !!(g || Math.abs(H - w.y) < Math.abs(I - w.x))), g) { h = !1; return } T.preventDefault(), b || (s.$el.removeClass("notification-transitioning"), s.$el.transition(0), $ = s.$el[0].offsetHeight / 2), b = !0, v = H - w.y; let D = v; v > 0 && (D = v ** .8), s.$el.transform(`translate3d(0, ${D}px, 0)`) } function M() { if (!h || !b) { h = !1, b = !1; return } if (h = !1, b = !1, v === 0) return; const T = Ie() - E; s.$el.transition(""), s.$el.addClass("notification-transitioning"), s.$el.transform(""), (v < -10 && T < 300 || -v >= $ / 1) && s.close() } function A() { s.$el.on(e.touchEvents.start, C, { passive: !0 }), e.on("touchmove:active", k), e.on("touchend:passive", M) } function O() { s.$el.off(e.touchEvents.start, C, { passive: !0 }), e.off("touchmove:active", k), e.off("touchend:passive", M) } let S; function P() { S = $e(() => { if (h && b) { P(); return } s.close() }, u) } return s.on("open", () => { s.params.swipeToClose && A(), y(".notification.modal-in").each(T => { const I = e.notification.get(T); T !== s.el && I && I.close() }), u && P() }), s.on("close beforeDestroy", () => { s.params.swipeToClose && O(), clearTimeout(S) }), s } render() { const e = this; if (e.params.render) return e.params.render.call(e, e); const { icon: t, title: a, titleRightText: s, subtitle: r, text: i, closeButton: o, cssClass: l } = e.params; return x("div", { class: `notification ${t ? "notification-with-icon" : ""} ${l || ""}` }, x("div", { class: "notification-header" }, t && x("div", { class: "notification-icon" }, t), a && x("div", { class: "notification-title" }, a), s && x("div", { class: "notification-title-right-text" }, s), o && x("span", { class: "notification-close-button" })), x("div", { class: "notification-content" }, r && x("div", { class: "notification-subtitle" }, r), i && x("div", { class: "notification-text" }, i))) } }; const vu = { name: "notification", static: { Notification: Un }, create() { const n = this; n.notification = R({}, Ze({ app: n, constructor: Un, defaultSelector: ".notification.modal-in" })) }, params: { notification: { icon: null, title: null, titleRightText: null, subtitle: null, text: null, closeButton: !1, closeTimeout: null, closeOnClick: !1, swipeToClose: !0, cssClass: null, render: null, containerEl: null } } }; let _n = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this; a.app = e; const s = ue(), r = R({ on: {} }, e.params.autocomplete); a.useModulesParams(r), a.params = R(r, t); let i; a.params.openerEl && (i = y(a.params.openerEl), i.length && (i[0].f7Autocomplete = a)); let o; a.params.inputEl && (o = y(a.params.inputEl), o.length && (o[0].f7Autocomplete = a)); const l = wt(); let c = t.url; !c && i && i.length && (i.attr("href") ? c = i.attr("href") : i.find("a").length > 0 && (c = i.find("a").attr("href"))), (!c || c === "#" || c === "") && (c = a.params.url); const d = a.params.multiple ? "checkbox" : "radio"; R(a, { $openerEl: i, openerEl: i && i[0], $inputEl: o, inputEl: o && o[0], id: l, url: c, value: a.params.value || [], inputType: d, inputName: `${d}-${l}`, $modalEl: void 0, $dropdownEl: void 0 }); let u = ""; function p() { let w = a.$inputEl.val().trim(); a.params.source && a.params.source.call(a, w, C => { let k = ""; const M = a.params.limit ? Math.min(a.params.limit, C.length) : C.length; a.items = C; let A; a.params.highlightMatches && (w = w.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), A = new RegExp(`(${w})`, "i")); let O, S; for (let P = 0; P < M; P += 1) { const T = typeof C[P] == "object" ? C[P][a.params.valueProperty] : C[P], I = typeof C[P] == "object" ? C[P][a.params.textProperty] : C[P]; P === 0 && (O = T, S = a.items[P]), k += a.renderItem({ value: T, text: a.params.highlightMatches ? I.replace(A, "<b>$1</b>") : I }, P) } if (k === "" && w === "" && a.params.dropdownPlaceholderText && (k += a.renderItem({ placeholder: !0, text: a.params.dropdownPlaceholderText })), a.$dropdownEl.find("ul").html(k), a.params.typeahead) { if (!O || !S || O.toLowerCase().indexOf(w.toLowerCase()) !== 0) return; if (u.toLowerCase() === w.toLowerCase()) { a.value = []; return } if (u.toLowerCase().indexOf(w.toLowerCase()) === 0) { u = w, a.value = []; return } o.val(O), o[0].setSelectionRange(w.length, O.length); const P = typeof a.value[0] == "object" ? a.value[0][a.params.valueProperty] : a.value[0]; (!P || O.toLowerCase() !== P.toLowerCase()) && (a.value = [S], a.emit("local::change autocompleteChange", [S])) } u = w }) } function m() { const w = this, C = w.value, k = y(w).parents(".autocomplete-values").length > 0; let M, A, O; if (k) { if (a.inputType === "checkbox" && !w.checked) { for (let S = 0; S < a.value.length; S += 1)O = typeof a.value[S] == "string" ? a.value[S] : a.value[S][a.params.valueProperty], (O === C || O * 1 === C * 1) && a.value.splice(S, 1); a.updateValues(), a.emit("local::change autocompleteChange", a.value) } return } for (let S = 0; S < a.items.length; S += 1)A = typeof a.items[S] == "object" ? a.items[S][a.params.valueProperty] : a.items[S], (A === C || A * 1 === C * 1) && (M = a.items[S]); if (a.inputType === "radio") a.value = [M]; else if (w.checked) a.value.push(M); else for (let S = 0; S < a.value.length; S += 1)O = typeof a.value[S] == "object" ? a.value[S][a.params.valueProperty] : a.value[S], (O === C || O * 1 === C * 1) && a.value.splice(S, 1); a.updateValues(), (a.inputType === "radio" && w.checked || a.inputType === "checkbox") && a.emit("local::change autocompleteChange", a.value) } function f(w) { const C = y(w.target); C.is(a.$inputEl[0]) || a.$dropdownEl && C.closest(a.$dropdownEl[0]).length || a.close() } function h() { a.open() } function b() { a.open() } function g() { a.$dropdownEl.find("label.active-state").length > 0 || setTimeout(() => { a.close() }, 0) } function v() { a.positionDropdown() } function E(w) { if (!a.opened) return; if (w.keyCode === 27) { w.preventDefault(), a.$inputEl.blur(); return } if (w.keyCode === 13) { const M = a.$dropdownEl.find(".autocomplete-dropdown-selected label"); if (M.length) { w.preventDefault(), M.trigger("click"), a.$inputEl.blur(); return } a.params.typeahead && (w.preventDefault(), a.$inputEl.blur()); return } if (w.keyCode !== 40 && w.keyCode !== 38) return; w.preventDefault(); const C = a.$dropdownEl.find(".autocomplete-dropdown-selected"); let k; C.length ? (k = C[w.keyCode === 40 ? "next" : "prev"]("li"), k.length || (k = a.$dropdownEl.find("li").eq(w.keyCode === 40 ? 0 : a.$dropdownEl.find("li").length - 1))) : k = a.$dropdownEl.find("li").eq(w.keyCode === 40 ? 0 : a.$dropdownEl.find("li").length - 1), !k.hasClass("autocomplete-dropdown-placeholder") && (C.removeClass("autocomplete-dropdown-selected"), k.addClass("autocomplete-dropdown-selected")) } function $() { const w = y(this); let C; for (let k = 0; k < a.items.length; k += 1) { const M = typeof a.items[k] == "object" ? a.items[k][a.params.valueProperty] : a.items[k], A = w.attr("data-value"); (M === A || M * 1 === A * 1) && (C = a.items[k]) } a.params.updateInputValueOnSelect && (a.$inputEl.val(typeof C == "object" ? C[a.params.valueProperty] : C), a.$inputEl.trigger("input change")), a.value = [C], a.emit("local::change autocompleteChange", [C]), a.close() } return a.attachEvents = function () { a.params.openIn !== "dropdown" && a.$openerEl && a.$openerEl.on("click", h), a.params.openIn === "dropdown" && a.$inputEl && (a.$inputEl.on("focus", b), a.$inputEl.on(a.params.inputEvents, p), s.android ? y("html").on("click", f) : a.$inputEl.on("blur", g), a.$inputEl.on("keydown", E)) }, a.detachEvents = function () { a.params.openIn !== "dropdown" && a.$openerEl && a.$openerEl.off("click", h), a.params.openIn === "dropdown" && a.$inputEl && (a.$inputEl.off("focus", b), a.$inputEl.off(a.params.inputEvents, p), s.android ? y("html").off("click", f) : a.$inputEl.off("blur", g), a.$inputEl.off("keydown", E)) }, a.attachDropdownEvents = function () { a.$dropdownEl.on("click", "label", $), e.on("resize", v) }, a.detachDropdownEvents = function () { a.$dropdownEl.off("click", "label", $), e.off("resize", v) }, a.attachPageEvents = function () { a.$el.on("change", 'input[type="radio"], input[type="checkbox"]', m), a.params.closeOnSelect && !a.params.multiple && a.$el.once("click", ".list label", () => { $e(() => { a.close() }) }) }, a.detachPageEvents = function () { a.$el.off("change", 'input[type="radio"], input[type="checkbox"]', m) }, a.useModules(), a.init(), a } get view() { const e = this, { $openerEl: t, $inputEl: a, app: s } = e; let r; if (e.params.view) r = e.params.view; else if (t || a) { const i = t || a; r = i.closest(".view").length && i.closest(".view")[0].f7View } return r || (r = s.views.main), r } positionDropdown() { const e = this, { $inputEl: t, app: a, $dropdownEl: s } = e, r = t.parents(".page-content"); if (r.length === 0) return; const i = t.offset(), o = t[0].offsetWidth, l = t[0].offsetHeight, c = t.parents(".list"); let d; c.parents().each(E => { if (d) return; const $ = y(E); $.parent(r).length && (d = $) }); const u = c.offset(), p = parseInt(r.css("padding-bottom"), 10), m = c.length > 0 ? u.left - r.offset().left : 0, f = i.left - (c.length > 0 ? u.left : 0) - (a.rtl, 0), h = i.top - (r.offset().top - r[0].scrollTop), b = r[0].scrollHeight - p - (h + r[0].scrollTop) - t[0].offsetHeight, g = a.rtl ? "padding-right" : "padding-left"; let v; c.length && (v = (a.rtl ? c[0].offsetWidth - f - o : f) - (a.theme === "md" ? 16 : 15)), s.css({ left: `${c.length > 0 ? m : f}px`, top: `${h + r[0].scrollTop + l}px`, width: `${c.length > 0 ? c[0].offsetWidth : o}px` }), s.children(".autocomplete-dropdown-inner").css({ maxHeight: `${b}px`, [g]: c.length > 0 ? `${v}px` : "" }) } focus() { this.$el.find("input[type=search]").focus() } source(e) { const t = this; if (!t.params.source) return; const { $el: a } = t; t.params.source.call(t, e, s => { let r = ""; const i = t.params.limit ? Math.min(t.params.limit, s.length) : s.length; t.items = s; for (let o = 0; o < i; o += 1) { let l = !1; const c = typeof s[o] == "object" ? s[o][t.params.valueProperty] : s[o]; for (let d = 0; d < t.value.length; d += 1) { const u = typeof t.value[d] == "object" ? t.value[d][t.params.valueProperty] : t.value[d]; (u === c || u * 1 === c * 1) && (l = !0) } r += t.renderItem({ value: c, text: typeof s[o] == "object" ? s[o][t.params.textProperty] : s[o], inputType: t.inputType, id: t.id, inputName: t.inputName, selected: l }, o) } a.find(".autocomplete-found ul").html(r), s.length === 0 ? e.length !== 0 ? (a.find(".autocomplete-not-found").show(), a.find(".autocomplete-found, .autocomplete-values").hide()) : (a.find(".autocomplete-values").show(), a.find(".autocomplete-found, .autocomplete-not-found").hide()) : (a.find(".autocomplete-found").show(), a.find(".autocomplete-not-found, .autocomplete-values").hide()) }) } updateValues() { const e = this; let t = ""; for (let a = 0; a < e.value.length; a += 1)t += e.renderItem({ value: typeof e.value[a] == "object" ? e.value[a][e.params.valueProperty] : e.value[a], text: typeof e.value[a] == "object" ? e.value[a][e.params.textProperty] : e.value[a], inputType: e.inputType, id: e.id, inputName: `${e.inputName}-checked}`, selected: !0 }, a); e.$el.find(".autocomplete-values ul").html(t) } preloaderHide() { const e = this; e.params.openIn === "dropdown" && e.$dropdownEl ? e.$dropdownEl.find(".autocomplete-preloader").removeClass("autocomplete-preloader-visible") : y(".autocomplete-preloader").removeClass("autocomplete-preloader-visible") } preloaderShow() { const e = this; e.params.openIn === "dropdown" && e.$dropdownEl ? e.$dropdownEl.find(".autocomplete-preloader").addClass("autocomplete-preloader-visible") : y(".autocomplete-preloader").addClass("autocomplete-preloader-visible") } renderPreloader() { const e = this, t = { iosPreloaderContent: ct, mdPreloaderContent: lt }; return x("div", { class: `autocomplete-preloader preloader ${e.params.preloaderColor ? `color-${e.params.preloaderColor}` : ""}` }, t[`${e.app.theme}PreloaderContent`] || "") } renderSearchbar() { const e = this; return e.params.renderSearchbar ? e.params.renderSearchbar.call(e) : x("form", { class: "searchbar" }, x("div", { class: "searchbar-inner" }, x("div", { class: "searchbar-input-wrap" }, x("input", { type: "search", spellcheck: e.params.searchbarSpellcheck || "false", placeholder: e.params.searchbarPlaceholder }), x("i", { class: "searchbar-icon" }), x("span", { class: "input-clear-button" })), e.params.searchbarDisableButton && x("span", { class: "searchbar-disable-button" }, e.params.searchbarDisableText))) } renderItem(e, t) { const a = this; if (a.params.renderItem) return a.params.renderItem.call(a, e, t); const s = e.value && typeof e.value == "string" ? e.value.replace(/"/g, "&quot;") : e.value; return a.params.openIn !== "dropdown" ? x("li", null, x("label", { class: `item-${e.inputType} item-content` }, x("input", { type: e.inputType, name: e.inputName, value: s, _checked: e.selected }), x("i", { class: `icon icon-${e.inputType}` }), x("div", { class: "item-inner" }, x("div", { class: "item-title" }, e.text)))) : e.placeholder ? x("li", { class: "autocomplete-dropdown-placeholder" }, x("label", { class: "item-content" }, x("div", { class: "item-inner" }, x("div", { class: "item-title" }, e.text)))) : x("li", null, x("label", { class: "item-radio item-content", "data-value": s }, x("div", { class: "item-inner" }, x("div", { class: "item-title" }, e.text)))) } renderNavbar() { const e = this; if (e.params.renderNavbar) return e.params.renderNavbar.call(e); let t = e.params.pageTitle; typeof t > "u" && e.$openerEl && e.$openerEl.length && (t = e.$openerEl.find(".item-title").text().trim()); const a = e.params.openIn === "popup", s = a ? e.params.preloader && x("div", { class: "left" }, e.renderPreloader()) : x("div", { class: "left sliding" }, x("a", { class: "link back" }, x("i", { class: "icon icon-back" }), x("span", { class: "if-not-md" }, e.params.pageBackLinkText))), r = a ? x("div", { class: "right" }, x("a", { class: "link popup-close", "data-popup": ".autocomplete-popup" }, e.params.popupCloseLinkText)) : e.params.preloader && x("div", { class: "right" }, e.renderPreloader()); return x("div", { class: `navbar ${e.params.navbarColorTheme ? `color-${e.params.navbarColorTheme}` : ""}` }, x("div", { class: "navbar-bg" }), x("div", { class: `navbar-inner ${e.params.navbarColorTheme ? `color-${e.params.navbarColorTheme}` : ""}` }, s, t && x("div", { class: "title sliding" }, t), r, x("div", { class: "subnavbar sliding" }, e.renderSearchbar()))) } renderDropdown() { const e = this; return e.params.renderDropdown ? e.params.renderDropdown.call(e, e.items) : x("div", { class: "autocomplete-dropdown" }, x("div", { class: "autocomplete-dropdown-inner" }, x("div", { class: "list no-safe-areas" }, x("ul", null))), e.params.preloader && e.renderPreloader()) } renderPage(e) { const t = this; return t.params.renderPage ? t.params.renderPage.call(t, t.items) : x("div", { class: "page page-with-subnavbar autocomplete-page", "data-name": "autocomplete-page" }, t.renderNavbar(e), x("div", { class: "searchbar-backdrop" }), x("div", { class: "page-content" }, x("div", { class: `list autocomplete-list autocomplete-found autocomplete-list-${t.id} ${t.params.formColorTheme ? `color-${t.params.formColorTheme}` : ""}` }, x("ul", null)), x("div", { class: "list autocomplete-not-found" }, x("ul", null, x("li", { class: "item-content" }, x("div", { class: "item-inner" }, x("div", { class: "item-title" }, t.params.notFoundText))))), x("div", { class: "list autocomplete-values" }, x("ul", null)))) } renderPopup() { const e = this; return e.params.renderPopup ? e.params.renderPopup.call(e, e.items) : x("div", { class: "popup autocomplete-popup" }, x("div", { class: "view" }, e.renderPage(!0), ";")) } onOpen(e, t) { const a = this, s = a.app, r = y(t); if (a.$el = r, a.el = r[0], a.openedIn = e, a.opened = !0, a.params.openIn === "dropdown") a.attachDropdownEvents(), a.$dropdownEl.addClass("autocomplete-dropdown-in"), a.$inputEl.trigger("input"); else { let i = r.find(".searchbar"); a.params.openIn === "page" && s.theme === "ios" && i.length === 0 && (i = y(s.navbar.getElByPage(r)).find(".searchbar")), a.searchbar = s.searchbar.create({ el: i, backdropEl: r.find(".searchbar-backdrop"), customSearch: !0, on: { search(o, l) { l.length === 0 && a.searchbar.enabled ? a.searchbar.backdropShow() : a.searchbar.backdropHide(), a.source(l) } } }), a.attachPageEvents(), a.updateValues(), a.params.requestSourceOnOpen && a.source("") } a.emit("local::open autocompleteOpen", a) } autoFocus() { const e = this; return e.searchbar && e.searchbar.$inputEl && e.searchbar.$inputEl.focus(), e } onOpened() { const e = this; e.params.openIn !== "dropdown" && e.params.autoFocus && e.autoFocus(), e.emit("local::opened autocompleteOpened", e) } onClose() { const e = this; e.destroyed || (e.searchbar && e.searchbar.destroy && (e.searchbar.destroy(), e.searchbar = null, delete e.searchbar), e.params.openIn === "dropdown" ? (e.detachDropdownEvents(), e.$dropdownEl.removeClass("autocomplete-dropdown-in").remove()) : e.detachPageEvents(), e.emit("local::close autocompleteClose", e)) } onClosed() { const e = this; e.destroyed || (e.opened = !1, e.$el = null, e.el = null, delete e.$el, delete e.el, e.emit("local::closed autocompleteClosed", e)) } openPage() { const e = this; if (e.opened) return e; const t = e.renderPage(); return e.view.router.navigate({ url: e.url, route: { content: t, path: e.url, on: { pageBeforeIn(a, s) { e.onOpen("page", s.el) }, pageAfterIn(a, s) { e.onOpened("page", s.el) }, pageBeforeOut(a, s) { e.onClose("page", s.el) }, pageAfterOut(a, s) { e.onClosed("page", s.el) } }, options: { animate: e.params.animate } } }), e } openPopup() { const e = this; if (e.opened) return e; const a = { content: e.renderPopup(), animate: e.params.animate, push: e.params.popupPush, swipeToClose: e.params.popupSwipeToClose, on: { popupOpen(s) { e.onOpen("popup", s.el) }, popupOpened(s) { e.onOpened("popup", s.el) }, popupClose(s) { e.onClose("popup", s.el) }, popupClosed(s) { e.onClosed("popup", s.el) } } }; return e.params.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, popup: a } }) : e.modal = e.app.popup.create(a).open(e.params.animate), e } openDropdown() { const e = this; e.$dropdownEl || (e.$dropdownEl = y(e.renderDropdown())); const t = e.$inputEl.parents(".page-content"); e.params.dropdownContainerEl ? y(e.params.dropdownContainerEl).append(e.$dropdownEl) : t.length === 0 ? e.$dropdownEl.insertAfter(e.$inputEl) : (e.positionDropdown(), t.append(e.$dropdownEl)), e.onOpen("dropdown", e.$dropdownEl), e.onOpened("dropdown", e.$dropdownEl) } open() { const e = this; if (e.opened) return e; const t = e.params.openIn; return e[`open${t.split("").map((a, s) => s === 0 ? a.toUpperCase() : a).join("")}`](), e } close() { const e = this; return e.opened && (e.params.openIn === "dropdown" ? (e.onClose(), e.onClosed()) : e.params.routableModals && e.view || e.openedIn === "page" ? e.view.router.back({ animate: e.params.animate }) : (e.modal.once("modalClosed", () => { $e(() => { e.destroyed || (e.modal.destroy(), delete e.modal) }) }), e.modal.close())), e } init() { this.attachEvents() } destroy() { const e = this; e.emit("local::beforeDestroy autocompleteBeforeDestroy", e), e.detachEvents(), e.$inputEl && e.$inputEl[0] && delete e.$inputEl[0].f7Autocomplete, e.$openerEl && e.$openerEl[0] && delete e.$openerEl[0].f7Autocomplete, ve(e), e.destroyed = !0 } }; const bu = { name: "autocomplete", params: { autocomplete: { openerEl: void 0, inputEl: void 0, view: void 0, dropdownContainerEl: void 0, dropdownPlaceholderText: void 0, typeahead: !1, highlightMatches: !0, updateInputValueOnSelect: !0, inputEvents: "input", value: void 0, multiple: !1, source: void 0, limit: void 0, valueProperty: "id", textProperty: "text", openIn: "page", pageBackLinkText: "Back", popupCloseLinkText: "Close", pageTitle: void 0, searchbarPlaceholder: "Search...", searchbarDisableText: "Cancel", searchbarDisableButton: !0, searchbarSpellcheck: !1, popupPush: !1, popupSwipeToClose: void 0, animate: !0, autoFocus: !1, closeOnSelect: !1, notFoundText: "Nothing found", requestSourceOnOpen: !1, preloaderColor: void 0, preloader: !1, formColorTheme: void 0, navbarColorTheme: void 0, routableModals: !1, url: "select/", renderDropdown: void 0, renderPage: void 0, renderPopup: void 0, renderItem: void 0, renderSearchbar: void 0, renderNavbar: void 0 } }, static: { Autocomplete: _n }, create() { const n = this; n.autocomplete = R(we({ defaultSelector: void 0, constructor: _n, app: n, domProp: "f7Autocomplete" }), { open(e) { const t = n.autocomplete.get(e); if (t && t.open) return t.open() }, close(e) { const t = n.autocomplete.get(e); if (t && t.close) return t.close() } }) } }; let Kn = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = Ee(), r = R({}, e.params.tooltip), i = ee(); a.useModulesParams(r), a.params = R(r, t), typeof t.offset > "u" && s.touch && a.params.trigger === "hover" && (a.params.offset = 10); const { targetEl: o, containerEl: l } = a.params; if (!o && !a.params.delegated) return a; const c = y(o); if (c.length === 0 && !a.params.delegated) return a; if (c[0] && c[0].f7Tooltip && !a.params.delegated) return c[0].f7Tooltip; let d = y(l || e.$el).eq(0); d.length === 0 && (d = e.$el); const u = y(a.render()).eq(0); R(a, { app: e, $targetEl: c, targetEl: c && c[0], $containerEl: d, containerEl: d && d[0], $el: u, el: u && u[0], text: a.params.text || "", visible: !1, opened: !1 }), c[0] && (c[0].f7Tooltip = a); const p = {}; let m; function f() { a.opened ? a.hide() : a.show(this) } function h(C) { a.opened && (y(C.target).closest(c).length || y(C.target).closest(a.$el).length) || a.hide() } function b(C) { m || (m = !0, p.x = C.type === "touchstart" ? C.targetTouches[0].pageX : C.pageX, p.y = C.type === "touchstart" ? C.targetTouches[0].pageY : C.pageY, a.show(this)) } function g(C) { if (!m) return; const k = C.type === "touchmove" ? C.targetTouches[0].pageX : C.pageX, M = C.type === "touchmove" ? C.targetTouches[0].pageY : C.pageY; ((k - p.x) ** 2 + (M - p.y) ** 2) ** .5 > 50 && (m = !1, a.hide()) } function v() { m && (m = !1, a.hide()) } function E() { a.show(this) } function $() { a.hide() } function w() { u.hasClass("tooltip-in") || u.removeClass("tooltip-out").remove() } return a.attachEvents = function () { if (u.on("transitionend", w), a.params.trigger === "click") { a.params.delegated ? y(i).on("click", a.params.targetEl, f) : a.$targetEl.on("click", f), y("html").on("click", h); return } if (a.params.trigger !== "manual") if (s.touch) { const k = s.passiveListener ? { passive: !0 } : !1; a.params.delegated ? y(i).on(e.touchEvents.start, a.params.targetEl, b, k) : a.$targetEl.on(e.touchEvents.start, b, k), e.on("touchmove", g), e.on("touchend:passive", v) } else a.params.delegated ? (y(i).on(s.pointerEvents ? "pointerenter" : "mouseenter", a.params.targetEl, E, !0), y(i).on(s.pointerEvents ? "pointerleave" : "mouseleave", a.params.targetEl, $, !0)) : (a.$targetEl.on(s.pointerEvents ? "pointerenter" : "mouseenter", E), a.$targetEl.on(s.pointerEvents ? "pointerleave" : "mouseleave", $)) }, a.detachEvents = function () { if (u.off("transitionend", w), a.params.trigger === "click") { a.params.delegated ? y(i).on("click", a.params.targetEl, f) : a.$targetEl.off("click", f), y("html").off("click", h); return } if (a.params.trigger !== "manual") if (s.touch) { const k = s.passiveListener ? { passive: !0 } : !1; a.params.delegated ? y(i).off(e.touchEvents.start, a.params.targetEl, b, k) : a.$targetEl.off(e.touchEvents.start, b, k), e.off("touchmove", g), e.off("touchend:passive", v) } else a.params.delegated ? (y(i).off(s.pointerEvents ? "pointerenter" : "mouseenter", a.params.targetEl, E, !0), y(i).off(s.pointerEvents ? "pointerleave" : "mouseleave", a.params.targetEl, $, !0)) : (a.$targetEl.off(s.pointerEvents ? "pointerenter" : "mouseenter", E), a.$targetEl.off(s.pointerEvents ? "pointerleave" : "mouseleave", $)) }, a.useModules(), a.init(), a } setTargetEl(e) { const t = this; return t.detachEvents(), t.$targetEl = y(e), t.targetEl = t.$targetEl[0], t.attachEvents(), t } position(e) { const t = this, { $el: a, app: s, $containerEl: r } = t, i = !!t.params.containerEl, o = t.params.offset || 0; a.css({ left: "", top: "" }); const l = y(e || t.targetEl), [c, d] = [a.width(), a.height()]; a.css({ left: "", top: "" }); let u, p, m, f; const h = i && r.length ? r[0].getBoundingClientRect() : s; if (l && l.length > 0) { if (u = l.outerWidth(), p = l.outerHeight(), typeof u > "u" && typeof p > "u") { const w = l[0].getBoundingClientRect(); u = w.width, p = w.height } const E = l.offset(); m = E.left - h.left, f = E.top - h.top; const $ = l.parents(".page"); $.length > 0 && (f -= $[0].scrollTop) } let [b, g] = [0, 0, 0], v = "top"; d + o < f ? g = f - d - o : d < h.height - f - p ? (v = "bottom", g = f + p + o) : (v = "middle", g = p / 2 + f - d / 2, g <= 0 ? g = 8 : g + d >= h.height && (g = h.height - d - 8)), v === "top" || v === "bottom" ? (b = u / 2 + m - c / 2, b < 8 && (b = 8), b + c > h.width && (b = h.width - c - 8), b < 0 && (b = 0)) : v === "middle" && (b = m - c, (b < 8 || b + c > h.width) && (b < 8 && (b = m + u), b + c > h.width && (b = h.width - c - 8))), a.css({ top: `${g}px`, left: `${b}px` }) } show(e) { const t = this, { $el: a, $targetEl: s, $containerEl: r } = t; r[0] && a[0] && !r[0].contains(a[0]) && r.append(a), t.position(e); const i = y(e); return t.visible = !0, t.opened = !0, s.trigger("tooltip:show"), a.trigger("tooltip:show"), i.length && i[0] !== s[0] && i.trigger("tooltip:show"), t.emit("local::show tooltipShow", t), a.removeClass("tooltip-out").addClass("tooltip-in"), t } hide() { const e = this, { $el: t, $targetEl: a } = e; return e.visible = !1, e.opened = !1, a.trigger("tooltip:hide"), t.trigger("tooltip:hide"), e.emit("local::hide tooltipHide", e), t.addClass("tooltip-out").removeClass("tooltip-in"), e } render() {
    const e = this; if (e.params.render) return e.params.render.call(e, e); const { cssClass: t, text: a } = e.params; return `
      <div class="tooltip ${t || ""}">
        <div class="tooltip-content">${a || ""}</div>
      </div>
    `.trim()
  } setText(e) { const t = this; return typeof e > "u" || (t.params.text = e, t.text = e, t.$el && t.$el.children(".tooltip-content").html(e), t.opened && t.position()), t } init() { this.attachEvents() } destroy() { const e = this; !e.$targetEl || e.destroyed || (e.$targetEl.trigger("tooltip:beforedestroy"), e.emit("local::beforeDestroy tooltipBeforeDestroy", e), e.$el.remove(), e.$targetEl[0] && delete e.$targetEl[0].f7Tooltip, e.detachEvents(), ve(e), e.destroyed = !0) }
}; const yu = { name: "tooltip", static: { Tooltip: Kn }, create() { const n = this; n.tooltip = we({ defaultSelector: ".tooltip", constructor: Kn, app: n, domProp: "f7Tooltip" }), n.tooltip.show = function (t) { const a = y(t); if (a.length === 0) return; const s = a[0].f7Tooltip; if (s) return s.show(a[0]), s }, n.tooltip.hide = function (t) { const a = y(t); if (a.length === 0) return; const s = a[0].f7Tooltip; if (s) return s.hide(), s }, n.tooltip.setText = function (t, a) { const s = y(t); if (s.length === 0) return; const r = s[0].f7Tooltip; if (r) return r.setText(a), r } }, params: { tooltip: { targetEl: null, delegated: !1, text: null, cssClass: null, render: null, offset: 0, trigger: "hover", containerEl: void 0 } }, on: { tabMounted(n) { const e = this; y(n).find(".tooltip-init").each(t => { const a = y(t).attr("data-tooltip"); a && e.tooltip.create({ targetEl: t, text: a }) }) }, tabBeforeRemove(n) { y(n).find(".tooltip-init").each(e => { e.f7Tooltip && e.f7Tooltip.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".tooltip-init").each(t => { const a = y(t).attr("data-tooltip"); a && e.tooltip.create({ targetEl: t, text: a }) }), e.theme === "ios" && n.view && n.view.router.dynamicNavbar && n.$navbarEl && n.$navbarEl.length > 0 && n.$navbarEl.find(".tooltip-init").each(t => { const a = y(t).attr("data-tooltip"); a && e.tooltip.create({ targetEl: t, text: a }) }) }, pageBeforeRemove(n) { const e = this; n.$el.find(".tooltip-init").each(t => { t.f7Tooltip && t.f7Tooltip.destroy() }), e.theme === "ios" && n.view && n.view.router.dynamicNavbar && n.$navbarEl && n.$navbarEl.length > 0 && n.$navbarEl.find(".tooltip-init").each(t => { t.f7Tooltip && t.f7Tooltip.destroy() }) } }, vnode: { "tooltip-init": { insert(n) { const e = this, t = n.elm, a = y(t).attr("data-tooltip"); a && e.tooltip.create({ targetEl: t, text: a }) }, update(n) { const e = n.elm; e.f7Tooltip && n && n.data && n.data.attrs && n.data.attrs["data-tooltip"] && e.f7Tooltip.setText(n.data.attrs["data-tooltip"]) }, destroy(n) { const e = n.elm; e.f7Tooltip && e.f7Tooltip.destroy() } } } }; let Qn = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = R({}, e.params.gauge); a.useModulesParams(s), a.params = R(s, t); const { el: r } = a.params; if (!r) return a; const i = y(r); return i.length === 0 ? a : i[0].f7Gauge ? i[0].f7Gauge : (R(a, { app: e, $el: i, el: i && i[0] }), i[0].f7Gauge = a, a.useModules(), a.init(), a) } calcRadius() { const e = this, { size: t, borderWidth: a } = e.params; return t / 2 - a / 2 } calcBorderLength() { const t = this.calcRadius(); return 2 * Math.PI * t } render() { const e = this; if (e.params.render) return e.params.render.call(e, e); const { type: t, value: a, size: s, bgColor: r, borderBgColor: i, borderColor: o, borderWidth: l, valueText: c, valueTextColor: d, valueFontSize: u, valueFontWeight: p, labelText: m, labelTextColor: f, labelFontSize: h, labelFontWeight: b } = e.params, g = t === "semicircle", v = e.calcRadius(), E = e.calcBorderLength(), $ = Math.max(Math.min(a, 1), 0); return x("svg", { class: "gauge-svg", width: `${s}px`, height: `${g ? s / 2 : s}px`, viewBox: `0 0 ${s} ${g ? s / 2 : s}` }, g && x("path", { class: "gauge-back-semi", d: `M${s - l / 2},${s / 2} a1,1 0 0,0 -${s - l},0`, stroke: i, "stroke-width": l, fill: r || "none" }), g && x("path", { class: "gauge-front-semi", d: `M${s - l / 2},${s / 2} a1,1 0 0,0 -${s - l},0`, stroke: o, "stroke-width": l, "stroke-dasharray": E / 2, "stroke-dashoffset": E / 2 * (1 + $), fill: i ? "none" : r || "none" }), !g && i && x("circle", { class: "gauge-back-circle", stroke: i, "stroke-width": l, fill: r || "none", cx: s / 2, cy: s / 2, r: v }), !g && x("circle", { class: "gauge-front-circle", transform: `rotate(-90 ${s / 2} ${s / 2})`, stroke: o, "stroke-width": l, "stroke-dasharray": E, "stroke-dashoffset": E * (1 - $), fill: i ? "none" : r || "none", cx: s / 2, cy: s / 2, r: v }), c && x("text", { class: "gauge-value-text", x: "50%", y: g ? "100%" : "50%", "font-weight": p, "font-size": u, fill: d, dy: g ? m ? -h - 15 : -5 : 0, "text-anchor": "middle", "dominant-baseline": !g && "middle" }, c), m && x("text", { class: "gauge-label-text", x: "50%", y: g ? "100%" : "50%", "font-weight": b, "font-size": h, fill: f, dy: g ? -5 : c ? u / 2 + 10 : 0, "text-anchor": "middle", "dominant-baseline": !g && "middle" }, m)) } update(e) { e === void 0 && (e = {}); const t = this, a = ee(), { params: s, $svgEl: r } = t; if (Object.keys(e).forEach(A => { typeof e[A] < "u" && (s[A] = e[A]) }), r.length === 0) return t; const { value: i, size: o, bgColor: l, borderBgColor: c, borderColor: d, borderWidth: u, valueText: p, valueTextColor: m, valueFontSize: f, valueFontWeight: h, labelText: b, labelTextColor: g, labelFontSize: v, labelFontWeight: E } = s, $ = t.calcBorderLength(), w = Math.max(Math.min(i, 1), 0), C = t.calcRadius(), k = s.type === "semicircle", M = { width: `${o}px`, height: `${k ? o / 2 : o}px`, viewBox: `0 0 ${o} ${k ? o / 2 : o}` }; if (Object.keys(M).forEach(A => { r.attr(A, M[A]) }), k) { const A = { d: `M${o - u / 2},${o / 2} a1,1 0 0,0 -${o - u},0`, stroke: c, "stroke-width": u, fill: l || "none" }, O = { d: `M${o - u / 2},${o / 2} a1,1 0 0,0 -${o - u},0`, stroke: d, "stroke-width": u, "stroke-dasharray": $ / 2, "stroke-dashoffset": $ / 2 * (1 + w), fill: c ? "none" : l || "none" }; Object.keys(A).forEach(S => { r.find(".gauge-back-semi").attr(S, A[S]) }), Object.keys(O).forEach(S => { r.find(".gauge-front-semi").attr(S, O[S]) }) } else { const A = { stroke: c, "stroke-width": u, fill: l || "none", cx: o / 2, cy: o / 2, r: C }, O = { transform: `rotate(-90 ${o / 2} ${o / 2})`, stroke: d, "stroke-width": u, "stroke-dasharray": $, "stroke-dashoffset": $ * (1 - w), fill: c ? "none" : l || "none", cx: o / 2, cy: o / 2, r: C }; Object.keys(A).forEach(S => { r.find(".gauge-back-circle").attr(S, A[S]) }), Object.keys(O).forEach(S => { r.find(".gauge-front-circle").attr(S, O[S]) }) } if (p) { if (!r.find(".gauge-value-text").length) { const O = a.createElementNS("http://www.w3.org/2000/svg", "text"); O.classList.add("gauge-value-text"), r.append(O) } const A = { x: "50%", y: k ? "100%" : "50%", "font-weight": h, "font-size": f, fill: m, dy: k ? b ? -v - 15 : -5 : 0, "text-anchor": "middle", "dominant-baseline": !k && "middle" }; Object.keys(A).forEach(O => { r.find(".gauge-value-text").attr(O, A[O]) }), r.find(".gauge-value-text").text(p) } else r.find(".gauge-value-text").remove(); if (b) { if (!r.find(".gauge-label-text").length) { const O = a.createElementNS("http://www.w3.org/2000/svg", "text"); O.classList.add("gauge-label-text"), r.append(O) } const A = { x: "50%", y: k ? "100%" : "50%", "font-weight": E, "font-size": v, fill: g, dy: k ? -5 : p ? f / 2 + 10 : 0, "text-anchor": "middle", "dominant-baseline": !k && "middle" }; Object.keys(A).forEach(O => { r.find(".gauge-label-text").attr(O, A[O]) }), r.find(".gauge-label-text").text(b) } else r.find(".gauge-label-text").remove(); return t } init() { const e = this, t = y(e.render()).eq(0); return t.f7Gauge = e, R(e, { $svgEl: t, svgEl: t && t[0] }), e.$el.append(t), e } destroy() { const e = this; !e.$el || e.destroyed || (e.$el.trigger("gauge:beforedestroy"), e.emit("local::beforeDestroy gaugeBeforeDestroy", e), e.$svgEl.remove(), delete e.$el[0].f7Gauge, ve(e), e.destroyed = !0) } }; const Eu = { name: "gauge", static: { Gauge: Qn }, create() { const n = this; n.gauge = we({ defaultSelector: ".gauge", constructor: Qn, app: n, domProp: "f7Gauge" }), n.gauge.update = function (t, a) { if (y(t).length === 0) return; const r = n.gauge.get(t); if (r) return r.update(a), r } }, params: { gauge: { el: null, type: "circle", value: 0, size: 200, bgColor: "transparent", borderBgColor: "#eeeeee", borderColor: "#000000", borderWidth: 10, valueText: null, valueTextColor: "#000000", valueFontSize: 31, valueFontWeight: 500, labelText: null, labelTextColor: "#888888", labelFontSize: 14, labelFontWeight: 400 } }, on: { tabMounted(n) { const e = this; y(n).find(".gauge-init").each(t => { e.gauge.create(R({ el: t }, y(t).dataset() || {})) }) }, tabBeforeRemove(n) { y(n).find(".gauge-init").each(e => { e.f7Gauge && e.f7Gauge.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".gauge-init").each(t => { e.gauge.create(R({ el: t }, y(t).dataset() || {})) }) }, pageBeforeRemove(n) { n.$el.find(".gauge-init").each(e => { e.f7Gauge && e.f7Gauge.destroy() }) } }, vnode: { "gauge-init": { insert(n) { const e = this, t = n.elm; e.gauge.create(R({ el: t }, y(t).dataset() || {})) }, destroy(n) { const e = n.elm; e.f7Gauge && e.f7Gauge.destroy() } } } }, wu = { name: "skeleton" }, Cu = { render(n) { const { sliderLabel: e, sliderValue: t, sliderValueEditable: a, alphaLabelText: s } = n.params; return x("div", { class: "color-picker-module color-picker-module-alpha-slider" }, x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, s), x("div", { class: "range-slider color-picker-slider color-picker-slider-alpha" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "0.01", min: "0", max: "1", class: "color-picker-value-alpha" }) : x("span", { class: "color-picker-value-alpha" })))) }, init(n) { n.alphaRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-alpha"), min: 0, max: 1, step: .01, value: 1, on: { change(t, a) { const s = Math.floor(a * 100) / 100; n.setValue({ alpha: s }) } } }); function e(t) { const a = n.value.alpha; let s = parseFloat(t.target.value); if (Number.isNaN(s)) { t.target.value = a; return } s = Math.max(0, Math.min(1, s)), n.setValue({ alpha: s }) } n.$el.on("change", ".color-picker-module-alpha-slider input", e), n.destroyAlphaSliderEvents = function () { n.$el.off("change", ".color-picker-module-alpha-slider input", e) } }, update(n) { const { value: e } = n, { sliderValue: t, sliderValueEditable: a } = n.params, { alpha: s } = e; n.alphaRangeSlider.value = s, n.alphaRangeSlider.layout(), t && a ? n.$el.find("input.color-picker-value-alpha").val(s) : n.$el.find("span.color-picker-value-alpha").text(s) }, destroy(n) { n.alphaRangeSlider && n.alphaRangeSlider.destroy && n.alphaRangeSlider.destroy(), delete n.alphaRangeSlider, n.destroyAlphaSliderEvents && n.destroyAlphaSliderEvents(), delete n.destroyAlphaSliderEvents } }, $u = { render() { return x("div", { class: "color-picker-module color-picker-module-current-color" }, x("div", { class: "color-picker-current-color" })) }, update(n) { n.$el.find(".color-picker-module-current-color .color-picker-current-color").css("background-color", n.value.hex) } }, xu = { render(n) { const { hexLabel: e, hexLabelText: t, hexValueEditable: a } = n.params; return x("div", { class: "color-picker-module color-picker-module-hex" }, x("div", { class: "color-picker-hex-wrap" }, e && x("div", { class: "color-picker-hex-label" }, t), x("div", { class: "color-picker-hex-value" }, a ? x("input", { type: "text", class: "color-picker-value-hex" }) : x("span", { class: "color-picker-value-hex" })))) }, init(n) { function e(t) { const a = n.value.hex; let s = t.target.value.replace(/#/g, ""); if (Number.isNaN(s) || !s || s.length !== 3 && s.length !== 6) { t.target.value = a; return } const r = 0, i = parseInt(s, 16), o = parseInt("ffffff", 16); i > o && (s = "fff"), i < r && (s = "000"), n.setValue({ hex: s }) } n.$el.on("change", ".color-picker-module-hex input", e), n.destroyHexEvents = function () { n.$el.off("change", ".color-picker-module-hex input", e) } }, update(n) { const { value: e } = n, { hexValueEditable: t } = n.params, { hex: a } = e; t ? n.$el.find("input.color-picker-value-hex").val(a) : n.$el.find("span.color-picker-value-hex").text(a) }, destroy(n) { n.destroyHexEvents && n.destroyHexEvents(), delete n.destroyHexEvents } }, ku = { render(n) { const { sliderLabel: e, sliderValue: t, sliderValueEditable: a, hueLabelText: s, saturationLabelText: r, brightnessLabelText: i } = n.params; return x("div", { class: "color-picker-module color-picker-module-hsb-sliders" }, x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, s), x("div", { class: "range-slider color-picker-slider color-picker-slider-hue" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "0.1", min: "0", max: "360", class: "color-picker-value-hue", "data-color-index": "0" }) : x("span", { class: "color-picker-value-hue" }))), x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, r), x("div", { class: "range-slider color-picker-slider color-picker-slider-saturation" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "0.1", min: "0", max: "100", class: "color-picker-value-saturation", "data-color-index": "1" }) : x("span", { class: "color-picker-value-saturation" }))), x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, i), x("div", { class: "range-slider color-picker-slider color-picker-slider-brightness" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "0.1", min: "0", max: "100", class: "color-picker-value-brightness", "data-color-index": "2" }) : x("span", { class: "color-picker-value-brightness" })))) }, init(n) { n.hueRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-hue"), min: 0, max: 360, step: .1, value: 0, on: { change(t, a) { n.setValue({ hue: a }) } } }), n.saturationRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-saturation"), min: 0, max: 1, step: .001, value: 0, on: { change(t, a) { const s = Math.floor(a * 1e3) / 1e3; n.setValue({ hsb: [n.value.hsb[0], s, n.value.hsb[2]] }) } } }), n.brightnessRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-brightness"), min: 0, max: 1, step: .001, value: 0, on: { change(t, a) { const s = Math.floor(a * 1e3) / 1e3; n.setValue({ hsb: [n.value.hsb[0], n.value.hsb[1], s] }) } } }); function e(t) { const a = [...n.value.hsb], s = parseInt(y(t.target).attr("data-color-index"), 10); let r = parseFloat(t.target.value); if (Number.isNaN(r)) { t.target.value = a[s]; return } s === 0 ? r = Math.max(0, Math.min(360, r)) : r = Math.max(0, Math.min(100, r)) / 100, a[s] = r, n.setValue({ hsb: a }) } n.$el.on("change", ".color-picker-module-hsb-sliders input", e), n.destroyHsbSlidersEvents = function () { n.$el.off("change", ".color-picker-module-hsb-sliders input", e) } }, update(n) { const { app: e, value: t } = n, { sliderValue: a, sliderValueEditable: s } = n.params, { hsb: r, hue: i } = t; n.hueRangeSlider.value = i, n.saturationRangeSlider.value = r[1], n.brightnessRangeSlider.value = r[2], n.hueRangeSlider.layout(), n.saturationRangeSlider.layout(), n.brightnessRangeSlider.layout(); const o = Qe(r[0], r[1], 1), l = Qe(r[0], 0, 1), c = Qe(r[0], 1, 1), d = r[2]; n.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${i}, 100%, 50%)`), n.saturationRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${o[0]}, ${o[1] * 100}%, ${o[2] * 100}%)`), n.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${d * 255}, ${d * 255}, ${d * 255})`), n.saturationRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${e.rtl ? "to left" : "to right"}, hsl(${l[0]}, ${l[1] * 100}%, ${l[2] * 100}%), hsl(${c[0]}, ${c[1] * 100}%, ${c[2] * 100}%))`), a && s ? (n.$el.find("input.color-picker-value-hue").val(`${i}`), n.$el.find("input.color-picker-value-saturation").val(`${r[1] * 1e3 / 10}`), n.$el.find("input.color-picker-value-brightness").val(`${r[2] * 1e3 / 10}`)) : a && (n.$el.find("span.color-picker-value-hue").text(`${i}`), n.$el.find("span.color-picker-value-saturation").text(`${r[1] * 1e3 / 10}`), n.$el.find("span.color-picker-value-brightness").text(`${r[2] * 1e3 / 10}`)) }, destroy(n) { n.hueRangeSlider && n.hueRangeSlider.destroy && n.hueRangeSlider.destroy(), n.saturationRangeSlider && n.saturationRangeSlider.destroy && n.saturationRangeSlider.destroy(), n.brightnessRangeSlider && n.brightnessRangeSlider.destroy && n.brightnessRangeSlider.destroy(), delete n.hueRangeSlider, delete n.saturationRangeSlider, delete n.brightnessRangeSlider, n.destroyHsbSlidersEvents && n.destroyHsbSlidersEvents(), delete n.destroyHsbSlidersEvents } }, Tu = { render(n) { const { sliderLabel: e, sliderValue: t, sliderValueEditable: a, hueLabelText: s } = n.params; return x("div", { class: "color-picker-module color-picker-module-hue-slider" }, x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, s), x("div", { class: "range-slider color-picker-slider color-picker-slider-hue" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "0.1", min: "0", max: "360", class: "color-picker-value-hue" }) : x("span", { class: "color-picker-value-hue" })))) }, init(n) { n.hueRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-hue"), min: 0, max: 360, step: .1, value: 0, on: { change(e, t) { n.setValue({ hue: t }) } } }) }, update(n) { const { value: e } = n, { sliderValue: t, sliderValueEditable: a } = n.params, { hue: s } = e; n.hueRangeSlider.value = s, n.hueRangeSlider.layout(), n.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${s}, 100%, 50%)`), t && a ? n.$el.find("input.color-picker-value-hue").val(`${s}`) : t && n.$el.find("span.color-picker-value-hue").text(`${s}`) }, destroy(n) { n.hueRangeSlider && n.hueRangeSlider.destroy && n.hueRangeSlider.destroy(), delete n.hueRangeSlider } }, Su = { render(n) { const { sliderLabel: e, sliderValue: t, sliderValueEditable: a, brightnessLabelText: s } = n.params; return x("div", { class: "color-picker-module color-picker-module-brightness-slider" }, x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, s), x("div", { class: "range-slider color-picker-slider color-picker-slider-brightness" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "0.1", min: "0", max: "100", class: "color-picker-value-brightness" }) : x("span", { class: "color-picker-value-brightness" })))) }, init(n) { n.brightnessRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-brightness"), min: 0, max: 1, step: .001, value: 0, on: { change(e, t) { const a = Math.floor(t * 1e3) / 1e3; n.setValue({ hsb: [n.value.hsb[0], n.value.hsb[1], a] }) } } }) }, update(n) { const { value: e, app: t } = n, { sliderValue: a, sliderValueEditable: s } = n.params, { hsb: r } = e; n.brightnessRangeSlider.value = r[2], n.brightnessRangeSlider.layout(); const i = Qe(r[0], r[1], r[2]), o = Qe(r[0], r[1], 0), l = Qe(r[0], r[1], 1); n.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${i[0]}, ${i[1] * 100}%, ${i[2] * 100}%)`), n.brightnessRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${t.rtl ? "to left" : "to right"}, hsl(${o[0]}, ${o[1] * 100}%, ${o[2] * 100}%), hsl(${l[0]}, ${l[1] * 100}%, ${l[2] * 100}%))`), a && s ? n.$el.find("input.color-picker-value-brightness").val(`${r[2] * 1e3 / 10}`) : a && n.$el.find("span.color-picker-value-brightness").text(`${r[2] * 1e3 / 10}`) }, destroy(n) { n.brightnessRangeSlider && n.brightnessRangeSlider.destroy && n.brightnessRangeSlider.destroy(), delete n.brightnessRangeSlider } }, Mu = {
  render(n) {
    return x("div", { class: "color-picker-module color-picker-module-palette" }, x("div", { class: "color-picker-palette" }, n.params.palette.map(e => {
      if (Array.isArray(e)) {
        let t = '<div class="color-picker-palette-row">'; return t += e.map(a => `
                <div class="color-picker-palette-value" data-palette-color="${a}" style="background-color: ${a}"></div>
              `).join(""), t += "</div>", t
      } return x("div", { class: "color-picker-palette-value", "data-palette-color": e, style: `background-color: ${e}` })
    })))
  }, init(n) { function e(t) { const a = y(t.target).attr("data-palette-color"); n.setValue({ hex: a }) } n.$el.on("click", ".color-picker-module-palette .color-picker-palette-value", e), n.destroyPaletteEvents = function () { n.$el.off("click", ".color-picker-module-hex input", e) } }, destroy(n) { n.destroyPaletteEvents && n.destroyPaletteEvents(), delete n.destroyPaletteEvents }
}, Pu = { render() { return x("div", { class: "color-picker-module color-picker-module-initial-current-colors" }, x("div", { class: "color-picker-initial-current-colors" }, x("div", { class: "color-picker-initial-color" }), x("div", { class: "color-picker-current-color" }))) }, init(n) { function e() { if (n.initialValue) { const { hex: t, alpha: a } = n.initialValue; n.setValue({ hex: t, alpha: a }) } } n.$el.on("click", ".color-picker-initial-color", e), n.destroyInitialCurrentEvents = function () { n.$el.off("click", ".color-picker-initial-color", e) } }, update(n) { n.$el.find(".color-picker-module-initial-current-colors .color-picker-initial-color").css("background-color", n.initialValue.hex), n.$el.find(".color-picker-module-initial-current-colors .color-picker-current-color").css("background-color", n.value.hex) }, destroy(n) { n.destroyInitialCurrentEvents && n.destroyInitialCurrentEvents(), delete n.destroyInitialCurrentEvents } }, Au = { render(n) { const { barLabel: e, barValue: t, barValueEditable: a, redLabelText: s, greenLabelText: r, blueLabelText: i } = n.params; return x("div", { class: "color-picker-module color-picker-module-rgb-bars" }, x("div", { class: "color-picker-bar-wrap" }, e && x("div", { class: "color-picker-bar-label" }, s), x("div", { class: "range-slider color-picker-bar color-picker-bar-red" }), t && x("div", { class: "color-picker-bar-value" }, a ? x("input", { type: "number", step: "1", min: "0", max: "255", class: "color-picker-value-bar-red", "data-color-index": "0" }) : x("span", { class: "color-picker-value-bar-red" }))), x("div", { class: "color-picker-bar-wrap" }, e && x("div", { class: "color-picker-bar-label" }, r), x("div", { class: "range-slider color-picker-bar color-picker-bar-green" }), t && x("div", { class: "color-picker-bar-value" }, a ? x("input", { type: "number", step: "1", min: "0", max: "255", class: "color-picker-value-bar-green", "data-color-index": "1" }) : x("span", { class: "color-picker-value-bar-green" }))), x("div", { class: "color-picker-bar-wrap" }, e && x("div", { class: "color-picker-bar-label" }, i), x("div", { class: "range-slider color-picker-bar color-picker-bar-blue" }), t && x("div", { class: "color-picker-bar-value" }, a ? x("input", { type: "number", step: "1", min: "0", max: "255", class: "color-picker-value-bar-blue", "data-color-index": "2" }) : x("span", { class: "color-picker-value-bar-blue" })))) }, init(n) { n.redBar = n.app.range.create({ el: n.$el.find(".color-picker-bar-red"), min: 0, max: 255, step: 1, value: 0, vertical: !0, on: { change(t, a) { n.setValue({ rgb: [a, n.value.rgb[1], n.value.rgb[2]] }) } } }), n.greenBar = n.app.range.create({ el: n.$el.find(".color-picker-bar-green"), min: 0, max: 255, step: 1, value: 0, vertical: !0, on: { change(t, a) { n.setValue({ rgb: [n.value.rgb[0], a, n.value.rgb[2]] }) } } }), n.blueBar = n.app.range.create({ el: n.$el.find(".color-picker-bar-blue"), min: 0, max: 255, step: 1, value: 0, vertical: !0, on: { change(t, a) { n.setValue({ rgb: [n.value.rgb[0], n.value.rgb[1], a] }) } } }); function e(t) { const a = [...n.value.rgb], s = parseInt(y(t.target).attr("data-color-index"), 10); let r = parseInt(t.target.value, 10); if (Number.isNaN(r)) { t.target.value = a[s]; return } r = Math.max(0, Math.min(255, r)), a[s] = r, n.setValue({ rgb: a }) } n.$el.on("change", ".color-picker-module-rgb-bars input", e), n.destroyRgbBarsEvents = function () { n.$el.off("change", ".color-picker-module-rgb-bars input", e) } }, update(n) { const { value: e, redBar: t, greenBar: a, blueBar: s } = n, { barValue: r, barValueEditable: i } = n.params, { rgb: o } = e; t.value = o[0], a.value = o[1], s.value = o[2], t.layout(), a.layout(), s.layout(), t.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(0, ${o[1]}, ${o[2]}), rgb(255, ${o[1]}, ${o[2]}))`), a.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${o[0]}, 0, ${o[2]}), rgb(${o[0]}, 255, ${o[2]}))`), s.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${o[0]}, ${o[1]}, 0), rgb(${o[0]}, ${o[1]}, 255))`), r && i ? (n.$el.find("input.color-picker-value-bar-red").val(o[0]), n.$el.find("input.color-picker-value-bar-green").val(o[1]), n.$el.find("input.color-picker-value-bar-blue").val(o[2])) : r && (n.$el.find("span.color-picker-value-bar-red").text(o[0]), n.$el.find("span.color-picker-value-bar-green").text(o[1]), n.$el.find("span.color-picker-value-bar-blue").text(o[2])) }, destroy(n) { n.redBar && n.redBar.destroy && n.redBar.destroy(), n.greenBar && n.greenBar.destroy && n.greenBar.destroy(), n.blueBar && n.blueBar.destroy && n.blueBar.destroy(), delete n.redBar, delete n.greenBar, delete n.blueBar, n.destroyRgbBarsEvents && n.destroyRgbBarsEvents(), delete n.destroyRgbBarsEvents } }, Iu = { render(n) { const { sliderLabel: e, sliderValue: t, sliderValueEditable: a, redLabelText: s, greenLabelText: r, blueLabelText: i } = n.params; return x("div", { class: "color-picker-module color-picker-module-rgb-sliders" }, x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, s), x("div", { class: "range-slider color-picker-slider color-picker-slider-red" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "1", min: "0", max: "255", class: "color-picker-value-red", "data-color-index": "0" }) : x("span", { class: "color-picker-value-red" }))), x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, r), x("div", { class: "range-slider color-picker-slider color-picker-slider-green" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "1", min: "0", max: "255", class: "color-picker-value-green", "data-color-index": "1" }) : x("span", { class: "color-picker-value-green" }))), x("div", { class: "color-picker-slider-wrap" }, e && x("div", { class: "color-picker-slider-label" }, i), x("div", { class: "range-slider color-picker-slider color-picker-slider-blue" }), t && x("div", { class: "color-picker-slider-value" }, a ? x("input", { type: "number", step: "1", min: "0", max: "255", class: "color-picker-value-blue", "data-color-index": "2" }) : x("span", { class: "color-picker-value-blue" })))) }, init(n) { n.redRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-red"), min: 0, max: 255, step: 1, value: 0, on: { change(t, a) { n.setValue({ rgb: [a, n.value.rgb[1], n.value.rgb[2]] }) } } }), n.greenRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-green"), min: 0, max: 255, step: 1, value: 0, on: { change(t, a) { n.setValue({ rgb: [n.value.rgb[0], a, n.value.rgb[2]] }) } } }), n.blueRangeSlider = n.app.range.create({ el: n.$el.find(".color-picker-slider-blue"), min: 0, max: 255, step: 1, value: 0, on: { change(t, a) { n.setValue({ rgb: [n.value.rgb[0], n.value.rgb[1], a] }) } } }); function e(t) { const a = [...n.value.rgb], s = parseInt(y(t.target).attr("data-color-index"), 10); let r = parseInt(t.target.value, 10); if (Number.isNaN(r)) { t.target.value = a[s]; return } r = Math.max(0, Math.min(255, r)), a[s] = r, n.setValue({ rgb: a }) } n.$el.on("change", ".color-picker-module-rgb-sliders input", e), n.destroyRgbSlidersEvents = function () { n.$el.off("change", ".color-picker-module-rgb-sliders input", e) } }, update(n) { const { app: e, value: t, redRangeSlider: a, greenRangeSlider: s, blueRangeSlider: r } = n, { sliderValue: i, sliderValueEditable: o } = n.params, { rgb: l } = t; a.value = l[0], s.value = l[1], r.value = l[2], a.layout(), s.layout(), r.layout(), a.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${l[0]}, ${l[1]}, ${l[2]})`), s.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${l[0]}, ${l[1]}, ${l[2]})`), r.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${l[0]}, ${l[1]}, ${l[2]})`); const c = e.rtl ? "to left" : "to right"; a.$el.find(".range-bar").css("background-image", `linear-gradient(${c}, rgb(0, ${l[1]}, ${l[2]}), rgb(255, ${l[1]}, ${l[2]}))`), s.$el.find(".range-bar").css("background-image", `linear-gradient(${c}, rgb(${l[0]}, 0, ${l[2]}), rgb(${l[0]}, 255, ${l[2]}))`), r.$el.find(".range-bar").css("background-image", `linear-gradient(${c}, rgb(${l[0]}, ${l[1]}, 0), rgb(${l[0]}, ${l[1]}, 255))`), i && o ? (n.$el.find("input.color-picker-value-red").val(l[0]), n.$el.find("input.color-picker-value-green").val(l[1]), n.$el.find("input.color-picker-value-blue").val(l[2])) : i && (n.$el.find("span.color-picker-value-red").text(l[0]), n.$el.find("span.color-picker-value-green").text(l[1]), n.$el.find("span.color-picker-value-blue").text(l[2])) }, destroy(n) { n.redRangeSlider && n.redRangeSlider.destroy && n.redRangeSlider.destroy(), n.greenRangeSlider && n.greenRangeSlider.destroy && n.greenRangeSlider.destroy(), n.blueRangeSlider && n.blueRangeSlider.destroy && n.blueRangeSlider.destroy(), delete n.redRangeSlider, delete n.greenRangeSlider, delete n.blueRangeSlider, n.destroyRgbSlidersEvents && n.destroyRgbSlidersEvents(), delete n.destroyRgbSlidersEvents } }, Ou = { render() { return x("div", { class: "color-picker-module color-picker-module-sb-spectrum" }, x("div", { class: "color-picker-sb-spectrum", style: "background-color: hsl(0, 100%, 50%)" }, x("div", { class: "color-picker-sb-spectrum-handle" }))) }, init(n) { const { app: e } = n; let t, a, s, r, i, o, l, c, d; const { $el: u } = n; function p(v, E) { let $ = (v - l.left) / l.width, w = (E - l.top) / l.height; $ = Math.max(0, Math.min(1, $)), w = 1 - Math.max(0, Math.min(1, w)), n.setValue({ hsb: [n.value.hue, $, w] }) } function m(v) { if (a || t) return; s = v.type === "touchstart" ? v.targetTouches[0].pageX : v.pageX, i = s, r = v.type === "touchstart" ? v.targetTouches[0].pageY : v.pageY, o = r; const E = y(v.target); d = E.closest(".color-picker-sb-spectrum-handle").length > 0, d || (c = E.closest(".color-picker-sb-spectrum").length > 0), c && (l = u.find(".color-picker-sb-spectrum")[0].getBoundingClientRect(), p(s, r)), (d || c) && u.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed") } function f(v) { (c || d) && (i = v.type === "touchmove" ? v.targetTouches[0].pageX : v.pageX, o = v.type === "touchmove" ? v.targetTouches[0].pageY : v.pageY, v.preventDefault(), a || (a = !0, d && (l = u.find(".color-picker-sb-spectrum")[0].getBoundingClientRect())), (c || d) && p(i, o)) } function h() { a = !1, (c || d) && u.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed"), c = !1, d = !1 } function b() { n.modules["sb-spectrum"].update(n) } const g = e.touchEvents.start === "touchstart" && Ee().passiveListener ? { passive: !0, capture: !1 } : !1; n.$el.on(e.touchEvents.start, m, g), e.on("touchmove:active", f), e.on("touchend:passive", h), e.on("resize", b), n.destroySpectrumEvents = function () { n.$el.off(e.touchEvents.start, m, g), e.off("touchmove:active", f), e.off("touchend:passive", h), e.off("resize", b) } }, update(n) { const { value: e } = n, { hsl: t, hsb: a } = e, s = n.$el.find(".color-picker-sb-spectrum")[0].offsetWidth, r = n.$el.find(".color-picker-sb-spectrum")[0].offsetHeight; n.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${t[0]}, 100%, 50%)`), n.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${t[0]}, ${t[1] * 100}%, ${t[2] * 100}%)`).transform(`translate(${s * a[1]}px, ${r * (1 - a[2])}px)`) }, destroy(n) { n.destroySpectrumEvents && n.destroySpectrumEvents(), delete n.destroySpectrumEvents } }, Bu = { render() { return x("div", { class: "color-picker-module color-picker-module-hs-spectrum" }, x("div", { class: "color-picker-hs-spectrum" }, x("div", { class: "color-picker-hs-spectrum-handle" }))) }, init(n) { const { app: e } = n; let t, a, s, r, i, o, l, c, d; const { $el: u } = n; function p(v, E) { let $ = (v - l.left) / l.width * 360, w = (E - l.top) / l.height; $ = Math.max(0, Math.min(360, $)), w = 1 - Math.max(0, Math.min(1, w)), n.setValue({ hsb: [$, w, n.value.hsb[2]] }) } function m(v) { if (a || t) return; s = v.type === "touchstart" ? v.targetTouches[0].pageX : v.pageX, i = s, r = v.type === "touchstart" ? v.targetTouches[0].pageY : v.pageY, o = r; const E = y(v.target); d = E.closest(".color-picker-hs-spectrum-handle").length > 0, d || (c = E.closest(".color-picker-hs-spectrum").length > 0), c && (l = u.find(".color-picker-hs-spectrum")[0].getBoundingClientRect(), p(s, r)), (d || c) && u.find(".color-picker-hs-spectrum-handle").addClass("color-picker-hs-spectrum-handle-pressed") } function f(v) { (c || d) && (i = v.type === "touchmove" ? v.targetTouches[0].pageX : v.pageX, o = v.type === "touchmove" ? v.targetTouches[0].pageY : v.pageY, v.preventDefault(), a || (a = !0, d && (l = u.find(".color-picker-hs-spectrum")[0].getBoundingClientRect())), (c || d) && p(i, o)) } function h() { a = !1, (c || d) && u.find(".color-picker-hs-spectrum-handle").removeClass("color-picker-hs-spectrum-handle-pressed"), c = !1, d = !1 } function b() { n.modules["hs-spectrum"].update(n) } const g = e.touchEvents.start === "touchstart" && Ee().passiveListener ? { passive: !0, capture: !1 } : !1; n.$el.on(e.touchEvents.start, m, g), e.on("touchmove:active", f), e.on("touchend:passive", h), e.on("resize", b), n.destroySpectrumEvents = function () { n.$el.off(e.touchEvents.start, m, g), e.off("touchmove:active", f), e.off("touchend:passive", h), e.off("resize", b) } }, update(n) { const { value: e } = n, { hsb: t } = e, a = n.$el.find(".color-picker-hs-spectrum")[0].offsetWidth, s = n.$el.find(".color-picker-hs-spectrum")[0].offsetHeight, r = Qe(t[0], t[1], 1); n.$el.find(".color-picker-hs-spectrum-handle").css("background-color", `hsl(${r[0]}, ${r[1] * 100}%, ${r[2] * 100}%)`).transform(`translate(${a * (t[0] / 360)}px, ${s * (1 - t[1])}px)`) }, destroy(n) { n.destroySpectrumEvents && n.destroySpectrumEvents(), delete n.destroySpectrumEvents } }; function Du() { let e = ""; for (let t = 256; t > 0; t -= 1) { const a = t * Math.PI / 128, s = 360 / 256 * t; e += `<circle cx="${150 - Math.sin(a) * 125}" cy="${150 - Math.cos(a) * 125}" r="25" fill="hsl(${s}, 100%, 50%)"></circle>` } return e } const Lu = { render() { return x("div", { class: "color-picker-module color-picker-module-wheel" }, x("div", { class: "color-picker-wheel" }, x("svg", { viewBox: "0 0 300 300", width: "300", height: "300" }, Du()), x("div", { class: "color-picker-wheel-handle" }), x("div", { class: "color-picker-sb-spectrum", style: "background-color: hsl(0, 100%, 50%)" }, x("div", { class: "color-picker-sb-spectrum-handle" })))) }, init(n) { const { app: e } = n; let t, a, s, r, i, o, l, c, d, u, p, m; const { $el: f } = n; function h(C, k) { const M = l.left + l.width / 2, A = l.top + l.height / 2; let S = Math.atan2(k - A, C - M) * 180 / Math.PI + 90; S < 0 && (S += 360), S = 360 - S, n.setValue({ hue: S }) } function b(C, k) { let M = (C - u.left) / u.width, A = (k - u.top) / u.height; M = Math.max(0, Math.min(1, M)), A = 1 - Math.max(0, Math.min(1, A)), n.setValue({ hsb: [n.value.hue, M, A] }) } function g(C) { if (a || t) return; s = C.type === "touchstart" ? C.targetTouches[0].pageX : C.pageX, i = s, r = C.type === "touchstart" ? C.targetTouches[0].pageY : C.pageY, o = r; const k = y(C.target); d = k.closest(".color-picker-wheel-handle").length > 0, c = k.closest("circle").length > 0, m = k.closest(".color-picker-sb-spectrum-handle").length > 0, m || (p = k.closest(".color-picker-sb-spectrum").length > 0), c && (l = f.find(".color-picker-wheel")[0].getBoundingClientRect(), h(s, r)), p && (u = f.find(".color-picker-sb-spectrum")[0].getBoundingClientRect(), b(s, r)), (m || p) && f.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed") } function v(C) { !(c || d) && !(p || m) || (i = C.type === "touchmove" ? C.targetTouches[0].pageX : C.pageX, o = C.type === "touchmove" ? C.targetTouches[0].pageY : C.pageY, C.preventDefault(), a || (a = !0, d && (l = f.find(".color-picker-wheel")[0].getBoundingClientRect()), m && (u = f.find(".color-picker-sb-spectrum")[0].getBoundingClientRect())), (c || d) && h(i, o), (p || m) && b(i, o)) } function E() { a = !1, (p || m) && f.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed"), c = !1, d = !1, p = !1, m = !1 } function $() { n.modules.wheel.update(n) } const w = e.touchEvents.start === "touchstart" && Ee().passiveListener ? { passive: !0, capture: !1 } : !1; n.$el.on(e.touchEvents.start, g, w), e.on("touchmove:active", v), e.on("touchend:passive", E), e.on("resize", $), n.destroyWheelEvents = function () { n.$el.off(e.touchEvents.start, g, w), e.off("touchmove:active", v), e.off("touchend:passive", E), e.off("resize", $) } }, update(n) { const { value: e } = n, { hsl: t, hsb: a } = e, s = n.$el.find(".color-picker-sb-spectrum")[0].offsetWidth, r = n.$el.find(".color-picker-sb-spectrum")[0].offsetHeight, i = n.$el.find(".color-picker-wheel")[0].offsetWidth, o = i / 2, l = e.hue * Math.PI / 180, d = i / 6 / 2, u = o - Math.sin(l) * (o - d) - d, p = o - Math.cos(l) * (o - d) - d; n.$el.find(".color-picker-wheel-handle").css("background-color", `hsl(${t[0]}, 100%, 50%)`).transform(`translate(${u}px, ${p}px)`), n.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${t[0]}, 100%, 50%)`), n.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${t[0]}, ${t[1] * 100}%, ${t[2] * 100}%)`).transform(`translate(${s * a[1]}px, ${r * (1 - a[2])}px)`) }, destroy(n) { n.destroyWheelEvents && n.destroyWheelEvents(), delete n.destroyWheelEvents } }; let Zn = class extends me { constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this; a.params = R({}, e.params.colorPicker, t); let s; if (a.params.containerEl && (s = y(a.params.containerEl), s.length === 0)) return a; let r; a.params.inputEl && (r = y(a.params.inputEl)); let i; a.params.targetEl && (i = y(a.params.targetEl)), R(a, { app: e, $containerEl: s, containerEl: s && s[0], inline: s && s.length > 0, $inputEl: r, inputEl: r && r[0], $targetEl: i, targetEl: i && i[0], initialized: !1, opened: !1, url: a.params.url, modules: { "alpha-slider": Cu, "current-color": $u, hex: xu, "hsb-sliders": ku, "hue-slider": Tu, "brightness-slider": Su, palette: Mu, "initial-current-colors": Pu, "rgb-bars": Au, "rgb-sliders": Iu, "sb-spectrum": Ou, "hs-spectrum": Bu, wheel: Lu } }); function o() { a.open() } function l(u) { u.preventDefault() } function c() { a.open() } function d(u) { if (a.destroyed || !a.params || a.params.openIn === "page") return; const p = y(u.target); !a.opened || a.closing || p.closest('[class*="backdrop"]').length || p.closest(".color-picker-popup, .color-picker-popover").length || (r && r.length > 0 ? p[0] !== r[0] && p.closest(".sheet-modal").length === 0 && a.close() : y(u.target).closest(".sheet-modal").length === 0 && a.close()) } return R(a, { attachInputEvents() { a.$inputEl.on("click", o), a.params.inputReadOnly && (a.$inputEl.on("focus mousedown", l), a.$inputEl[0] && (a.$inputEl[0].f7ValidateReadonly = !0)) }, detachInputEvents() { a.$inputEl.off("click", o), a.params.inputReadOnly && (a.$inputEl.off("focus mousedown", l), a.$inputEl[0] && delete a.$inputEl[0].f7ValidateReadonly) }, attachTargetEvents() { a.$targetEl.on("click", c) }, detachTargetEvents() { a.$targetEl.off("click", c) }, attachHtmlEvents() { e.on("click", d) }, detachHtmlEvents() { e.off("click", d) } }), a.init(), a } get view() { const { $inputEl: e, $targetEl: t, app: a, params: s } = this; let r; return s.view ? r = s.view : (e && (r = e.parents(".view").length && e.parents(".view")[0].f7View), !r && t && (r = t.parents(".view").length && t.parents(".view")[0].f7View)), r || (r = a.views.main), r } attachEvents() { const e = this; e.centerModules = e.centerModules.bind(e), e.params.centerModules && e.app.on("resize", e.centerModules) } detachEvents() { const e = this; e.params.centerModules && e.app.off("resize", e.centerModules) } centerModules() { const e = this; if (!e.opened || !e.$el || e.inline) return; const t = e.$el.find(".page-content"); if (!t.length) return; const { scrollHeight: a, offsetHeight: s } = t[0]; a <= s ? t.addClass("justify-content-center") : t.removeClass("justify-content-center") } initInput() { const e = this; e.$inputEl && e.params.inputReadOnly && e.$inputEl.prop("readOnly", !0) } getModalType() { const e = this, { app: t, modal: a, params: s } = e, { openIn: r, openInPhone: i } = s, o = ue(); return a && a.type ? a.type : r !== "auto" ? r : e.inline ? null : o.ios ? o.ipad ? "popover" : i : t.width >= 768 ? "popover" : i } formatValue() { const e = this, { value: t } = e; return e.params.formatValue ? e.params.formatValue.call(e, t) : t.hex } normalizeHsValues(e) { return [Math.floor(e[0] * 10) / 10, Math.floor(e[1] * 1e3) / 1e3, Math.floor(e[2] * 1e3) / 1e3] } setValue(e, t) { e === void 0 && (e = {}), t === void 0 && (t = !0); const a = this; if (typeof e > "u") return; let { hex: s, rgb: r, hsl: i, hsb: o, alpha: l = 1, hue: c, rgba: d, hsla: u } = a.value || {}; const p = a.value || !a.value && !a.params.value; let m; if (Object.keys(e).forEach(f => { if (!a.value || typeof a.value[f] > "u") { m = !0; return } const h = e[f]; Array.isArray(h) ? h.forEach((b, g) => { b !== a.value[f][g] && (m = !0) }) : h !== a.value[f] && (m = !0) }), !!m) { if (e.rgb || e.rgba) { const [f, h, b, g = l] = e.rgb || e.rgba; r = [f, h, b], s = _e(...r), i = Kt(...r), o = Mt(...i), i = a.normalizeHsValues(i), o = a.normalizeHsValues(o), c = o[0], l = g, d = [r[0], r[1], r[2], g], u = [i[0], i[1], i[2], g] } if (e.hsl || e.hsla) { const [f, h, b, g = l] = e.hsl || e.hsla; i = [f, h, b], r = bt(...i), s = _e(...r), o = Mt(...i), i = a.normalizeHsValues(i), o = a.normalizeHsValues(o), c = o[0], l = g, d = [r[0], r[1], r[2], g], u = [i[0], i[1], i[2], g] } if (e.hsb) { const [f, h, b, g = l] = e.hsb; o = [f, h, b], i = Qe(...o), r = bt(...i), s = _e(...r), i = a.normalizeHsValues(i), o = a.normalizeHsValues(o), c = o[0], l = g, d = [r[0], r[1], r[2], g], u = [i[0], i[1], i[2], g] } if (e.hex && (r = Ge(e.hex), s = _e(...r), i = Kt(...r), o = Mt(...i), i = a.normalizeHsValues(i), o = a.normalizeHsValues(o), c = o[0], d = [r[0], r[1], r[2], l], u = [i[0], i[1], i[2], l]), typeof e.alpha < "u" && (l = e.alpha, typeof r < "u" && (d = [r[0], r[1], r[2], l]), typeof i < "u" && (u = [i[0], i[1], i[2], l])), typeof e.hue < "u") { const [f, h, b] = i; i = [e.hue, h, b], o = Mt(...i), r = bt(...i), s = _e(...r), i = a.normalizeHsValues(i), o = a.normalizeHsValues(o), c = o[0], d = [r[0], r[1], r[2], l], u = [i[0], i[1], i[2], l] } a.value = { hex: s, alpha: l, hue: c, rgb: r, hsl: i, hsb: o, rgba: d, hsla: u }, a.initialValue || (a.initialValue = R({}, a.value)), a.updateValue(p), a.opened && t && a.updateModules() } } getValue() { return this.value } updateValue(e) { e === void 0 && (e = !0); const t = this, { $inputEl: a, value: s, $targetEl: r } = t; if (r && t.params.targetElSetBackgroundColor) { const { rgba: i } = s; r.css("background-color", `rgba(${i.join(", ")})`) } if (e && t.emit("local::change colorPickerChange", t, s), a && a.length) { const i = t.formatValue(s); a && a.length && (a.val(i), e && a.trigger("change")) } } updateModules() { const e = this, { modules: t } = e; e.params.modules.forEach(a => { typeof a == "string" && t[a] && t[a].update ? t[a].update(e) : a && a.update && a.update(e) }) } update() { this.updateModules() } renderPicker() { const e = this, { params: t, modules: a } = e; let s = ""; return t.modules.forEach(r => { typeof r == "string" && a[r] && a[r].render ? s += a[r].render(e) : r && r.render && (s += r.render(e)) }), s } renderNavbar() { const e = this; if (e.params.renderNavbar) return e.params.renderNavbar.call(e, e); const { openIn: t, navbarTitleText: a, navbarBackLinkText: s, navbarCloseText: r } = e.params; return x("div", { class: "navbar" }, x("div", { class: "navbar-bg" }), x("div", { class: "navbar-inner sliding" }, t === "page" && x("div", { class: "left" }, x("a", { class: "link back" }, x("i", { class: "icon icon-back" }), x("span", { class: "if-not-md" }, s))), x("div", { class: "title" }, a), t !== "page" && x("div", { class: "right" }, x("a", { class: "link popup-close", "data-popup": ".color-picker-popup" }, r)))) } renderToolbar() { const e = this; return e.params.renderToolbar ? e.params.renderToolbar.call(e, e) : x("div", { class: "toolbar toolbar-top" }, x("div", { class: "toolbar-inner" }, x("div", { class: "left" }), x("div", { class: "right" }, x("a", { class: "link sheet-close popover-close", "data-sheet": ".color-picker-sheet-modal", "data-popover": ".color-picker-popover" }, e.params.toolbarCloseText)))) } renderInline() { const e = this, { cssClass: t, groupedModules: a } = e.params; return x("div", { class: `color-picker color-picker-inline ${a ? "color-picker-grouped-modules" : ""} ${t || ""}` }, e.renderPicker()) } renderSheet() { const e = this, { cssClass: t, toolbarSheet: a, groupedModules: s } = e.params; return x("div", { class: `sheet-modal color-picker color-picker-sheet-modal ${s ? "color-picker-grouped-modules" : ""} ${t || ""}` }, a && e.renderToolbar(), x("div", { class: "sheet-modal-inner" }, x("div", { class: "page-content" }, e.renderPicker()))) } renderPopover() { const e = this, { cssClass: t, toolbarPopover: a, groupedModules: s } = e.params; return x("div", { class: `popover color-picker-popover ${t || ""}` }, x("div", { class: "popover-inner" }, x("div", { class: `color-picker ${s ? "color-picker-grouped-modules" : ""}` }, a && e.renderToolbar(), x("div", { class: "page-content" }, e.renderPicker())))) } renderPopup() { const e = this, { cssClass: t, navbarPopup: a, groupedModules: s } = e.params; return x("div", { class: `popup color-picker-popup ${t || ""}` }, x("div", { class: "page" }, a && e.renderNavbar(), x("div", { class: `color-picker ${s ? "color-picker-grouped-modules" : ""}` }, x("div", { class: "page-content" }, e.renderPicker())))) } renderPage() { const e = this, { cssClass: t, groupedModules: a } = e.params; return x("div", { class: `page color-picker-page ${t || ""}`, "data-name": "color-picker-page" }, e.renderNavbar(), x("div", { class: `color-picker ${a ? "color-picker-grouped-modules" : ""}` }, x("div", { class: "page-content" }, e.renderPicker()))) } render() { const e = this, { params: t } = e; if (t.render) return t.render.call(e); if (e.inline) return e.renderInline(); if (t.openIn === "page") return e.renderPage(); const a = e.getModalType(); if (a === "popover") return e.renderPopover(); if (a === "sheet") return e.renderSheet(); if (a === "popup") return e.renderPopup() } onOpen() { const e = this, { initialized: t, $el: a, app: s, $inputEl: r, inline: i, value: o, params: l, modules: c } = e; e.closing = !1, e.opened = !0, e.opening = !0, e.attachEvents(), l.modules.forEach(u => { typeof u == "string" && c[u] && c[u].init ? c[u].init(e) : u && u.init && u.init(e) }); const d = !o && l.value; t ? o && (e.initialValue = R({}, o), e.setValue(o, !1)) : o ? e.setValue(o) : l.value ? e.setValue(l.value, !1) : l.value || e.setValue({ hex: "#ff0000" }, !1), d && e.updateValue(), e.updateModules(), l.centerModules && e.centerModules(), !i && r && r.length && s.theme === "md" && r.trigger("focus"), e.initialized = !0, a && a.trigger("colorpicker:open"), r && r.trigger("colorpicker:open"), e.emit("local::open colorPickerOpen", e) } onOpened() { const e = this; e.opening = !1, e.$el && e.$el.trigger("colorpicker:opened"), e.$inputEl && e.$inputEl.trigger("colorpicker:opened"), e.emit("local::opened colorPickerOpened", e) } onClose() { const e = this, { app: t, params: a, modules: s } = e; if (e.opening = !1, e.closing = !0, e.detachEvents(), e.$inputEl) if (t.theme === "md") e.$inputEl.trigger("blur"); else { const r = e.$inputEl.attr("validate"), i = e.$inputEl.attr("required"); r && i && t.input.validate(e.$inputEl) } a.modules.forEach(r => { typeof r == "string" && s[r] && s[r].destroy ? s[r].destroy(e) : r && r.destroy && r.destroy(e) }), e.$el && e.$el.trigger("colorpicker:close"), e.$inputEl && e.$inputEl.trigger("colorpicker:close"), e.emit("local::close colorPickerClose", e) } onClosed() { const e = this; e.opened = !1, e.closing = !1, e.inline || $e(() => { e.modal && e.modal.el && e.modal.destroy && (e.params.routableModals || e.modal.destroy()), delete e.modal }), e.$el && e.$el.trigger("colorpicker:closed"), e.$inputEl && e.$inputEl.trigger("colorpicker:closed"), e.emit("local::closed colorPickerClosed", e) } open() { const e = this, { app: t, opened: a, inline: s, $inputEl: r, $targetEl: i, params: o } = e; if (a) return; if (s) { e.$el = y(e.render()), e.$el[0].f7ColorPicker = e, e.$containerEl.append(e.$el), e.onOpen(), e.onOpened(); return } const l = e.render(); if (o.openIn === "page") e.view.router.navigate({ url: e.url, route: { content: l, path: e.url, on: { pageBeforeIn(c, d) { e.$el = d.$el.find(".color-picker"), e.$el[0].f7ColorPicker = e, e.onOpen() }, pageAfterIn() { e.onOpened() }, pageBeforeOut() { e.onClose() }, pageAfterOut() { e.onClosed(), e.$el && e.$el[0] && (e.$el[0].f7ColorPicker = null, delete e.$el[0].f7ColorPicker) } } } }); else { const c = e.getModalType(); let d = o.backdrop; (d === null || typeof d > "u") && (c === "popover" && t.params.popover.backdrop !== !1 && (d = !0), c === "popup" && (d = !0)); const u = { targetEl: i || r, scrollToEl: o.scrollToInput ? i || r : void 0, content: l, backdrop: d, closeByBackdropClick: o.closeByBackdropClick, on: { open() { const p = this; e.modal = p, e.$el = c === "popover" || c === "popup" ? p.$el.find(".color-picker") : p.$el, e.$el[0].f7ColorPicker = e, e.onOpen() }, opened() { e.onOpened() }, close() { e.onClose() }, closed() { e.onClosed(), e.$el && e.$el[0] && (e.$el[0].f7ColorPicker = null, delete e.$el[0].f7ColorPicker) } } }; c === "popup" && (u.push = o.popupPush, u.swipeToClose = o.popupSwipeToClose), c === "sheet" && (u.push = o.sheetPush, u.swipeToClose = o.sheetSwipeToClose), o.routableModals && e.view ? e.view.router.navigate({ url: e.url, route: { path: e.url, [c]: u } }) : (e.modal = t[c].create(u), e.modal.open()) } } close() { const e = this, { opened: t, inline: a } = e; if (t) { if (a) { e.onClose(), e.onClosed(); return } e.params.routableModals && e.view || e.params.openIn === "page" ? e.view.router.back() : e.modal.close() } } init() { const e = this; if (e.initInput(), e.inline) { e.open(), e.emit("local::init colorPickerInit", e); return } !e.initialized && e.params.value && e.setValue(e.params.value), e.$inputEl && e.attachInputEvents(), e.$targetEl && e.attachTargetEvents(), e.params.closeByOutsideClick && e.attachHtmlEvents(), e.emit("local::init colorPickerInit", e) } destroy() { const e = this; if (e.destroyed) return; const { $el: t } = e; e.emit("local::beforeDestroy colorPickerBeforeDestroy", e), t && t.trigger("colorpicker:beforedestroy"), e.close(), e.detachEvents(), e.$inputEl && e.detachInputEvents(), e.$targetEl && e.detachTargetEvents(), e.params.closeByOutsideClick && e.detachHtmlEvents(), t && t.length && delete e.$el[0].f7ColorPicker, ve(e), e.destroyed = !0 } }; const Ru = { name: "colorPicker", static: { ColorPicker: Zn }, create() { const n = this; n.colorPicker = we({ defaultSelector: ".color-picker", constructor: Zn, app: n, domProp: "f7ColorPicker" }), n.colorPicker.close = function (t) { t === void 0 && (t = ".color-picker"); const a = y(t); if (a.length === 0) return; const s = a[0].f7ColorPicker; !s || s && !s.opened || s.close() } }, params: { colorPicker: { value: null, modules: ["wheel"], palette: [["#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373", "#EF5350", "#F44336", "#E53935", "#D32F2F", "#C62828", "#B71C1C"], ["#F3E5F5", "#E1BEE7", "#CE93D8", "#BA68C8", "#AB47BC", "#9C27B0", "#8E24AA", "#7B1FA2", "#6A1B9A", "#4A148C"], ["#E8EAF6", "#C5CAE9", "#9FA8DA", "#7986CB", "#5C6BC0", "#3F51B5", "#3949AB", "#303F9F", "#283593", "#1A237E"], ["#E1F5FE", "#B3E5FC", "#81D4FA", "#4FC3F7", "#29B6F6", "#03A9F4", "#039BE5", "#0288D1", "#0277BD", "#01579B"], ["#E0F2F1", "#B2DFDB", "#80CBC4", "#4DB6AC", "#26A69A", "#009688", "#00897B", "#00796B", "#00695C", "#004D40"], ["#F1F8E9", "#DCEDC8", "#C5E1A5", "#AED581", "#9CCC65", "#8BC34A", "#7CB342", "#689F38", "#558B2F", "#33691E"], ["#FFFDE7", "#FFF9C4", "#FFF59D", "#FFF176", "#FFEE58", "#FFEB3B", "#FDD835", "#FBC02D", "#F9A825", "#F57F17"], ["#FFF3E0", "#FFE0B2", "#FFCC80", "#FFB74D", "#FFA726", "#FF9800", "#FB8C00", "#F57C00", "#EF6C00", "#E65100"]], groupedModules: !1, centerModules: !0, sliderLabel: !1, sliderValue: !1, sliderValueEdiable: !1, barLabel: !1, barValue: !1, barValueEdiable: !1, hexLabel: !1, hexValueEditable: !1, redLabelText: "R", greenLabelText: "G", blueLabelText: "B", hueLabelText: "H", saturationLabelText: "S", brightnessLabelText: "B", hexLabelText: "HEX", alphaLabelText: "A", containerEl: null, openIn: "popover", openInPhone: "popup", popupPush: !1, popupSwipeToClose: void 0, sheetPush: !1, sheetSwipeToClose: void 0, formatValue: null, targetEl: null, targetElSetBackgroundColor: !1, inputEl: null, inputReadOnly: !0, closeByOutsideClick: !0, scrollToInput: !0, toolbarSheet: !0, toolbarPopover: !1, toolbarCloseText: "Done", navbarPopup: !0, navbarCloseText: "Done", navbarTitleText: "Color", navbarBackLinkText: "Back", cssClass: null, routableModals: !1, view: null, url: "color/", backdrop: null, closeByBackdropClick: !0, renderToolbar: null, renderNavbar: null, renderInline: null, renderPopover: null, renderSheet: null, renderPopup: null, render: null } } }, Hu = { open(n) { const e = this, t = y(n).eq(0); if (!t.length) return; t.addClass("treeview-item-opened"), t.trigger("treeview:open"), e.emit("treeviewOpen", t[0]); function a(s) { s ? (t.removeClass("treeview-item-opened"), t.trigger("treeview:close"), e.emit("treeviewClose", t[0])) : t[0].f7TreeviewChildrenLoaded = !0, t.find(".treeview-toggle").removeClass("treeview-toggle-hidden"), t.find(".treeview-preloader").remove() } if (t.hasClass("treeview-load-children") && !t[0].f7TreeviewChildrenLoaded) { const s = { iosPreloaderContent: ct, mdPreloaderContent: lt }; t.trigger("treeview:loadchildren", a), e.emit("treeviewLoadChildren", t[0], a), t.find(".treeview-toggle").addClass("treeview-toggle-hidden"), t.find(".treeview-item-root").prepend(`<div class="preloader treeview-preloader">${s[`${e.theme}PreloaderContent`]}</div>`) } }, close(n) { const e = this, t = y(n).eq(0); t.length && (t.removeClass("treeview-item-opened"), t.trigger("treeview:close"), e.emit("treeviewClose", t[0])) }, toggle(n) { const e = this, t = y(n).eq(0); if (!t.length) return; const a = t.hasClass("treeview-item-opened"); e.treeview[a ? "close" : "open"](t) } }, zu = { name: "treeview", create() { Se(this, { treeview: Hu }) }, clicks: { ".treeview-toggle": function (e, t, a) { const s = this; if (e.parents(".treeview-item-toggle").length) return; const r = e.parents(".treeview-item").eq(0); r.length && (a.preventF7Router = !0, s.treeview.toggle(r[0])) }, ".treeview-item-toggle": function (e, t, a) { const s = this, r = e.closest(".treeview-item").eq(0); r.length && (a.preventF7Router = !0, s.treeview.toggle(r[0])) } } }, Nt = { bold: ["bold", "format_bold", "bold"], italic: ["italic", "format_italic", "italic"], underline: ["underline", "format_underlined", "underline"], strikeThrough: ["strikethrough", "strikethrough_s", "strikeThrough"], orderedList: ["list_number", "format_list_numbered", "insertOrderedList"], unorderedList: ["list_bullet", "format_list_bulleted", "insertUnorderedList"], link: ["link", "link", "createLink"], image: ["photo", "image", "insertImage"], paragraph: ["paragraph", '<i class="icon">¶</i>', "formatBlock.P"], h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', "formatBlock.H1"], h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', "formatBlock.H2"], h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', "formatBlock.H3"], alignLeft: ["text_alignleft", "format_align_left", "justifyLeft"], alignCenter: ["text_aligncenter", "format_align_center", "justifyCenter"], alignRight: ["text_alignright", "format_align_right", "justifyRight"], alignJustify: ["text_justify", "format_align_justify", "justifyFull"], subscript: ["textformat_subscript", '<i class="icon">A<sub>1</sub></i>', "subscript"], superscript: ["textformat_superscript", '<i class="icon">A<sup>1</sup></i>', "superscript"], indent: ["increase_indent", "format_indent_increase", "indent"], outdent: ["decrease_indent", "format_indent_decrease", "outdent"] }; let Jn = class extends me {
  constructor(e, t) { super(t, [e]); const a = this, s = ee(), r = ue(), i = R({}, e.params.textEditor); a.useModulesParams(i), a.params = R(i, t); const o = a.params.el; if (!o) return a; const l = y(o); if (l.length === 0) return a; if (l[0].f7TextEditor) return l[0].f7TextEditor; let c = l.children(".text-editor-content"); if (c.length || (l.append('<div class="text-editor-content" contenteditable></div>'), c = l.children(".text-editor-content")), R(a, { app: e, $el: l, el: l[0], $contentEl: c, contentEl: c[0] }), "value" in t && (a.value = a.params.value), a.params.mode === "keyboard-toolbar" && !(r.cordova || r.capacitor) && !r.android && (a.params.mode = "popover"), typeof a.params.buttons == "string") try { a.params.buttons = JSON.parse(a.params.buttons) } catch { throw new Error('Framework7: TextEditor: wrong "buttons" parameter format') } return l[0].f7TextEditor = a, a.onButtonClick = a.onButtonClick.bind(a), a.onFocus = a.onFocus.bind(a), a.onBlur = a.onBlur.bind(a), a.onInput = a.onInput.bind(a), a.onPaste = a.onPaste.bind(a), a.onSelectionChange = a.onSelectionChange.bind(a), a.closeKeyboardToolbar = a.closeKeyboardToolbar.bind(a), a.attachEvents = function () { a.params.mode === "toolbar" && a.$el.find(".text-editor-toolbar").on("click", "button", a.onButtonClick), a.params.mode === "keyboard-toolbar" && (a.$keyboardToolbarEl.on("click", "button", a.onButtonClick), a.$el.parents(".page").on("page:beforeout", a.closeKeyboardToolbar)), a.params.mode === "popover" && a.popover && a.popover.$el.on("click", "button", a.onButtonClick), a.$contentEl.on("paste", a.onPaste), a.$contentEl.on("focus", a.onFocus), a.$contentEl.on("blur", a.onBlur), a.$contentEl.on("input", a.onInput, !0), y(s).on("selectionchange", a.onSelectionChange) }, a.detachEvents = function () { a.params.mode === "toolbar" && a.$el.find(".text-editor-toolbar").off("click", "button", a.onButtonClick), a.params.mode === "keyboard-toolbar" && (a.$keyboardToolbarEl.off("click", "button", a.onButtonClick), a.$el.parents(".page").off("page:beforeout", a.closeKeyboardToolbar)), a.params.mode === "popover" && a.popover && a.popover.$el.off("click", "button", a.onButtonClick), a.$contentEl.off("paste", a.onPaste), a.$contentEl.off("focus", a.onFocus), a.$contentEl.off("blur", a.onBlur), a.$contentEl.off("input", a.onInput, !0), y(s).off("selectionchange", a.onSelectionChange) }, a.useModules(), a.init(), a } setValue(e) { const t = this; return t.value === e || (t.value = e, t.$contentEl.html(e), t.$el.trigger("texteditor:change", t.value), t.emit("local::change textEditorChange", t, t.value)), t } getValue() { return this.value } clearValue() { const e = this; return e.setValue(""), e.params.placeholder && !e.$contentEl.html() && e.insertPlaceholder(), e } createLink() { const e = this, t = U(), a = ee(), s = t.getSelection(), r = []; let i; if (s && s.anchorNode && y(s.anchorNode).parents(e.$el).length) { let c = s.anchorNode; for (; c;)r.push(c), (!c.nextSibling || c === s.focusNode) && (c = null), c && (c = c.nextSibling); const d = [], u = y(r); for (let p = 0; p < u.length; p += 1) { const m = u[p].children; if (m) for (let f = 0; f < m.length; f += 1)y(m[f]).is("a") && d.push(m[f]) } i = u.closest("a").add(y(d)) } if (i && i.length) return i.each(c => { const d = t.getSelection(), u = a.createRange(); u.selectNodeContents(c), d.removeAllRanges(), d.addRange(u), a.execCommand("unlink", !1), d.removeAllRanges() }), e; const o = e.getSelectionRange(); return o && e.app.dialog.prompt("", e.params.linkUrlText, c => { c && c.trim().length && (e.setSelectionRange(o), a.execCommand("createLink", !1, c.trim()), e.$el.trigger("texteditor:insertlink", { url: c.trim() }), e.emit("local:insertLink textEditorInsertLink", e, c.trim())) }).$el.find("input").focus(), e } insertImage() { const e = this, t = ee(), a = e.getSelectionRange(); return a && e.app.dialog.prompt("", e.params.imageUrlText, r => { r && r.trim().length && (e.setSelectionRange(a), t.execCommand("insertImage", !1, r.trim()), e.$el.trigger("texteditor:insertimage", { url: r.trim() }), e.emit("local:insertImage textEditorInsertImage", e, r.trim())) }).$el.find("input").focus(), e } removePlaceholder() { this.$contentEl.find(".text-editor-placeholder").remove() } insertPlaceholder() { const e = this; e.$contentEl.append(`<div class="text-editor-placeholder">${e.params.placeholder}</div>`) } onSelectionChange() { const e = this, t = U(), a = ee(); if (e.params.mode === "toolbar") return; const s = t.getSelection(), r = y(s.anchorNode).parents(e.contentEl).length || s.anchorNode === e.contentEl; if (e.params.mode === "keyboard-toolbar") { r ? e.openKeyboardToolbar() : e.closeKeyboardToolbar(); return } if (e.params.mode === "popover") { const i = y(s.anchorNode).parents(e.popover.el).length || s.anchorNode === e.popover.el; if (!r && !i) { e.closePopover(); return } if (!s.isCollapsed && s.rangeCount) { const l = s.getRangeAt(0).getBoundingClientRect(), c = e.app.$el[0] || a.body; e.openPopover(l.x + (t.scrollX || 0) - c.offsetLeft, l.y + (t.scrollY || 0) - c.offsetTop, l.width, l.height) } else s.isCollapsed && e.closePopover() } } onPaste(e) { const t = this, a = ee(); if (t.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) { const s = e.clipboardData.getData("text/plain"); e.preventDefault(), a.execCommand("insertText", !1, s) } } onInput() { const e = this, t = e.$contentEl.html(); e.value = t, e.$el.trigger("texteditor:input"), e.emit("local:input textEditorInput", e, e.value), e.$el.trigger("texteditor:change", e.value), e.emit("local::change textEditorChange", e, e.value) } onFocus() { const e = this; e.removePlaceholder(), e.$contentEl.focus(), e.$el.trigger("texteditor:focus"), e.emit("local::focus textEditorFocus", e) } onBlur() { const e = this, t = U(), a = ee(); if (e.params.placeholder && e.$contentEl.html() === "" && e.insertPlaceholder(), e.params.mode === "popover") { const s = t.getSelection(), r = y(s.anchorNode).parents(e.contentEl).length || s.anchorNode === e.contentEl; !(a.activeElement && e.popover && y(a.activeElement).closest(e.popover.$el).length) && !r && e.closePopover() } if (e.params.mode === "keyboard-toolbar") { const s = t.getSelection(); y(s.anchorNode).parents(e.contentEl).length || s.anchorNode === e.contentEl || e.closeKeyboardToolbar() } e.$el.trigger("texteditor:blur"), e.emit("local::blur textEditorBlur", e) } onButtonClick(e) { const t = this, a = U(), s = ee(), r = a.getSelection(); if (!(y(r.anchorNode).parents(t.contentEl).length || r.anchorNode === t.contentEl)) return; const o = y(e.target).closest("button"); o.parents("form").length && e.preventDefault(); const l = o.attr("data-button"), c = t.params.customButtons && t.params.customButtons[l]; if (!l || !(Nt[l] || c)) return; if (o.trigger("texteditor:buttonclick", l), t.emit("local::buttonClick textEditorButtonClick", t, l), c) { c.onClick && c.onClick(t, o[0]); return } const d = Nt[l][2]; if (d === "createLink") { t.createLink(); return } if (d === "insertImage") { t.insertImage(); return } if (d.indexOf("formatBlock") === 0) { const u = d.split(".")[1], p = y(r.anchorNode); p.parents(u.toLowerCase()).length || p.is(u) ? s.execCommand("formatBlock", !1, "div") : s.execCommand("formatBlock", !1, u); return } s.execCommand(d, !1) } getSelectionRange() { const e = U(), t = ee(); if (e.getSelection) { const a = e.getSelection(); if (a.getRangeAt && a.rangeCount) return a.getRangeAt(0) } else if (t.selection && t.selection.createRange) return t.selection.createRange(); return null } setSelectionRange(e) { const t = U(), a = ee(); if (e) if (t.getSelection) { const s = t.getSelection(); s.removeAllRanges(), s.addRange(e) } else a.selection && e.select && e.select() } renderButtons() { const e = this; let t = ""; function a(s) { const r = e.app.theme === "md" ? "material-icons" : "f7-icons"; if (e.params.customButtons && e.params.customButtons[s]) { const o = e.params.customButtons[s]; return `<button type="button" class="text-editor-button" data-button="${s}">${o.content || ""}</button>` } if (!Nt[s]) return ""; const i = Nt[s][e.app.theme === "md" ? 1 : 0]; return `<button type="button" class="text-editor-button" data-button="${s}">${i.indexOf("<") >= 0 ? i : `<i class="${r}">${i}</i>`}</button>`.trim() } return e.params.buttons.forEach((s, r) => { Array.isArray(s) ? (s.forEach(i => { t += a(i) }), r < e.params.buttons.length - 1 && e.params.dividers && (t += '<div class="text-editor-button-divider"></div>')) : t += a(s) }), t } createToolbar() { const e = this; e.$el.prepend(`<div class="text-editor-toolbar">${e.renderButtons()}</div>`) } createKeyboardToolbar() { const e = this; e.$keyboardToolbarEl = y(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar"><div class="toolbar-inner">${e.renderButtons()}</div></div>`) } createPopover() {
    const e = this; e.popover = e.app.popover.create({
      content: `
        <div class="popover dark text-editor-popover">
          <div class="popover-inner">${e.renderButtons()}</div>
        </div>
      `, closeByOutsideClick: !1, backdrop: !1
    })
  } openKeyboardToolbar() { const e = this; e.$keyboardToolbarEl.parent(e.app.$el).length || (e.$el.trigger("texteditor:keyboardopen"), e.emit("local::keyboardOpen textEditorKeyboardOpen", e), e.app.$el.append(e.$keyboardToolbarEl)) } closeKeyboardToolbar() { const e = this; e.$keyboardToolbarEl.remove(), e.$el.trigger("texteditor:keyboardclose"), e.emit("local::keyboardClose textEditorKeyboardClose", e) } openPopover(e, t, a, s) { const r = this; r.popover && (Object.assign(r.popover.params, { targetX: e, targetY: t, targetWidth: a, targetHeight: s }), clearTimeout(r.popoverTimeout), r.popoverTimeout = setTimeout(() => { r.popover && (r.popover.opened ? r.popover.resize() : (r.$el.trigger("texteditor:popoveropen"), r.emit("local::popoverOpen textEditorPopoverOpen", r), r.popover.open())) }, 400)) } closePopover() { const e = this; clearTimeout(e.popoverTimeout), !(!e.popover || !e.popover.opened) && (e.popoverTimeout = setTimeout(() => { e.popover && (e.$el.trigger("texteditor:popoverclose"), e.emit("local::popoverClose textEditorPopoverClose", e), e.popover.close()) }, 400)) } init() { const e = this; return e.value ? e.$contentEl.html(e.value) : e.value = e.$contentEl.html(), e.params.placeholder && e.value === "" && e.insertPlaceholder(), e.params.mode === "toolbar" ? e.createToolbar() : e.params.mode === "popover" ? e.createPopover() : e.params.mode === "keyboard-toolbar" && e.createKeyboardToolbar(), e.attachEvents(), e.$el.trigger("texteditor:init"), e.emit("local::init textEditorInit", e), e } destroy() { let e = this; e.$el.trigger("texteditor:beforedestroy"), e.emit("local::beforeDestroy textEditorBeforeDestroy", e), e.detachEvents(), e.params.mode === "keyboard-toolbar" && e.$keyboardToolbarEl && e.$keyboardToolbarEl.remove(), e.popover && (e.popover.close(!1), e.popover.destroy()), delete e.$el[0].f7TextEditor, ve(e), e = null }
}; const Fu = { name: "textEditor", params: { textEditor: { el: null, mode: "toolbar", value: void 0, customButtons: null, buttons: [["bold", "italic", "underline", "strikeThrough"], ["orderedList", "unorderedList"], ["link", "image"], ["paragraph", "h1", "h2", "h3"], ["alignLeft", "alignCenter", "alignRight", "alignJustify"], ["subscript", "superscript"], ["indent", "outdent"]], dividers: !0, imageUrlText: "Insert image URL", linkUrlText: "Insert link URL", placeholder: null, clearFormattingOnPaste: !0 } }, create() { const n = this; n.textEditor = R(we({ defaultSelector: ".text-editor", constructor: Jn, app: n, domProp: "f7TextEditor" })) }, static: { TextEditor: Jn }, on: { tabMounted(n) { const e = this; y(n).find(".text-editor-init").each(t => { const a = y(t).dataset(); e.textEditor.create(R({ el: t }, a || {})) }) }, tabBeforeRemove(n) { y(n).find(".text-editor-init").each(e => { e.f7TextEditor && e.f7TextEditor.destroy() }) }, pageInit(n) { const e = this; n.$el.find(".text-editor-init").each(t => { const a = y(t).dataset(); e.textEditor.create(R({ el: t }, a || {})) }) }, pageBeforeRemove(n) { n.$el.find(".text-editor-init").each(e => { e.f7TextEditor && e.f7TextEditor.destroy() }) } }, vnode: { "text-editor-init": { insert(n) { const e = this, t = n.elm, a = y(t).dataset(); e.textEditor.create(R({ el: t }, a || {})) }, destroy(n) { const e = n.elm; e.f7TextEditor && e.f7TextEditor.destroy() } } } }; let Vu = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = R({}, e.params.pieChart); a.useModulesParams(s), a.params = R(s, t); const { el: r } = a.params; if (!r) return a; const i = y(r); return i.length === 0 ? a : i[0].f7PieChart ? i[0].f7PieChart : (R(a, { app: e, $el: i, el: i && i[0], currentIndex: null, f7Tooltip: null }), i[0].f7PieChart = a, a.useModules(), a.showTooltip = a.showTooltip.bind(this), a.hideTooltip = a.hideTooltip.bind(this), a.init(), a) } getSummValue() { const { datasets: e } = this.params; let t = 0; return e.map(a => a.value || 0).forEach(a => { t += a }), t } getPaths() { const { datasets: e, size: t } = this.params, a = []; let s = 0; function r(i) { const o = Math.cos(2 * Math.PI * i) * (t / 3), l = Math.sin(2 * Math.PI * i) * (t / 3); return [o, l] } return e.forEach(i => { let { value: o, label: l, color: c } = i; const d = o / this.getSummValue(), [u, p] = r(s); s += d; const [m, f] = r(s), h = d > .5 ? 1 : 0, b = [`M ${u} ${p}`, `A ${t / 3} ${t / 3} 0 ${h} 1 ${m} ${f}`, "L 0 0"].join(" "); a.push({ points: b, label: l, color: c }) }), a } formatTooltipText() {
    const { datasets: e } = this.params, { currentIndex: t } = this; if (t === null) return ""; const { value: a, label: s, color: r } = e[t], i = a / this.getSummValue() * 100, o = c => parseInt(c, 10) === c ? c : Math.round(c * 100) / 100; if (this.params.formatTooltip) return this.params.formatTooltip.call(this, { index: t, value: a, label: s, color: r, percentage: i }); const l = `${s ? `${s}: ` : ""}${o(a)} (${o(i)}%)`; return `
      <div class="pie-chart-tooltip-label">
        <span class="pie-chart-tooltip-color" style="background-color: ${r};"></span> ${l}
      </div>
    `} setTooltip() { const e = this, { currentIndex: t, el: a, app: s, params: r } = e, { tooltip: i } = r; if (!(t === null && !e.f7Tooltip) && !(!i || !a)) { if (t !== null && !e.f7Tooltip) { e.f7Tooltip = s.tooltip.create({ trigger: "manual", containerEl: a, targetEl: a.querySelector(`path[data-index="${t}"]`), text: e.formatTooltipText(), cssClass: "pie-chart-tooltip" }), e.f7Tooltip.show(); return } e.f7Tooltip && (t !== null ? (e.f7Tooltip.setText(e.formatTooltipText()), e.f7Tooltip.setTargetEl(a.querySelector(`path[data-index="${t}"]`)), e.f7Tooltip.show()) : e.f7Tooltip.hide()) } } render() { const e = this, t = e.params.size, a = e.getPaths(); return x("svg", { xmlns: "http://www.w3.org/2000/svg", width: t, viewBox: `-${t / 3} -${t / 3} ${t * 2 / 3} ${t * 2 / 3}`, style: "transform: rotate(-90deg)" }, a.map((s, r) => x("path", { d: s.points, fill: s.color, "data-index": r }))) } update(e) { e === void 0 && (e = {}); const t = this, { params: a } = t; if (Object.keys(e).forEach(r => { typeof e[r] < "u" && (a[r] = e[r]) }), t.$svgEl.length === 0) return t; t.$svgEl.remove(), delete t.$svgEl.f7PieChart; const s = y(t.render()).eq(0); return s.f7PieChart = t, R(t, { $svgEl: s, svgEl: s && s[0] }), t.$el.append(s), t } setCurrentIndex(e) { const t = this; if (e === t.currentIndex) return; const { datasets: a } = t.params; t.currentIndex = e, t.$el.trigger("piechart:select", { index: e, dataset: a[e] }), t.emit("local::select pieChartSelect", t, e, a[e]) } showTooltip(e) { const t = parseInt(e.target.getAttribute("data-index"), 10); this.setCurrentIndex(t), this.$svgEl.find("path").removeClass("pie-chart-hidden").forEach((a, s) => { s !== this.currentIndex && y(a).addClass("pie-chart-hidden") }), this.setTooltip() } hideTooltip() { this.setCurrentIndex(null), this.$svgEl.find("path").removeClass("pie-chart-hidden"), this.setTooltip() } init() { const e = this, t = y(e.render()).eq(0); return t.f7PieChart = e, R(e, { $svgEl: t, svgEl: t && t[0] }), e.$el.append(t), e.$el.on("click mouseenter", "path", e.showTooltip, !0), e.$el.on("mouseleave", "path", e.hideTooltip, !0), e } destroy() { const e = this; !e.$el || e.destroyed || (e.$el.trigger("piechart:beforedestroy"), e.emit("local::beforeDestroy pieChartBeforeDestroy", e), e.$el.off("click mouseenter", "path", e.showTooltip, !0), e.$el.off("mouseleave", "path", e.hideTooltip, !0), e.$svgEl.remove(), e.f7Tooltip && e.f7Tooltip.destroy && e.f7Tooltip.destroy(), delete e.$el[0].f7PieChart, ve(e), e.destroyed = !0) }
}; const Nu = { name: "pieChart", params: { pieChart: { el: null, datasets: [], size: 320, tooltip: !1, formatTooltip: null } }, create() { const n = this; n.pieChart = we({ defaultSelector: ".pie-chart", constructor: Vu, app: n, domProp: "f7PieChart" }), n.pieChart.update = function (t, a) { if (y(t).length === 0) return; const r = n.pieChart.get(t); if (r) return r.update(a), r } } }; let Yu = class extends me {
  constructor(e, t) { t === void 0 && (t = {}), super(t, [e]); const a = this, s = R({}, e.params.areaChart); a.useModulesParams(s), a.params = R(s, t); const { el: r } = a.params; if (!r) return a; const i = y(r); return i.length === 0 ? a : i[0].f7AreaChart ? i[0].f7AreaChart : (R(a, { app: e, $el: i, el: i && i[0], currentIndex: null, hiddenDatasets: [], f7Tooltip: null, linesOffsets: null }), i[0].f7AreaChart = a, a.useModules(), a.onMouseEnter = a.onMouseEnter.bind(a), a.onMouseMove = a.onMouseMove.bind(a), a.onMouseLeave = a.onMouseLeave.bind(a), a.onLegendClick = a.onLegendClick.bind(a), a.init(), a) } getVisibleLabels() { const { maxAxisLabels: e, axisLabels: t } = this.params; if (!e || t.length <= e) return t; const a = Math.ceil(t.length / e); return t.filter((r, i) => i % a === 0) } getSummValues() { const { datasets: e } = this.params, { hiddenDatasets: t } = this, a = []; return e.filter((s, r) => !t.includes(r)).forEach(s => { let { values: r } = s; r.forEach((i, o) => { a[o] || (a[o] = 0), a[o] += i }) }), a } getChartData() { const { datasets: e, lineChart: t, width: a, height: s } = this.params, { hiddenDatasets: r } = this, i = []; if (!e.length) return i; const o = e[0].values.map(() => 0); let l = 0; return t ? e.filter((c, d) => !r.includes(d)).forEach(c => { let { values: d } = c; const u = Math.max(...d); u > l && (l = u) }) : l = Math.max(...this.getSummValues()), e.filter((c, d) => !r.includes(d)).forEach(c => { let { label: d, values: u, color: p } = c; const m = u.map((f, h) => { o[h] += f; const b = t ? f : o[h], g = h / (u.length - 1) * a, v = s - b / l * s; return t ? `${h === 0 ? "M" : "L"}${g},${v}` : `${g} ${v}` }); t || m.push(`${a} ${s} 0 ${s}`), i.push({ label: d, points: m.join(" "), color: p }) }), i.reverse() } getVerticalLines() { const { datasets: e, width: t } = this.params, a = []; if (!e.length) return a; const s = e[0].values; return s.forEach((r, i) => { const o = i / (s.length - 1) * t; a.push(o) }), a } toggleDataset(e) { const { hiddenDatasets: t, params: { toggleDatasets: a } } = this; a && (t.includes(e) ? t.splice(t.indexOf(e), 1) : t.push(e), this.$legendEl && (this.$legendEl.find(".area-chart-legend-item").removeClass("area-chart-legend-item-hidden"), t.forEach(s => { this.$legendEl.find(`.area-chart-legend-item[data-index="${s}"]`).addClass("area-chart-legend-item-hidden") })), this.update({}, !0)) } formatAxisLabel(e) { const { formatAxisLabel: t } = this.params; return t ? t.call(this, e) : e } formatLegendLabel(e) { const { formatLegendLabel: t } = this.params; return t ? t.call(this, e) : e } calcLinesOffsets() { const e = this.svgEl.querySelectorAll("line"); this.linesOffsets = []; for (let t = 0; t < e.length; t += 1)this.linesOffsets.push(e[t].getBoundingClientRect().left) } formatTooltip() {
    const e = this, { currentIndex: t, hiddenDatasets: a, params: { datasets: s, axisLabels: r, formatTooltip: i, formatTooltipTotal: o, formatTooltipAxisLabel: l, formatTooltipDataset: c } } = e; if (t === null) return ""; let d = 0; const u = s.filter((h, b) => !a.includes(b)).map(h => ({ color: h.color, label: h.label, value: h.values[t] })); if (u.forEach(h => { d += h.value }), i) return i({ index: t, total: d, datasets: u }); let p = l ? l.call(e, r[t]) : this.formatAxisLabel(r[t]); p || (p = ""); const m = o ? o.call(e, d) : d, f = u.length > 0 ? `
      <ul class="area-chart-tooltip-list">
        ${u.map(h => {
      let { label: b, color: g, value: v } = h; const E = c ? c.call(e, b, v, g) : `${b ? `${b}: ` : ""}${v}`; return `
              <li><span style="background-color: ${g};"></span>${E}</li>
            `}).join("")}
      </ul>`: ""; return `
      <div class="area-chart-tooltip-label">${p}</div>
      <div class="area-chart-tooltip-total">${m}</div>
      ${f}
    `} setTooltip() { const e = this, { app: t, el: a, svgEl: s, hiddenDatasets: r, currentIndex: i, params: { tooltip: o, datasets: l } } = e; if (!o) return; if (!(l.filter((d, u) => !r.includes(u)).length > 0)) { e.f7Tooltip && e.f7Tooltip.hide && e.f7Tooltip.hide(); return } if (i !== null && !e.f7Tooltip) { e.f7Tooltip = t.tooltip.create({ trigger: "manual", containerEl: a, targetEl: s.querySelector(`line[data-index="${i}"]`), text: e.formatTooltip(), cssClass: "area-chart-tooltip" }), e.f7Tooltip && e.f7Tooltip.show && e.f7Tooltip.show(); return } !e.f7Tooltip || !e.f7Tooltip.hide || !e.f7Tooltip.show || (i !== null ? (e.f7Tooltip.setText(e.formatTooltip()), e.f7Tooltip.setTargetEl(s.querySelector(`line[data-index="${i}"]`)), e.f7Tooltip.show()) : e.f7Tooltip.hide()) } setCurrentIndex(e) { e !== this.currentIndex && (this.currentIndex = e, this.$el.trigger("areachart:select", { index: e }), this.emit("local::select areaChartSelect", this, e), this.$svgEl.find("line").removeClass("area-chart-current-line"), this.$svgEl.find(`line[data-index="${e}"]`).addClass("area-chart-current-line"), this.setTooltip()) } onLegendClick(e) { const t = parseInt(y(e.target).closest(".area-chart-legend-item").attr("data-index"), 10); this.toggleDataset(t) } onMouseEnter() { this.calcLinesOffsets() } onMouseMove(e) { const t = this; t.linesOffsets || t.calcLinesOffsets(); let a = e.pageX; typeof a > "u" && (a = 0); const s = t.linesOffsets.map(o => Math.abs(a - o)), r = Math.min(...s), i = s.indexOf(r); t.setCurrentIndex(i) } onMouseLeave() { this.setCurrentIndex(null) } attachEvents() { const { svgEl: e, $el: t } = this; e && (e.addEventListener("mouseenter", this.onMouseEnter), e.addEventListener("mousemove", this.onMouseMove), e.addEventListener("mouseleave", this.onMouseLeave), t.on("click", ".area-chart-legend-item", this.onLegendClick)) } detachEvents() { const { svgEl: e, $el: t } = this; e && (e.removeEventListener("mouseenter", this.onMouseEnter), e.removeEventListener("mousemove", this.onMouseMove), e.removeEventListener("mouseleave", this.onMouseLeave), t.off("click", ".area-chart-legend-item", this.onLegendClick)) } render() { const e = this, { lineChart: t, toggleDatasets: a, width: s, height: r, axis: i, axisLabels: o, legend: l, datasets: c } = e.params, d = e.getChartData(), u = e.getVerticalLines(), p = e.getVisibleLabels(), m = a ? "button" : "span"; return x("div", null, x("svg", { xmlns: "http://www.w3.org/2000/svg", width: s, height: r, viewBox: `0 0 ${s} ${r}`, preserveAspectRatio: "none" }, d.map(f => t ? x("path", { stroke: f.color, "fill-rule": "evenodd", d: f.points }) : x("polygon", { fill: f.color, "fill-rule": "evenodd", points: f.points })), u.map((f, h) => x("line", { "data-index": h, fill: "#000", x1: f, y1: 0, x2: f, y2: r }))), i && x("div", { class: "area-chart-axis" }, o.map(f => x("span", null, p.includes(f) && x("span", null, e.formatAxisLabel(f))))), l && x("div", { class: "area-chart-legend" }, c.map((f, h) => x(m, { "data-index": h, class: `area-chart-legend-item ${a ? "area-chart-legend-button" : ""}`, _type: a ? "button" : void 0 }, x("span", { style: `background-color: ${f.color}` }), e.formatLegendLabel(f.label))))) } update(e, t) { e === void 0 && (e = {}), t === void 0 && (t = !1); const a = this, { params: s } = a; if (Object.keys(e).forEach(o => { typeof e[o] < "u" && (s[o] = e[o]) }), a.$svgEl.length === 0) return a; a.detachEvents(), a.$svgEl.remove(), t || (a.$axisEl.remove(), a.$legendEl.remove()); const r = y(a.render()), i = r.find("svg"); if (R(a, { svgEl: i && i[0], $svgEl: i }), !t) { const o = r.find(".area-chart-axis"), l = r.find(".area-chart-legend"); R(a, { $axisEl: o, $legendEl: l }), a.$el.append(o), a.$el.append(l) } return a.$el.prepend(i), a.attachEvents(), a } init() { const e = this, t = y(e.render()), a = t.find("svg"), s = t.find(".area-chart-axis"), r = t.find(".area-chart-legend"); return R(e, { svgEl: a && a[0], $svgEl: a, $axisEl: s, $legendEl: r }), e.$el.append(a), e.$el.append(s), e.$el.append(r), e.attachEvents(), e } destroy() { const e = this; !e.$el || e.destroyed || (e.$el.trigger("piechart:beforedestroy"), e.emit("local::beforeDestroy areaChartBeforeDestroy", e), e.detachEvents(), e.$svgEl.remove(), e.$axisEl.remove(), e.$legendEl.remove(), e.f7Tooltip && e.f7Tooltip.destroy && e.f7Tooltip.destroy(), delete e.$el[0].f7AreaChart, ve(e), e.destroyed = !0) }
}; const qu = { name: "areaChart", params: { areaChart: { el: null, lineChart: !1, datasets: [], axis: !1, axisLabels: [], tooltip: !1, legend: !1, toggleDatasets: !1, width: 640, height: 320, maxAxisLabels: 8, formatAxisLabel: null, formatLegendLabel: null, formatTooltip: null, formatTooltipAxisLabel: null, formatTooltipTotal: null, formatTooltipDataset: null } }, create() { const n = this; n.areaChart = we({ defaultSelector: ".area-chart", constructor: Yu, app: n, domProp: "f7AreaChart" }), n.areaChart.update = function (t, a) { if (y(t).length === 0) return; const r = n.areaChart.get(t); if (r) return r.update(a), r } } }, ju = {}, Wu = { name: "breadrumbs", create() { Se(this, { breadrumbs: ju }) } }, Xu = { name: "typography" }; Le.use([vs]); Pe.use([ls, cs, ds, us, ps, gs, Xa, xs, $s, ks, Ts, Ss, Ms, Ps, As, Is, Os, Bs, yl, El, wl, Cl, $l, xl, kl, Tl, Ml, Al, Il, Ol, Bl, Dl, Ll, Rl, zl, Nl, ql, jl, Ul, _l, Kl, Ql, Zl, Jl, ec, tc, ac, nc, rc, oc, lc, cc, uc, pc, fc, hc, mu, gu, vu, bu, yu, Eu, wu, Ru, zu, Fu, Nu, qu, Wu, Xu]); var Je = { f7: null, handleSplashscreen: function () { var n = Je.f7; window.navigator.splashscreen && setTimeout(() => { window.navigator.splashscreen.hide() }, 2e3) }, handleAndroidBackButton: function () { var n = Je.f7; const e = n.$; document.addEventListener("backbutton", function (t) { if (e(".actions-modal.modal-in").length) return n.actions.close(".actions-modal.modal-in"), t.preventDefault(), !1; if (e(".dialog.modal-in").length) return n.dialog.close(".dialog.modal-in"), t.preventDefault(), !1; if (e(".sheet-modal.modal-in").length) return n.sheet.close(".sheet-modal.modal-in"), t.preventDefault(), !1; if (e(".popover.modal-in").length) return n.popover.close(".popover.modal-in"), t.preventDefault(), !1; if (e(".popup.modal-in").length) { if (e(".popup.modal-in>.view").length) { const s = n.views.get(".popup.modal-in>.view"); if (s && s.router && s.router.history.length > 1) return s.router.back(), t.preventDefault(), !1 } return n.popup.close(".popup.modal-in"), t.preventDefault(), !1 } if (e(".login-screen.modal-in").length) return n.loginScreen.close(".login-screen.modal-in"), t.preventDefault(), !1; if (e(".page-current .searchbar-enabled").length) return n.searchbar.disable(".page-current .searchbar-enabled"), t.preventDefault(), !1; if (e(".page-current .card-expandable.card-opened").length) return n.card.close(".page-current .card-expandable.card-opened"), t.preventDefault(), !1; const a = n.views.current; if (a && a.router && a.router.history.length > 1) return a.router.back(), t.preventDefault(), !1; if (e(".panel.panel-in").length) return n.panel.close(".panel.panel-in"), t.preventDefault(), !1 }, !1) }, handleKeyboard: function () { var n = Je.f7; if (!(!window.Keyboard || !window.Keyboard.shrinkView)) { var e = n.$; window.Keyboard.shrinkView(!1), window.Keyboard.disableScrollingInShrinkView(!0), window.Keyboard.hideFormAccessoryBar(!0), window.addEventListener("keyboardWillShow", () => { n.input.scrollIntoView(document.activeElement, 0, !0, !0) }), window.addEventListener("keyboardDidShow", () => { n.input.scrollIntoView(document.activeElement, 0, !0, !0) }), window.addEventListener("keyboardDidHide", () => { document.activeElement && e(document.activeElement).parents(".messagebar").length || window.Keyboard.hideFormAccessoryBar(!1) }), window.addEventListener("keyboardHeightWillChange", t => { var a = t.keyboardHeight; a > 0 ? (document.body.style.height = `calc(100% - ${a}px)`, e("html").addClass("device-with-keyboard")) : (document.body.style.height = "", e("html").removeClass("device-with-keyboard")) }), e(document).on("touchstart", "input, textarea, select", function (t) { var a = t.target.nodeName.toLowerCase(), s = t.target.type, r = ["datetime-local", "time", "date", "datetime"]; a === "select" || r.indexOf(s) >= 0 ? window.Keyboard.hideFormAccessoryBar(!1) : window.Keyboard.hideFormAccessoryBar(!0) }, !0) } }, init: function (n) { Je.f7 = n, document.addEventListener("deviceready", () => { Je.handleAndroidBackButton(), Je.handleSplashscreen(), Je.handleKeyboard() }) } }; const { Client: Gu, Databases: Uu, ID: Hp } = Appwrite, Ns = new Gu; Ns.setEndpoint("https://appwrite.shuchir.dev/v1").setProject("wheresmyflight"); const _u = new Uu(Ns); function Ys() {
  return _u.listDocuments("data", "flights").then(function (e) {
    let t = e.documents, a = document.getElementById("flightslist"); for (let s = 0; s < t.length; s++)a.innerHTML += `
              <div class="card demo-card-header-pic">
                <a href="/flight/${t[s].flightId}">
                <div style="background-image:url(https://flightaware.com/images/airline_logos/90p/${t[s]["iata-code"]}.png)"
                  valign="bottom" class="card-header hasimage"></div>
                <div class="card-content card-content-padding">
                  <div class="card-header">${t[s].flightId}</div>
                  <div class="card-row">
                    <p>${t[s].location[0]}</p>
                    <p>${t[s].location[1]}</p>
                  </div>
                  <div class="card-row">
                    <div class="airportrow"><p class="big">${t[s].airport[0]}</p><p class="kindofbig">${new Date(Date.parse(t[s].time[0].replace("+00:00", "-04:00"))).toLocaleTimeString().replace(":00", "")}</p></div>
                    <div class="airportrow"><p class="kindofbig">${new Date(Date.parse(t[s].time[1].replace("+00:00", "-04:00"))).toLocaleTimeString().replace(":00", "")}</p><p class="big">${t[s].airport[1]}</p></div>
                  </div>
                  <div class="card-row">
                      <p class="mt-0 mb-0">Gate ${t[s].gate[0]}</p>
                      <p class="mt-0 mb-0">Gate ${t[s].gate[1]}</p>
                  </div>
                </div>
              </a>
              </div>`}, function (e) { console.log(e) }), function (e) {
      var t = e.$, a = e.$h, s = e.$root, r = e.$f7, i = e.$f7route, o = e.$f7router, l = e.$theme, c = e.$update, d = e.$store; return a`
  <div class="page" data-name="home">
    <!-- Top Navbar -->
    <div class="navbar navbar-large">
      <div class="navbar-bg"></div>
      <div class="navbar-inner">
        <div class="title sliding">WheresMyFlight</div>
        <div class="title-large">
          <div class="title-large-text">WheresMyFlight</div>
        </div>
      </div>
    </div>
    <!-- Scrollable page content-->
    <div class="page-content">
      <div class="block">
        <a href="/add-flight" class="button button-fill">Add Flight</a>
      </div>

      <div class="block-title">Flights</div>
        <div id="flightslist">
        </div>
        <br></br>
    </div>
  </div>
`}
} Ys.id = "9d5dd32156"; function qs() {
  return function (n) {
    var e = n.$, t = n.$h, a = n.$root, s = n.$f7, r = n.$f7route, i = n.$f7router, o = n.$theme, l = n.$update, c = n.$store; return t`
<div class="page">
  <div class="navbar">
    <div class="navbar-bg"></div>
    <div class="navbar-inner sliding">
      <div class="left">
        <a href="#" class="link back">
          <i class="icon icon-back"></i>
          <span class="if-not-md">Back</span>
        </a>
      </div>
      <div class="title">Not found</div>
    </div>
  </div>
  <div class="page-content">
    <div class="block block-strong inset">
      <p>Sorry</p>
      <p>Requested content not found.</p>
    </div>
  </div>
</div>
`}
} qs.id = "931f21159a"; const { Client: Ku, Databases: Qu, ID: Zu } = Appwrite, js = new Ku; js.setEndpoint("https://appwrite.shuchir.dev/v1").setProject("wheresmyflight"); const Ju = new Qu(js); function Ka(n, { $: e, $f7: t, $on: a, $onBeforeMount: s, $onMounted: r, $onBeforeUnmount: i, $onUnmounted: o }) {
  return a("pageInit", () => { e(".convert-form-to-data").on("click", function () { var l = t.form.convertToData("#form"); t.dialog.preloader("Getting flight data..."), axios({ method: "get", url: `https://api.allorigins.win/get?url=${encodeURIComponent("https://flightaware.com/live/flight/" + l.flightnum)}` }).then(function (c) { let u = c.data.contents.split("trackpollBootstrap = ")[1].split("<\/script>")[0].replace("}}};", "}}}"); u = JSON.parse(u), console.log(u); let p = Object.keys(u.flights)[0], m = u.flights[p], f = [m.origin.iata, m.destination.iata], h = [m.origin.friendlyLocation, m.destination.friendlyLocation], b = [new Date(+(String(m.gateDepartureTimes.estimated) + "000") - 144e5), new Date(+(String(m.gateArrivalTimes.estimated) + "000") - 144e5)], g = [new Date(+(String(m.gateDepartureTimes.scheduled) + "000") - 144e5), new Date(+(String(m.gateArrivalTimes.scheduled) + "000") - 144e5)], v = m.airline.icao, E = [m.origin.gate, m.destination.gate], $ = m.aircraft.friendlyType, w = m.airline.fullName, C = m.origin.TZ, k = m.origin.iata + " (" + m.origin.friendlyName + ")", M = m.origin.friendlyLocation, A = m.origin.gate, O = m.origin.terminal, S = m.destination.TZ, P = m.destination.iata + " (" + m.destination.friendlyName + ")", T = m.destination.friendlyLocation, I = m.destination.gate, H = m.destination.terminal, D = Math.round(m.distance.actual * 1.151) + "mi", z = Math.round(m.flightPlan.plannedDistance * 1.151) + "mi", B = Math.round(m.distance.elapsed * 1.151) + "mi", L = Math.round(m.flightPlan.speed * 1.151) + "mph", N = Math.round(m.flightPlan.altitude * 100) + "ft", F = Math.round(m.flightPlan.fuelBurn.gallons) + "gal", V = m.flightStatus, _ = new Date(+(String(m.gateDepartureTimes.scheduled) + "000") - 144e5), J = new Date(+(String(m.gateDepartureTimes.estimated) + "000") - 144e5), Q = new Date(+(String(m.gateDepartureTimes.actual) + "000") - 144e5), j = new Date(+(String(m.gateArrivalTimes.scheduled) + "000") - 144e5), Y = new Date(+(String(m.gateArrivalTimes.estimated) + "000") - 144e5), X = new Date(+(String(m.gateArrivalTimes.actual) + "000") - 144e5), K = []; if (m.track) for (let G = 0; G < m.track.length; G++) { let Z = m.track[G].coord; K.push(Z) } K = JSON.stringify(K), console.log(f, h, b, v, E), Ju.createDocument("data", "flights", Zu.unique(), { flightId: l.flightnum, airport: f, location: h, time: b, "iata-code": v, gate: E, scheduledTime: g, fullData: [$, w, C, k, M, A, O, S, P, T, I, H, D, z, B, L, N, F, V, _, J, Q, j, Y, X], coordinates: K }).then(function (G) { console.log(G), t.views.main.router.navigate("/flight/" + l.flightnum) }, function (G) { console.log(G) }) }) }) }), s(() => { console.log("onBeforeMount") }), r(() => { console.log("onMounted") }), i(() => { console.log("onBeforeUnmount") }), o(() => { console.log("onUnmounted") }), a("pageMounted", (l, c) => { console.log("pageMounted", c) }), a("pageInit", (l, c) => { console.log("pageInit", c) }), a("pageBeforeIn", (l, c) => { console.log("pageBeforeIn", c) }), a("pageAfterIn", (l, c) => { console.log("pageAfterIn", c) }), a("pageBeforeOut", (l, c) => { console.log("pageBeforeOut", c) }), a("pageAfterOut", (l, c) => { console.log("pageAfterOut", c) }), a("pageBeforeRemove", (l, c) => { console.log("pageBeforeRemove", c) }), function (l) {
    var c = l.$, d = l.$h, u = l.$root, p = l.$f7, m = l.$f7route, f = l.$f7router, h = l.$theme, b = l.$update, g = l.$store; return d`
  <div class="page">
    <div class="navbar">
      <div class="navbar-bg"></div>
      <div class="navbar-inner sliding">
        <div class="left">
          <a href="#" class="link back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">Back</span>
          </a>
        </div>
        <div class="title">Add Flight</div>
      </div>
    </div>
    <div class="page-content">
      <div class="block block-strong inset">
        <form id="form">
          <div class="list">
            <ul>
              <li class="item-content item-input item-input-outline">
                <div class="item-inner">
                  <div class="item-title item-floating-label">Flight Number</div>
                  <div class="item-input-wrap">
                    <input type="text" name="flightnum" />
                    <span class="input-clear-button"></span>
                  </div>
                </div>
              </li>
            </ul>
          </div>
        </form>
        <div class="block block-strong">
          <a class="button button-fill convert-form-to-data" href="#">Get Data</a>
        </div>
      </div>
    </div>
  </div>
`}
} Ka.id = "6bb65f74dd"; Ka.style = `
  p {
    margin: 10px 0;
  }
`; const { Client: ep, Databases: tp, ID: zp, Query: es } = Appwrite, Ws = new ep; Ws.setEndpoint("https://appwrite.shuchir.dev/v1").setProject("wheresmyflight"); const Sa = new tp(Ws); function Qa(n, { $: e, $f7: t, $f7route: a, $on: s, $onBeforeMount: r, $onMounted: i, $onBeforeUnmount: o, $onUnmounted: l }) {
  return s("pageInit", () => { t.dialog.preloader("Getting flight data..."); let c = a.path.replace("/flight/", ""); console.log(c), e(".delete-flight").on("click", function () { t.dialog.confirm("Are you sure you want to delete this flight?", function () { Sa.listDocuments("data", "flights", [es.equal("flightId", c)]).then(p => { Sa.deleteDocument("data", "flights", p.documents[0].$id).then(function (f) { t.dialog.alert("Flight deleted successfully!", function () { t.views.main.router.navigate("/") }) }, function (f) { console.log(f) }) }) }) }), Sa.listDocuments("data", "flights", [es.equal("flightId", c)]).then(function (u) { let p = u.documents[0].fullData; document.getElementById("aircraft").innerHTML = p[0], document.getElementById("airline").innerHTML = p[1], document.getElementById("origtz").innerHTML = p[2], document.getElementById("origairport").innerHTML = p[3], document.getElementById("origcity").innerHTML = p[4], document.getElementById("origgate").innerHTML = p[5], document.getElementById("origterm").innerHTML = p[6], document.getElementById("desttz").innerHTML = p[7], document.getElementById("destairport").innerHTML = p[8], document.getElementById("destcity").innerHTML = p[9], document.getElementById("destgate").innerHTML = p[10], document.getElementById("destterm").innerHTML = p[11], document.getElementById("actualdist").innerHTML = p[12], document.getElementById("plandist").innerHTML = p[13], document.getElementById("takendist").innerHTML = p[14], document.getElementById("speed").innerHTML = p[15], document.getElementById("altitude").innerHTML = p[16], document.getElementById("fuel").innerHTML = p[17], document.getElementById("status").innerHTML = p[18], document.getElementById("scheddeptime").innerHTML = new Date(Date.parse(p[19])).toString().split(":00 GMT")[0], document.getElementById("estdeptime").innerHTML = new Date(Date.parse(p[20])).toString().split(":00 GMT")[0], document.getElementById("actualdeptime").innerHTML = new Date(Date.parse(p[21])).toString().split(":00 GMT")[0], document.getElementById("schedarrtime").innerHTML = new Date(Date.parse(p[22])).toString().split(":00 GMT")[0], document.getElementById("estarrtime").innerHTML = new Date(Date.parse(p[23])).toString().split(":00 GMT")[0], document.getElementById("actualarrtime").innerHTML = new Date(Date.parse(p[24])).toString().split(":00 GMT")[0]; function m() { var f = new google.maps.Map(document.getElementById("map"), { zoom: 4, center: { lat: 41.871314, lng: -99.86958 }, mapTypeId: google.maps.MapTypeId.TERRAIN }), h = [], b = []; let g = JSON.parse(u.documents[0].coordinates); for (var v = 0; v < g.length; v++)b.push(g[v][0]), h.push(g[v][1]); console.log(h, b); for (var E = { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW }, $ = new Array, v = 0; v < h.length; v++) { var w = new google.maps.LatLng(h[v], b[v]); $.push(w) } var C = new google.maps.Polyline({ path: $, geodesic: !1, strokeColor: "#DC143C", strokeOpacity: .8, strokeWeight: 2, map: f }); C.setMap(f) } m(), t.dialog.close() }, function (u) { console.log(u) }) }), r(() => { console.log("onBeforeMount") }), i(() => { console.log("onMounted") }), o(() => { console.log("onBeforeUnmount") }), l(() => { console.log("onUnmounted") }), s("pageMounted", (c, d) => { console.log("pageMounted", d) }), s("pageInit", (c, d) => { console.log("pageInit", d) }), s("pageBeforeIn", (c, d) => { console.log("pageBeforeIn", d) }), s("pageAfterIn", (c, d) => { console.log("pageAfterIn", d) }), s("pageBeforeOut", (c, d) => { console.log("pageBeforeOut", d) }), s("pageAfterOut", (c, d) => { console.log("pageAfterOut", d) }), s("pageBeforeRemove", (c, d) => { console.log("pageBeforeRemove", d) }), function (c) {
    var d = c.$, u = c.$h, p = c.$root, m = c.$f7, f = c.$f7route, h = c.$f7router, b = c.$theme, g = c.$update, v = c.$store; return u`
  <div class="page">
    <div class="navbar">
      <div class="navbar-bg"></div>
      <div class="navbar-inner sliding">
        <div class="left">
          <a href="#" class="link back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">Back</span>
          </a>
        </div>
        <div class="title">Flight ${f.path.replace("/flight/", "")}</div>
      </div>
    </div>
    <div class="page-content">
      <div class="block block-strong" style="z-index: 9999; height: 300px;">
        <div id="map" style="height: 300px;"></div>
      </div>

      <p class="block-title">General Info</p>
      <div class="block block-strong">
        <div class="row"><p class="block-title">Aircraft</p><p id="aircraft"></p></div>
        <div class="row"><p class="block-title">Airline Name</p><p id="airline"></p></div>
      </div>

      <p class="block-title">Start</p>
      <div class="block block-strong">
        <div class="row"><p class="block-title">Timezome</p><p id="origtz"></p></div>
        <div class="row"><p class="block-title">Airport</p><p id="origairport"></p></div>
        <div class="row"><p class="block-title">City</p><p id="origcity"></p></div>
      </div>

      <p class="block-title">Destination</p>
      <div class="block block-strong">
        <div class="row"><p class="block-title">Timezome</p><p id="desttz"></p></div>
        <div class="row"><p class="block-title">Airport</p><p id="destairport"></p></div>
        <div class="row"><p class="block-title">City</p><p id="destcity"></p></div>
      </div>

      <p class="block-title">Flight Data</p>
      <div class="block block-strong">
        <div class="row"><p class="block-title">Actual Distance</p><p id="actualdist"></p></div>
        <div class="row"><p class="block-title">Planned Distance</p><p id="plandist"></p></div>
        <div class="row"><p class="block-title">Taken Distance</p><p id="takendist"></p></div>
        <div class="row"><p class="block-title">Speed</p><p id="speed"></p></div>
        <div class="row"><p class="block-title">Altitude</p><p id="altitude"></p></div>
        <div class="row"><p class="block-title">Fuel Burned</p><p id="fuel"></p></div>
        <div class="row"><p class="block-title">Status</p><p id="status"></p></div>
      </div>

      <p class="block-title">Departure</p>
      <div class="block block-strong">
        <div class="row"><p class="block-title">Scheduled Time</p><p id="scheddeptime"></p></div>
        <div class="row"><p class="block-title">Estimated Time</p><p id="estdeptime"></p></div>
        <div class="row"><p class="block-title">Actual Time</p><p id="actualdeptime"></p></div>
        <div class="row"><p class="block-title">Gate</p><p id="origgate"></p></div>
        <div class="row"><p class="block-title">Terminal</p><p id="origterm"></p></div>
        </div>

    <p class="block-title">Arrival</p>
      <div class="block block-strong">
        <div class="row"><p class="block-title">Scheduled Time</p><p id="schedarrtime"></p></div>
        <div class="row"><p class="block-title">Estimated Time</p><p id="estarrtime"></p></div>
        <div class="row"><p class="block-title">Actual Time</p><p id="actualarrtime"></p></div>
        <div class="row"><p class="block-title">Gate</p><p id="destgate"></p></div>
        <div class="row"><p class="block-title">Terminal</p><p id="destterm"></p></div>
      </div>
    
      <div class="block block-strong">
        <a class="button button-fill delete-flight color-red" href="#">Delete Flight</a>
      </div>
    </div>
  </div>
`}
} Qa.id = "d4fb2e0383"; Qa.style = `
  p {
    margin: 10px 0;
  }
`; var ap = [{ path: "/", component: Ys }, { path: "/flight/:flightId", component: Qa }, { path: "/add-flight", component: Ka }, { path: "(.*)", component: qs }]; Le.use([vs]); Pe.use([ls, cs, ds, us, ps, gs, Xa, xs, $s, ks, Ts, Ss, Ms, Ps, As, Is, Os, Bs]); const np = Da({ state: { products: [{ id: "1", title: "Apple iPhone 8", description: "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nisi tempora similique reiciendis, error nesciunt vero, blanditiis pariatur dolor, minima sed sapiente rerum, dolorem corrupti hic modi praesentium unde saepe perspiciatis." }, { id: "2", title: "Apple iPhone 8 Plus", description: "Velit odit autem modi saepe ratione totam minus, aperiam, labore quia provident temporibus quasi est ut aliquid blanditiis beatae suscipit odio vel! Nostrum porro sunt sint eveniet maiores, dolorem itaque!" }, { id: "3", title: "Apple iPhone X", description: "Expedita sequi perferendis quod illum pariatur aliquam, alias laboriosam! Vero blanditiis placeat, mollitia necessitatibus reprehenderit. Labore dolores amet quos, accusamus earum asperiores officiis assumenda optio architecto quia neque, quae eum." }] }, getters: { products({ state: n }) { return n.products } }, actions: { addProduct({ state: n }, e) { n.products = [...n.products, e] } } }); function Xs() {
  return function (n) {
    var e = n.$, t = n.$h, a = n.$root, s = n.$f7, r = n.$f7route, i = n.$f7router, o = n.$theme, l = n.$update, c = n.$store; return t`
  <div id="app">
    <!-- Your main view, should have "view-main" class -->
    <div class="view view-main view-init safe-areas" data-url="/"></div>
  </div>
`}
} Xs.id = "2ded08c013"; var ts = ue(), Fp = new Pe({ name: "WheresMyFlight", theme: "auto", colors: { primary: "#007aff" }, darkMode: !0, el: "#app", component: Xs, id: "dev.shuchir.wheresmyflight", store: np, routes: ap, serviceWorker: { path: "/service-worker.js" }, input: { scrollIntoViewOnFocus: ts.cordova, scrollIntoViewCentered: ts.cordova }, statusbar: { iosOverlaysWebView: !0, androidOverlaysWebView: !1 }, on: { init: function () { var n = this; n.device.cordova && Je.init(n) } } });
